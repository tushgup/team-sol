!(function (t) {
  var e = {};
  function r(n) {
    if (e[n]) return e[n].exports;
    var i = (e[n] = { i: n, l: !1, exports: {} });
    return t[n].call(i.exports, i, i.exports, r), (i.l = !0), i.exports;
  }
  (r.m = t),
    (r.c = e),
    (r.d = function (t, e, n) {
      r.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n });
    }),
    (r.r = function (t) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (r.t = function (t, e) {
      if ((1 & e && (t = r(t)), 8 & e)) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var n = Object.create(null);
      if (
        (r.r(n),
        Object.defineProperty(n, "default", { enumerable: !0, value: t }),
        2 & e && "string" != typeof t)
      )
        for (var i in t)
          r.d(
            n,
            i,
            function (e) {
              return t[e];
            }.bind(null, i)
          );
      return n;
    }),
    (r.n = function (t) {
      var e =
        t && t.__esModule
          ? function () {
              return t.default;
            }
          : function () {
              return t;
            };
      return r.d(e, "a", e), e;
    }),
    (r.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (r.p = ""),
    r((r.s = 69));
})([
  function (t, e, r) {
    var n = r(141);
    t.exports = function (t, e, r) {
      var i = null == t ? void 0 : n(t, e);
      return void 0 === i ? r : i;
    };
  },
  function (t, e, r) {
    "use strict";
    var n =
      (this && this.__importDefault) ||
      function (t) {
        return t && t.__esModule ? t : { default: t };
      };
    Object.defineProperty(e, "__esModule", { value: !0 });
    var i = r(8),
      o = r(12),
      a = n(r(145)),
      s = r(11),
      l = n(r(146));
    function h(t, e) {
      var r = o.getCoords(t),
        n = o.getCoords(e);
      if (2 !== r.length)
        throw new Error("<intersects> line1 must only contain 2 coordinates");
      if (2 !== n.length)
        throw new Error("<intersects> line2 must only contain 2 coordinates");
      var a = r[0][0],
        s = r[0][1],
        l = r[1][0],
        h = r[1][1],
        u = n[0][0],
        c = n[0][1],
        f = n[1][0],
        p = n[1][1],
        d = (p - c) * (l - a) - (f - u) * (h - s);
      if (0 == d) return null;
      var g = ((f - u) * (s - c) - (p - c) * (a - u)) / d,
        m = ((l - a) * (s - c) - (h - s) * (a - u)) / d;
      if (0 <= g && g <= 1 && 0 <= m && m <= 1) {
        var y = a + g * (l - a),
          _ = s + g * (h - s);
        return i.point([y, _]);
      }
      return null;
    }
    e.default = function (t, e) {
      var r = {},
        n = [];
      if (
        ("LineString" === t.type && (t = i.feature(t)),
        "LineString" === e.type && (e = i.feature(e)),
        "Feature" === t.type &&
          "Feature" === e.type &&
          null !== t.geometry &&
          null !== e.geometry &&
          "LineString" === t.geometry.type &&
          "LineString" === e.geometry.type &&
          2 === t.geometry.coordinates.length &&
          2 === e.geometry.coordinates.length)
      ) {
        var u = h(t, e);
        return u && n.push(u), i.featureCollection(n);
      }
      var c = l.default();
      return (
        c.load(a.default(e)),
        s.featureEach(a.default(t), function (t) {
          s.featureEach(c.search(t), function (e) {
            var i = h(t, e);
            if (i) {
              var a = o.getCoords(i).join(",");
              r[a] || ((r[a] = !0), n.push(i));
            }
          });
        }),
        i.featureCollection(n)
      );
    };
  },
  function (t, e, r) {
    "use strict";
    var n =
      (this && this.__importDefault) ||
      function (t) {
        return t && t.__esModule ? t : { default: t };
      };
    Object.defineProperty(e, "__esModule", { value: !0 });
    var i = n(r(49)),
      o = n(r(142)),
      a = n(r(143)),
      s = r(12);
    function l(t, e) {
      var r,
        n = !1;
      for (r = 0; r < t.coordinates.length; r++)
        if (m(t.coordinates[r], e.coordinates)) {
          n = !0;
          break;
        }
      return n;
    }
    function h(t, e) {
      for (var r = 0, n = e.coordinates; r < n.length; r++) {
        for (var i = n[r], o = !1, a = 0, s = t.coordinates; a < s.length; a++)
          if (m(i, s[a])) {
            o = !0;
            break;
          }
        if (!o) return !1;
      }
      return !0;
    }
    function u(t, e) {
      for (var r = !1, n = 0, i = e.coordinates; n < i.length; n++) {
        var o = i[n];
        if (
          (a.default(o, t, { ignoreEndVertices: !0 }) && (r = !0),
          !a.default(o, t))
        )
          return !1;
      }
      return !!r;
    }
    function c(t, e) {
      for (var r = 0, n = e.coordinates; r < n.length; r++) {
        var i = n[r];
        if (!o.default(i, t, { ignoreBoundary: !0 })) return !1;
      }
      return !0;
    }
    function f(t, e) {
      for (var r = !1, n = 0, i = e.coordinates; n < i.length; n++) {
        var o = i[n];
        if (
          (a.default({ type: "Point", coordinates: o }, t, {
            ignoreEndVertices: !0,
          }) && (r = !0),
          !a.default({ type: "Point", coordinates: o }, t, {
            ignoreEndVertices: !1,
          }))
        )
          return !1;
      }
      return r;
    }
    function p(t, e) {
      var r = !1,
        n = 0;
      if (!g(i.default(t), i.default(e))) return !1;
      for (; n < e.coordinates.length - 1; n++) {
        var a = y(e.coordinates[n], e.coordinates[n + 1]);
        if (
          o.default({ type: "Point", coordinates: a }, t, {
            ignoreBoundary: !0,
          })
        ) {
          r = !0;
          break;
        }
      }
      return r;
    }
    function d(t, e) {
      if ("Feature" === t.type && null === t.geometry) return !1;
      if ("Feature" === e.type && null === e.geometry) return !1;
      if (!g(i.default(t), i.default(e))) return !1;
      for (var r = 0, n = s.getGeom(e).coordinates; r < n.length; r++)
        for (var a = 0, l = n[r]; a < l.length; a++) {
          var h = l[a];
          if (!o.default(h, t)) return !1;
        }
      return !0;
    }
    function g(t, e) {
      return !(t[0] > e[0] || t[2] < e[2] || t[1] > e[1] || t[3] < e[3]);
    }
    function m(t, e) {
      return t[0] === e[0] && t[1] === e[1];
    }
    function y(t, e) {
      return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2];
    }
    (e.default = function (t, e) {
      var r = s.getGeom(t),
        n = s.getGeom(e),
        i = s.getType(t),
        g = s.getType(e),
        y = s.getCoords(t),
        _ = s.getCoords(e);
      switch (i) {
        case "Point":
          switch (g) {
            case "Point":
              return m(y, _);
            default:
              throw new Error("feature2 " + g + " geometry not supported");
          }
        case "MultiPoint":
          switch (g) {
            case "Point":
              return l(r, n);
            case "MultiPoint":
              return h(r, n);
            default:
              throw new Error("feature2 " + g + " geometry not supported");
          }
        case "LineString":
          switch (g) {
            case "Point":
              return a.default(n, r, { ignoreEndVertices: !0 });
            case "LineString":
              return f(r, n);
            case "MultiPoint":
              return u(r, n);
            default:
              throw new Error("feature2 " + g + " geometry not supported");
          }
        case "Polygon":
          switch (g) {
            case "Point":
              return o.default(n, r, { ignoreBoundary: !0 });
            case "LineString":
              return p(r, n);
            case "Polygon":
              return d(r, n);
            case "MultiPoint":
              return c(r, n);
            default:
              throw new Error("feature2 " + g + " geometry not supported");
          }
        default:
          throw new Error("feature1 " + i + " geometry not supported");
      }
    }),
      (e.isPointInMultiPoint = l),
      (e.isMultiPointInMultiPoint = h),
      (e.isMultiPointOnLine = u),
      (e.isMultiPointInPoly = c),
      (e.isLineOnLine = f),
      (e.isLineInPoly = p),
      (e.isPolyInPoly = d),
      (e.doBBoxOverlap = g),
      (e.compareCoords = m),
      (e.getMidpoint = y);
  },
  function (t, e) {
    t.exports = function (t) {
      var e = typeof t;
      return null != t && ("object" == e || "function" == e);
    };
  },
  function (t, e, r) {
    var n = r(30),
      i = r(149),
      o = r(47),
      a = r(160),
      s = r(161),
      l = o(function (t) {
        var e = s(t),
          r = n(t, a);
        return (
          (e = "function" == typeof e ? e : void 0) && r.pop(),
          r.length && r[0] === t[0] ? i(r, void 0, e) : []
        );
      });
    t.exports = l;
  },
  function (t, e, r) {
    var n = r(35),
      i = "object" == typeof self && self && self.Object === Object && self,
      o = n || i || Function("return this")();
    t.exports = o;
  },
  function (t, e) {
    t.exports = function (t) {
      return null != t && "object" == typeof t;
    };
  },
  function (t, e) {
    var r = Array.isArray;
    t.exports = r;
  },
  function (t, e, r) {
    "use strict";
    function n(t, e, r) {
      void 0 === r && (r = {});
      var n = { type: "Feature" };
      return (
        (0 !== r.id && !r.id) || (n.id = r.id),
        r.bbox && (n.bbox = r.bbox),
        (n.properties = e || {}),
        (n.geometry = t),
        n
      );
    }
    function i(t, e, r) {
      return (
        void 0 === r && (r = {}), n({ type: "Point", coordinates: t }, e, r)
      );
    }
    function o(t, e, r) {
      void 0 === r && (r = {});
      for (var i = 0, o = t; i < o.length; i++) {
        var a = o[i];
        if (a.length < 4)
          throw new Error(
            "Each LinearRing of a Polygon must have 4 or more Positions."
          );
        for (var s = 0; s < a[a.length - 1].length; s++)
          if (a[a.length - 1][s] !== a[0][s])
            throw new Error("First and last Position are not equivalent.");
      }
      return n({ type: "Polygon", coordinates: t }, e, r);
    }
    function a(t, e, r) {
      if ((void 0 === r && (r = {}), t.length < 2))
        throw new Error(
          "coordinates must be an array of two or more positions"
        );
      return n({ type: "LineString", coordinates: t }, e, r);
    }
    function s(t, e) {
      void 0 === e && (e = {});
      var r = { type: "FeatureCollection" };
      return (
        e.id && (r.id = e.id), e.bbox && (r.bbox = e.bbox), (r.features = t), r
      );
    }
    function l(t, e, r) {
      return (
        void 0 === r && (r = {}),
        n({ type: "MultiLineString", coordinates: t }, e, r)
      );
    }
    function h(t, e, r) {
      return (
        void 0 === r && (r = {}),
        n({ type: "MultiPoint", coordinates: t }, e, r)
      );
    }
    function u(t, e, r) {
      return (
        void 0 === r && (r = {}),
        n({ type: "MultiPolygon", coordinates: t }, e, r)
      );
    }
    function c(t, r) {
      void 0 === r && (r = "kilometers");
      var n = e.factors[r];
      if (!n) throw new Error(r + " units is invalid");
      return t * n;
    }
    function f(t, r) {
      void 0 === r && (r = "kilometers");
      var n = e.factors[r];
      if (!n) throw new Error(r + " units is invalid");
      return t / n;
    }
    function p(t) {
      return ((t % (2 * Math.PI)) * 180) / Math.PI;
    }
    function d(t) {
      return !isNaN(t) && null !== t && !Array.isArray(t) && !/^\s*$/.test(t);
    }
    Object.defineProperty(e, "__esModule", { value: !0 }),
      (e.earthRadius = 6371008.8),
      (e.factors = {
        centimeters: 100 * e.earthRadius,
        centimetres: 100 * e.earthRadius,
        degrees: e.earthRadius / 111325,
        feet: 3.28084 * e.earthRadius,
        inches: 39.37 * e.earthRadius,
        kilometers: e.earthRadius / 1e3,
        kilometres: e.earthRadius / 1e3,
        meters: e.earthRadius,
        metres: e.earthRadius,
        miles: e.earthRadius / 1609.344,
        millimeters: 1e3 * e.earthRadius,
        millimetres: 1e3 * e.earthRadius,
        nauticalmiles: e.earthRadius / 1852,
        radians: 1,
        yards: e.earthRadius / 1.0936,
      }),
      (e.unitsFactors = {
        centimeters: 100,
        centimetres: 100,
        degrees: 1 / 111325,
        feet: 3.28084,
        inches: 39.37,
        kilometers: 0.001,
        kilometres: 0.001,
        meters: 1,
        metres: 1,
        miles: 1 / 1609.344,
        millimeters: 1e3,
        millimetres: 1e3,
        nauticalmiles: 1 / 1852,
        radians: 1 / e.earthRadius,
        yards: 1 / 1.0936,
      }),
      (e.areaFactors = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046,
      }),
      (e.feature = n),
      (e.geometry = function (t, e, r) {
        switch ((void 0 === r && (r = {}), t)) {
          case "Point":
            return i(e).geometry;
          case "LineString":
            return a(e).geometry;
          case "Polygon":
            return o(e).geometry;
          case "MultiPoint":
            return h(e).geometry;
          case "MultiLineString":
            return l(e).geometry;
          case "MultiPolygon":
            return u(e).geometry;
          default:
            throw new Error(t + " is invalid");
        }
      }),
      (e.point = i),
      (e.points = function (t, e, r) {
        return (
          void 0 === r && (r = {}),
          s(
            t.map(function (t) {
              return i(t, e);
            }),
            r
          )
        );
      }),
      (e.polygon = o),
      (e.polygons = function (t, e, r) {
        return (
          void 0 === r && (r = {}),
          s(
            t.map(function (t) {
              return o(t, e);
            }),
            r
          )
        );
      }),
      (e.lineString = a),
      (e.lineStrings = function (t, e, r) {
        return (
          void 0 === r && (r = {}),
          s(
            t.map(function (t) {
              return a(t, e);
            }),
            r
          )
        );
      }),
      (e.featureCollection = s),
      (e.multiLineString = l),
      (e.multiPoint = h),
      (e.multiPolygon = u),
      (e.geometryCollection = function (t, e, r) {
        return (
          void 0 === r && (r = {}),
          n({ type: "GeometryCollection", geometries: t }, e, r)
        );
      }),
      (e.round = function (t, e) {
        if ((void 0 === e && (e = 0), e && !(0 <= e)))
          throw new Error("precision must be a positive number");
        var r = Math.pow(10, e || 0);
        return Math.round(t * r) / r;
      }),
      (e.radiansToLength = c),
      (e.lengthToRadians = f),
      (e.lengthToDegrees = function (t, e) {
        return p(f(t, e));
      }),
      (e.bearingToAzimuth = function (t) {
        var e = t % 360;
        return e < 0 && (e += 360), e;
      }),
      (e.radiansToDegrees = p),
      (e.degreesToRadians = function (t) {
        return ((t % 360) * Math.PI) / 180;
      }),
      (e.convertLength = function (t, e, r) {
        if (
          (void 0 === e && (e = "kilometers"),
          void 0 === r && (r = "kilometers"),
          !(0 <= t))
        )
          throw new Error("length must be a positive number");
        return c(f(t, e), r);
      }),
      (e.convertArea = function (t, r, n) {
        if (
          (void 0 === r && (r = "meters"),
          void 0 === n && (n = "kilometers"),
          !(0 <= t))
        )
          throw new Error("area must be a positive number");
        var i = e.areaFactors[r];
        if (!i) throw new Error("invalid original units");
        var o = e.areaFactors[n];
        if (!o) throw new Error("invalid final units");
        return (t / i) * o;
      }),
      (e.isNumber = d),
      (e.isObject = function (t) {
        return !!t && t.constructor === Object;
      }),
      (e.validateBBox = function (t) {
        if (!t) throw new Error("bbox is required");
        if (!Array.isArray(t)) throw new Error("bbox must be an Array");
        if (4 !== t.length && 6 !== t.length)
          throw new Error("bbox must be an Array of 4 or 6 numbers");
        t.forEach(function (t) {
          if (!d(t)) throw new Error("bbox must only contain numbers");
        });
      }),
      (e.validateId = function (t) {
        if (!t) throw new Error("id is required");
        if (-1 === ["string", "number"].indexOf(typeof t))
          throw new Error("id must be a number or a string");
      }),
      (e.radians2degrees = function () {
        throw new Error("method has been renamed to `radiansToDegrees`");
      }),
      (e.degrees2radians = function () {
        throw new Error("method has been renamed to `degreesToRadians`");
      }),
      (e.distanceToDegrees = function () {
        throw new Error("method has been renamed to `lengthToDegrees`");
      }),
      (e.distanceToRadians = function () {
        throw new Error("method has been renamed to `lengthToRadians`");
      }),
      (e.radiansToDistance = function () {
        throw new Error("method has been renamed to `radiansToLength`");
      }),
      (e.bearingToAngle = function () {
        throw new Error("method has been renamed to `bearingToAzimuth`");
      }),
      (e.convertDistance = function () {
        throw new Error("method has been renamed to `convertLength`");
      });
  },
  function (t, e, r) {
    "use strict";
    Object.defineProperty(e, "__esModule", { value: !0 });
    var n = r(8);
    function i(t, e, r, n, i, o, a, s) {
      var l,
        h,
        u,
        c,
        f = { x: null, y: null, onLine1: !1, onLine2: !1 };
      return 0 == (l = (s - o) * (r - t) - (a - i) * (n - e))
        ? null !== f.x && null !== f.y && f
        : ((c = (r - t) * (h = e - o) - (n - e) * (u = t - i)),
          (h = ((a - i) * h - (s - o) * u) / l),
          (u = c / l),
          (f.x = t + h * (r - t)),
          (f.y = e + h * (n - e)),
          0 <= h && h <= 1 && (f.onLine1 = !0),
          0 <= u && u <= 1 && (f.onLine2 = !0),
          !(!f.onLine1 || !f.onLine2) && [f.x, f.y]);
    }
    e.default = function (t) {
      var e,
        r,
        o = { type: "FeatureCollection", features: [] };
      if ("LineString" === (r = "Feature" === t.type ? t.geometry : t).type)
        e = [r.coordinates];
      else if ("MultiLineString" === r.type) e = r.coordinates;
      else if ("MultiPolygon" === r.type)
        e = [].concat.apply([], r.coordinates);
      else {
        if ("Polygon" !== r.type)
          throw new Error(
            "Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry"
          );
        e = r.coordinates;
      }
      return (
        e.forEach(function (t) {
          e.forEach(function (e) {
            for (var r = 0; r < t.length - 1; r++)
              for (var a = r; a < e.length - 1; a++) {
                if (t === e) {
                  if (1 === Math.abs(r - a)) continue;
                  if (
                    0 === r &&
                    a === t.length - 2 &&
                    t[r][0] === t[t.length - 1][0] &&
                    t[r][1] === t[t.length - 1][1]
                  )
                    continue;
                }
                var s = i(
                  t[r][0],
                  t[r][1],
                  t[r + 1][0],
                  t[r + 1][1],
                  e[a][0],
                  e[a][1],
                  e[a + 1][0],
                  e[a + 1][1]
                );
                s && o.features.push(n.point([s[0], s[1]]));
              }
          });
        }),
        o
      );
    };
  },
  function (t, e, r) {
    var n = r(21),
      i = r(85),
      o = r(86),
      a = n ? n.toStringTag : void 0;
    t.exports = function (t) {
      return null == t
        ? void 0 === t
          ? "[object Undefined]"
          : "[object Null]"
        : a && a in Object(t)
        ? i(t)
        : o(t);
    };
  },
  function (t, e, r) {
    "use strict";
    Object.defineProperty(e, "__esModule", { value: !0 });
    var n = r(8);
    function i(t, e, r) {
      if (null !== t)
        for (
          var n,
            o,
            a,
            s,
            l,
            h,
            u,
            c,
            f = 0,
            p = 0,
            d = t.type,
            g = "FeatureCollection" === d,
            m = "Feature" === d,
            y = g ? t.features.length : 1,
            _ = 0;
          _ < y;
          _++
        ) {
          l = (c =
            !!(u = g ? t.features[_].geometry : m ? t.geometry : t) &&
            "GeometryCollection" === u.type)
            ? u.geometries.length
            : 1;
          for (var v = 0; v < l; v++) {
            var b = 0,
              L = 0;
            if (null !== (s = c ? u.geometries[v] : u)) {
              h = s.coordinates;
              var k = s.type;
              switch (
                ((f = !r || ("Polygon" !== k && "MultiPolygon" !== k) ? 0 : 1),
                k)
              ) {
                case null:
                  break;
                case "Point":
                  if (!1 === e(h, p, _, b, L)) return !1;
                  p++, b++;
                  break;
                case "LineString":
                case "MultiPoint":
                  for (n = 0; n < h.length; n++) {
                    if (!1 === e(h[n], p, _, b, L)) return !1;
                    p++, "MultiPoint" === k && b++;
                  }
                  "LineString" === k && b++;
                  break;
                case "Polygon":
                case "MultiLineString":
                  for (n = 0; n < h.length; n++) {
                    for (o = 0; o < h[n].length - f; o++) {
                      if (!1 === e(h[n][o], p, _, b, L)) return !1;
                      p++;
                    }
                    "MultiLineString" === k && b++, "Polygon" === k && L++;
                  }
                  "Polygon" === k && b++;
                  break;
                case "MultiPolygon":
                  for (n = 0; n < h.length; n++) {
                    for (o = L = 0; o < h[n].length; o++) {
                      for (a = 0; a < h[n][o].length - f; a++) {
                        if (!1 === e(h[n][o][a], p, _, b, L)) return !1;
                        p++;
                      }
                      L++;
                    }
                    b++;
                  }
                  break;
                case "GeometryCollection":
                  for (n = 0; n < s.geometries.length; n++)
                    if (!1 === i(s.geometries[n], e, r)) return !1;
                  break;
                default:
                  throw new Error("Unknown Geometry Type");
              }
            }
          }
        }
    }
    function o(t, e) {
      var r;
      switch (t.type) {
        case "FeatureCollection":
          for (
            r = 0;
            r < t.features.length && !1 !== e(t.features[r].properties, r);
            r++
          );
          break;
        case "Feature":
          e(t.properties, 0);
      }
    }
    function a(t, e) {
      if ("Feature" === t.type) e(t, 0);
      else if ("FeatureCollection" === t.type)
        for (
          var r = 0;
          r < t.features.length && !1 !== e(t.features[r], r);
          r++
        );
    }
    function s(t, e) {
      var r,
        n,
        i,
        o,
        a,
        s,
        l,
        h,
        u,
        c,
        f = 0,
        p = "FeatureCollection" === t.type,
        d = "Feature" === t.type,
        g = p ? t.features.length : 1;
      for (r = 0; r < g; r++) {
        for (
          s = p ? t.features[r].geometry : d ? t.geometry : t,
            h = p ? t.features[r].properties : d ? t.properties : {},
            u = p ? t.features[r].bbox : d ? t.bbox : void 0,
            c = p ? t.features[r].id : d ? t.id : void 0,
            a = (l = !!s && "GeometryCollection" === s.type)
              ? s.geometries.length
              : 1,
            i = 0;
          i < a;
          i++
        )
          if (null !== (o = l ? s.geometries[i] : s))
            switch (o.type) {
              case "Point":
              case "LineString":
              case "MultiPoint":
              case "Polygon":
              case "MultiLineString":
              case "MultiPolygon":
                if (!1 === e(o, f, h, u, c)) return !1;
                break;
              case "GeometryCollection":
                for (n = 0; n < o.geometries.length; n++)
                  if (!1 === e(o.geometries[n], f, h, u, c)) return !1;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          else if (!1 === e(null, f, h, u, c)) return !1;
        f++;
      }
    }
    function l(t, e) {
      s(t, function (t, r, i, o, a) {
        var s,
          l = null === t ? null : t.type;
        switch (l) {
          case null:
          case "Point":
          case "LineString":
          case "Polygon":
            return (
              !1 !== e(n.feature(t, i, { bbox: o, id: a }), r, 0) && void 0
            );
        }
        switch (l) {
          case "MultiPoint":
            s = "Point";
            break;
          case "MultiLineString":
            s = "LineString";
            break;
          case "MultiPolygon":
            s = "Polygon";
        }
        for (var h = 0; h < t.coordinates.length; h++) {
          var u = { type: s, coordinates: t.coordinates[h] };
          if (!1 === e(n.feature(u, i), r, h)) return !1;
        }
      });
    }
    function h(t, e) {
      l(t, function (t, r, o) {
        var a = 0;
        if (t.geometry) {
          var s = t.geometry.type;
          if ("Point" !== s && "MultiPoint" !== s) {
            var l,
              h = 0,
              u = 0,
              c = 0;
            return (
              !1 !==
                i(t, function (i, s, f, p, d) {
                  if (void 0 === l || h < r || u < p || c < d)
                    return (l = i), (h = r), (u = p), (c = d), void (a = 0);
                  var g = n.lineString([l, i], t.properties);
                  if (!1 === e(g, r, o, d, a)) return !1;
                  a++, (l = i);
                }) && void 0
            );
          }
        }
      });
    }
    function u(t, e) {
      if (!t) throw new Error("geojson is required");
      l(t, function (t, r, i) {
        if (null !== t.geometry) {
          var o = t.geometry.type,
            a = t.geometry.coordinates;
          switch (o) {
            case "LineString":
              if (!1 === e(t, r, i, 0, 0)) return !1;
              break;
            case "Polygon":
              for (var s = 0; s < a.length; s++)
                if (!1 === e(n.lineString(a[s], t.properties), r, i, s))
                  return !1;
          }
        }
      });
    }
    (e.coordEach = i),
      (e.coordReduce = function (t, e, r, n) {
        var o = r;
        return (
          i(
            t,
            function (t, n, i, a, s) {
              o = 0 === n && void 0 === r ? t : e(o, t, n, i, a, s);
            },
            n
          ),
          o
        );
      }),
      (e.propEach = o),
      (e.propReduce = function (t, e, r) {
        var n = r;
        return (
          o(t, function (t, i) {
            n = 0 === i && void 0 === r ? t : e(n, t, i);
          }),
          n
        );
      }),
      (e.featureEach = a),
      (e.featureReduce = function (t, e, r) {
        var n = r;
        return (
          a(t, function (t, i) {
            n = 0 === i && void 0 === r ? t : e(n, t, i);
          }),
          n
        );
      }),
      (e.coordAll = function (t) {
        var e = [];
        return (
          i(t, function (t) {
            e.push(t);
          }),
          e
        );
      }),
      (e.geomEach = s),
      (e.geomReduce = function (t, e, r) {
        var n = r;
        return (
          s(t, function (t, i, o, a, s) {
            n = 0 === i && void 0 === r ? t : e(n, t, i, o, a, s);
          }),
          n
        );
      }),
      (e.flattenEach = l),
      (e.flattenReduce = function (t, e, r) {
        var n = r;
        return (
          l(t, function (t, i, o) {
            n = 0 === i && 0 === o && void 0 === r ? t : e(n, t, i, o);
          }),
          n
        );
      }),
      (e.segmentEach = h),
      (e.segmentReduce = function (t, e, r) {
        var n = r,
          i = !1;
        return (
          h(t, function (t, o, a, s, l) {
            (n = !1 === i && void 0 === r ? t : e(n, t, o, a, s, l)), (i = !0);
          }),
          n
        );
      }),
      (e.lineEach = u),
      (e.lineReduce = function (t, e, r) {
        var n = r;
        return (
          u(t, function (t, i, o, a) {
            n = 0 === i && void 0 === r ? t : e(n, t, i, o, a);
          }),
          n
        );
      }),
      (e.findSegment = function (t, e) {
        if (((e = e || {}), !n.isObject(e)))
          throw new Error("options is invalid");
        var r,
          i = e.featureIndex || 0,
          o = e.multiFeatureIndex || 0,
          a = e.geometryIndex || 0,
          s = e.segmentIndex || 0,
          l = e.properties;
        switch (t.type) {
          case "FeatureCollection":
            i < 0 && (i = t.features.length + i),
              (l = l || t.features[i].properties),
              (r = t.features[i].geometry);
            break;
          case "Feature":
            (l = l || t.properties), (r = t.geometry);
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            r = t;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (null === r) return null;
        var h = r.coordinates;
        switch (r.type) {
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
            return (
              s < 0 && (s = h.length + s - 1),
              n.lineString([h[s], h[s + 1]], l, e)
            );
          case "Polygon":
            return (
              a < 0 && (a = h.length + a),
              s < 0 && (s = h[a].length + s - 1),
              n.lineString([h[a][s], h[a][s + 1]], l, e)
            );
          case "MultiLineString":
            return (
              o < 0 && (o = h.length + o),
              s < 0 && (s = h[o].length + s - 1),
              n.lineString([h[o][s], h[o][s + 1]], l, e)
            );
          case "MultiPolygon":
            return (
              o < 0 && (o = h.length + o),
              a < 0 && (a = h[o].length + a),
              s < 0 && (s = h[o][a].length - s - 1),
              n.lineString([h[o][a][s], h[o][a][s + 1]], l, e)
            );
        }
        throw new Error("geojson is invalid");
      }),
      (e.findPoint = function (t, e) {
        if (((e = e || {}), !n.isObject(e)))
          throw new Error("options is invalid");
        var r,
          i = e.featureIndex || 0,
          o = e.multiFeatureIndex || 0,
          a = e.geometryIndex || 0,
          s = e.coordIndex || 0,
          l = e.properties;
        switch (t.type) {
          case "FeatureCollection":
            i < 0 && (i = t.features.length + i),
              (l = l || t.features[i].properties),
              (r = t.features[i].geometry);
            break;
          case "Feature":
            (l = l || t.properties), (r = t.geometry);
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            r = t;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (null === r) return null;
        var h = r.coordinates;
        switch (r.type) {
          case "Point":
            return n.point(h, l, e);
          case "MultiPoint":
            return o < 0 && (o = h.length + o), n.point(h[o], l, e);
          case "LineString":
            return s < 0 && (s = h.length + s), n.point(h[s], l, e);
          case "Polygon":
            return (
              a < 0 && (a = h.length + a),
              s < 0 && (s = h[a].length + s),
              n.point(h[a][s], l, e)
            );
          case "MultiLineString":
            return (
              o < 0 && (o = h.length + o),
              s < 0 && (s = h[o].length + s),
              n.point(h[o][s], l, e)
            );
          case "MultiPolygon":
            return (
              o < 0 && (o = h.length + o),
              a < 0 && (a = h[o].length + a),
              s < 0 && (s = h[o][a].length - s),
              n.point(h[o][a][s], l, e)
            );
        }
        throw new Error("geojson is invalid");
      });
  },
  function (t, e, r) {
    "use strict";
    Object.defineProperty(e, "__esModule", { value: !0 });
    var n = r(8);
    (e.getCoord = function (t) {
      if (!t) throw new Error("coord is required");
      if (!Array.isArray(t)) {
        if (
          "Feature" === t.type &&
          null !== t.geometry &&
          "Point" === t.geometry.type
        )
          return t.geometry.coordinates;
        if ("Point" === t.type) return t.coordinates;
      }
      if (
        Array.isArray(t) &&
        2 <= t.length &&
        !Array.isArray(t[0]) &&
        !Array.isArray(t[1])
      )
        return t;
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }),
      (e.getCoords = function (t) {
        if (Array.isArray(t)) return t;
        if ("Feature" === t.type) {
          if (null !== t.geometry) return t.geometry.coordinates;
        } else if (t.coordinates) return t.coordinates;
        throw new Error(
          "coords must be GeoJSON Feature, Geometry Object or an Array"
        );
      }),
      (e.containsNumber = function t(e) {
        if (1 < e.length && n.isNumber(e[0]) && n.isNumber(e[1])) return !0;
        if (Array.isArray(e[0]) && e[0].length) return t(e[0]);
        throw new Error("coordinates must only contain numbers");
      }),
      (e.geojsonType = function (t, e, r) {
        if (!e || !r) throw new Error("type and name required");
        if (!t || t.type !== e)
          throw new Error(
            "Invalid input to " + r + ": must be a " + e + ", given " + t.type
          );
      }),
      (e.featureOf = function (t, e, r) {
        if (!t) throw new Error("No feature passed");
        if (!r) throw new Error(".featureOf() requires a name");
        if (!t || "Feature" !== t.type || !t.geometry)
          throw new Error(
            "Invalid input to " + r + ", Feature with geometry required"
          );
        if (!t.geometry || t.geometry.type !== e)
          throw new Error(
            "Invalid input to " +
              r +
              ": must be a " +
              e +
              ", given " +
              t.geometry.type
          );
      }),
      (e.collectionOf = function (t, e, r) {
        if (!t) throw new Error("No featureCollection passed");
        if (!r) throw new Error(".collectionOf() requires a name");
        if (!t || "FeatureCollection" !== t.type)
          throw new Error(
            "Invalid input to " + r + ", FeatureCollection required"
          );
        for (var n = 0, i = t.features; n < i.length; n++) {
          var o = i[n];
          if (!o || "Feature" !== o.type || !o.geometry)
            throw new Error(
              "Invalid input to " + r + ", Feature with geometry required"
            );
          if (!o.geometry || o.geometry.type !== e)
            throw new Error(
              "Invalid input to " +
                r +
                ": must be a " +
                e +
                ", given " +
                o.geometry.type
            );
        }
      }),
      (e.getGeom = function (t) {
        return "Feature" === t.type ? t.geometry : t;
      }),
      (e.getType = function (t, e) {
        return "FeatureCollection" === t.type
          ? "FeatureCollection"
          : "GeometryCollection" === t.type
          ? "GeometryCollection"
          : "Feature" === t.type && null !== t.geometry
          ? t.geometry.type
          : t.type;
      });
  },
  function (t, e, r) {
    var n = r(73),
      i = r(74),
      o = r(75),
      a = r(76),
      s = r(77);
    function l(t) {
      var e = -1,
        r = null == t ? 0 : t.length;
      for (this.clear(); ++e < r; ) {
        var n = t[e];
        this.set(n[0], n[1]);
      }
    }
    (l.prototype.clear = n),
      (l.prototype.delete = i),
      (l.prototype.get = o),
      (l.prototype.has = a),
      (l.prototype.set = s),
      (t.exports = l);
  },
  function (t, e, r) {
    var n = r(15);
    t.exports = function (t, e) {
      for (var r = t.length; r--; ) if (n(t[r][0], e)) return r;
      return -1;
    };
  },
  function (t, e) {
    t.exports = function (t, e) {
      return t === e || (t != t && e != e);
    };
  },
  function (t, e, r) {
    var n = r(19)(Object, "create");
    t.exports = n;
  },
  function (t, e, r) {
    var n = r(99);
    t.exports = function (t, e) {
      var r = t.__data__;
      return n(e) ? r["string" == typeof e ? "string" : "hash"] : r.map;
    };
  },
  function (t, e) {
    var r = /^(?:0|[1-9]\d*)$/;
    t.exports = function (t, e) {
      var n = typeof t;
      return (
        !!(e = null == e ? 9007199254740991 : e) &&
        ("number" == n || ("symbol" != n && r.test(t))) &&
        -1 < t &&
        t % 1 == 0 &&
        t < e
      );
    };
  },
  function (t, e, r) {
    var n = r(83),
      i = r(90);
    t.exports = function (t, e) {
      var r = i(t, e);
      return n(r) ? r : void 0;
    };
  },
  function (t, e, r) {
    var n = r(10),
      i = r(3);
    t.exports = function (t) {
      if (!i(t)) return !1;
      var e = n(t);
      return (
        "[object Function]" == e ||
        "[object GeneratorFunction]" == e ||
        "[object AsyncFunction]" == e ||
        "[object Proxy]" == e
      );
    };
  },
  function (t, e, r) {
    var n = r(5).Symbol;
    t.exports = n;
  },
  function (t, e, r) {
    var n = r(91),
      i = r(98),
      o = r(100),
      a = r(101),
      s = r(102);
    function l(t) {
      var e = -1,
        r = null == t ? 0 : t.length;
      for (this.clear(); ++e < r; ) {
        var n = t[e];
        this.set(n[0], n[1]);
      }
    }
    (l.prototype.clear = n),
      (l.prototype.delete = i),
      (l.prototype.get = o),
      (l.prototype.has = a),
      (l.prototype.set = s),
      (t.exports = l);
  },
  function (t, e, r) {
    var n = r(37);
    t.exports = function (t, e, r) {
      "__proto__" == e && n
        ? n(t, e, { configurable: !0, enumerable: !0, value: r, writable: !0 })
        : (t[e] = r);
    };
  },
  function (t, e) {
    t.exports = function (t) {
      return (
        t.webpackPolyfill ||
          ((t.deprecate = function () {}),
          (t.paths = []),
          t.children || (t.children = []),
          Object.defineProperty(t, "loaded", {
            enumerable: !0,
            get: function () {
              return t.l;
            },
          }),
          Object.defineProperty(t, "id", {
            enumerable: !0,
            get: function () {
              return t.i;
            },
          }),
          (t.webpackPolyfill = 1)),
        t
      );
    };
  },
  function (t, e, r) {
    var n = r(114),
      i = r(6),
      o = Object.prototype,
      a = o.hasOwnProperty,
      s = o.propertyIsEnumerable,
      l = n(
        (function () {
          return arguments;
        })()
      )
        ? n
        : function (t) {
            return i(t) && a.call(t, "callee") && !s.call(t, "callee");
          };
    t.exports = l;
  },
  function (t, e, r) {
    var n = r(20),
      i = r(27);
    t.exports = function (t) {
      return null != t && i(t.length) && !n(t);
    };
  },
  function (t, e) {
    t.exports = function (t) {
      return (
        "number" == typeof t && -1 < t && t % 1 == 0 && t <= 9007199254740991
      );
    };
  },
  function (t, e, r) {
    var n = r(7),
      i = r(135),
      o = r(136),
      a = r(139);
    t.exports = function (t, e) {
      return n(t) ? t : i(t, e) ? [t] : o(a(t));
    };
  },
  function (t, e, r) {
    var n = r(10),
      i = r(6);
    t.exports = function (t) {
      return "symbol" == typeof t || (i(t) && "[object Symbol]" == n(t));
    };
  },
  function (t, e) {
    t.exports = function (t, e) {
      for (var r = -1, n = null == t ? 0 : t.length, i = Array(n); ++r < n; )
        i[r] = e(t[r], r, t);
      return i;
    };
  },
  function (t, e, r) {
    var n = r(29);
    t.exports = function (t) {
      if ("string" == typeof t || n(t)) return t;
      var e = t + "";
      return "0" == e && 1 / t == -1 / 0 ? "-0" : e;
    };
  },
  function (t, e, r) {
    var n = r(71),
      i = r(125)(function (t, e, r) {
        n(t, e, r);
      });
    t.exports = i;
  },
  function (t, e, r) {
    (function (e) {
      t.exports = (function () {
        "use strict";
        function t(t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        }
        function r(t, e) {
          for (var r = 0; r < e.length; r++) {
            var n = e[r];
            (n.enumerable = n.enumerable || !1),
              (n.configurable = !0),
              "value" in n && (n.writable = !0),
              Object.defineProperty(t, n.key, n);
          }
        }
        function n(t, e, n) {
          return e && r(t.prototype, e), n && r(t, n), t;
        }
        var i = function e(r, n) {
          t(this, e),
            (this.next = null),
            (this.key = r),
            (this.data = n),
            (this.left = null),
            (this.right = null);
        };
        function o(t, e) {
          return e < t ? 1 : t < e ? -1 : 0;
        }
        function a(t, e, r) {
          for (var n = new i(null, null), o = n, a = n; ; ) {
            var s = r(t, e.key);
            if (s < 0) {
              if (null === e.left) break;
              if (r(t, e.left.key) < 0) {
                var l = e.left;
                if (((e.left = l.right), (l.right = e), null === (e = l).left))
                  break;
              }
              (a.left = e), (e = (a = e).left);
            } else {
              if (!(0 < s)) break;
              if (null === e.right) break;
              if (0 < r(t, e.right.key)) {
                var h = e.right;
                if (((e.right = h.left), (h.left = e), null === (e = h).right))
                  break;
              }
              (o.right = e), (e = (o = e).right);
            }
          }
          return (
            (o.right = e.left),
            (a.left = e.right),
            (e.left = n.right),
            (e.right = n.left),
            e
          );
        }
        function s(t, e, r, n) {
          var o = new i(t, e);
          if (null === r) return (o.left = o.right = null), o;
          var s = n(t, (r = a(t, r, n)).key);
          return (
            s < 0
              ? ((o.left = r.left), ((o.right = r).left = null))
              : 0 <= s && ((o.right = r.right), ((o.left = r).right = null)),
            o
          );
        }
        function l(t, e, r) {
          var n = null,
            i = null;
          if (e) {
            var o = r((e = a(t, e, r)).key, t);
            0 === o
              ? ((n = e.left), (i = e.right))
              : o < 0
              ? ((i = e.right), (e.right = null), (n = e))
              : ((n = e.left), (e.left = null), (i = e));
          }
          return { left: n, right: i };
        }
        var h = (function () {
            function e() {
              var r =
                0 < arguments.length && void 0 !== arguments[0]
                  ? arguments[0]
                  : o;
              t(this, e),
                (this._root = null),
                (this._size = 0),
                (this._comparator = r);
            }
            return (
              n(e, [
                {
                  key: "insert",
                  value: function (t, e) {
                    return (
                      this._size++,
                      (this._root = s(t, e, this._root, this._comparator))
                    );
                  },
                },
                {
                  key: "add",
                  value: function (t, e) {
                    var r = new i(t, e);
                    null === this._root &&
                      ((r.left = r.right = null),
                      this._size++,
                      (this._root = r));
                    var n = this._comparator,
                      o = a(t, this._root, n),
                      s = n(t, o.key);
                    return (
                      0 === s
                        ? (this._root = o)
                        : (s < 0
                            ? ((r.left = o.left), ((r.right = o).left = null))
                            : 0 < s &&
                              ((r.right = o.right),
                              ((r.left = o).right = null)),
                          this._size++,
                          (this._root = r)),
                      this._root
                    );
                  },
                },
                {
                  key: "remove",
                  value: function (t) {
                    this._root = this._remove(t, this._root, this._comparator);
                  },
                },
                {
                  key: "_remove",
                  value: function (t, e, r) {
                    var n;
                    return null === e
                      ? null
                      : 0 === r(t, (e = a(t, e, r)).key)
                      ? (null === e.left
                          ? (n = e.right)
                          : ((n = a(t, e.left, r)).right = e.right),
                        this._size--,
                        n)
                      : e;
                  },
                },
                {
                  key: "pop",
                  value: function () {
                    var t = this._root;
                    if (t) {
                      for (; t.left; ) t = t.left;
                      return (
                        (this._root = a(t.key, this._root, this._comparator)),
                        (this._root = this._remove(
                          t.key,
                          this._root,
                          this._comparator
                        )),
                        { key: t.key, data: t.data }
                      );
                    }
                    return null;
                  },
                },
                {
                  key: "findStatic",
                  value: function (t) {
                    for (var e = this._root, r = this._comparator; e; ) {
                      var n = r(t, e.key);
                      if (0 === n) return e;
                      e = n < 0 ? e.left : e.right;
                    }
                    return null;
                  },
                },
                {
                  key: "find",
                  value: function (t) {
                    return this._root &&
                      ((this._root = a(t, this._root, this._comparator)),
                      0 !== this._comparator(t, this._root.key))
                      ? null
                      : this._root;
                  },
                },
                {
                  key: "contains",
                  value: function (t) {
                    for (var e = this._root, r = this._comparator; e; ) {
                      var n = r(t, e.key);
                      if (0 === n) return !0;
                      e = n < 0 ? e.left : e.right;
                    }
                    return !1;
                  },
                },
                {
                  key: "forEach",
                  value: function (t, e) {
                    for (var r = this._root, n = [], i = !1; !i; )
                      null !== r
                        ? (n.push(r), (r = r.left))
                        : 0 !== n.length
                        ? ((r = n.pop()), t.call(e, r), (r = r.right))
                        : (i = !0);
                    return this;
                  },
                },
                {
                  key: "range",
                  value: function (t, e, r, n) {
                    for (
                      var i = [], o = this._comparator, a = this._root;
                      0 !== i.length || a;

                    )
                      if (a) i.push(a), (a = a.left);
                      else {
                        if (0 < o((a = i.pop()).key, e)) break;
                        if (0 <= o(a.key, t) && r.call(n, a)) return this;
                        a = a.right;
                      }
                    return this;
                  },
                },
                {
                  key: "keys",
                  value: function () {
                    var t = [];
                    return (
                      this.forEach(function (e) {
                        var r = e.key;
                        return t.push(r);
                      }),
                      t
                    );
                  },
                },
                {
                  key: "values",
                  value: function () {
                    var t = [];
                    return (
                      this.forEach(function (e) {
                        var r = e.data;
                        return t.push(r);
                      }),
                      t
                    );
                  },
                },
                {
                  key: "min",
                  value: function () {
                    return this._root ? this.minNode(this._root).key : null;
                  },
                },
                {
                  key: "max",
                  value: function () {
                    return this._root ? this.maxNode(this._root).key : null;
                  },
                },
                {
                  key: "minNode",
                  value: function () {
                    var t =
                      0 < arguments.length && void 0 !== arguments[0]
                        ? arguments[0]
                        : this._root;
                    if (t) for (; t.left; ) t = t.left;
                    return t;
                  },
                },
                {
                  key: "maxNode",
                  value: function () {
                    var t =
                      0 < arguments.length && void 0 !== arguments[0]
                        ? arguments[0]
                        : this._root;
                    if (t) for (; t.right; ) t = t.right;
                    return t;
                  },
                },
                {
                  key: "at",
                  value: function (t) {
                    for (var e = this._root, r = !1, n = 0, i = []; !r; )
                      if (e) i.push(e), (e = e.left);
                      else if (0 < i.length) {
                        if (((e = i.pop()), n === t)) return e;
                        n++, (e = e.right);
                      } else r = !0;
                    return null;
                  },
                },
                {
                  key: "next",
                  value: function (t) {
                    var e = this._root,
                      r = null;
                    if (t.right) {
                      for (r = t.right; r.left; ) r = r.left;
                      return r;
                    }
                    for (var n = this._comparator; e; ) {
                      var i = n(t.key, e.key);
                      if (0 === i) break;
                      e = i < 0 ? (r = e).left : e.right;
                    }
                    return r;
                  },
                },
                {
                  key: "prev",
                  value: function (t) {
                    var e = this._root,
                      r = null;
                    if (null !== t.left) {
                      for (r = t.left; r.right; ) r = r.right;
                      return r;
                    }
                    for (var n = this._comparator; e; ) {
                      var i = n(t.key, e.key);
                      if (0 === i) break;
                      e = i < 0 ? e.left : (r = e).right;
                    }
                    return r;
                  },
                },
                {
                  key: "clear",
                  value: function () {
                    return (this._root = null), (this._size = 0), this;
                  },
                },
                {
                  key: "toList",
                  value: function () {
                    return (function (t) {
                      for (
                        var e = t, r = [], n = !1, o = new i(null, null), a = o;
                        !n;

                      )
                        e
                          ? (r.push(e), (e = e.left))
                          : 0 < r.length
                          ? (e = (e = a = a.next = r.pop()).right)
                          : (n = !0);
                      return (a.next = null), o.next;
                    })(this._root);
                  },
                },
                {
                  key: "load",
                  value: function (t) {
                    var e =
                        1 < arguments.length && void 0 !== arguments[1]
                          ? arguments[1]
                          : [],
                      r =
                        2 < arguments.length &&
                        void 0 !== arguments[2] &&
                        arguments[2],
                      n = t.length,
                      o = this._comparator;
                    if (
                      (r &&
                        (function t(e, r, n, i, o) {
                          if (!(i <= n)) {
                            for (
                              var a = e[(n + i) >> 1], s = n - 1, l = i + 1;
                              ;

                            ) {
                              for (; o(e[++s], a) < 0; );
                              for (; 0 < o(e[--l], a); );
                              if (l <= s) break;
                              var h = e[s];
                              (e[s] = e[l]),
                                (e[l] = h),
                                (h = r[s]),
                                (r[s] = r[l]),
                                (r[l] = h);
                            }
                            t(e, r, n, l, o), t(e, r, l + 1, i, o);
                          }
                        })(t, e, 0, n - 1, o),
                      null === this._root)
                    )
                      (this._root = (function t(e, r, n, o) {
                        var a = o - n;
                        if (0 < a) {
                          var s = n + Math.floor(a / 2),
                            l = e[s],
                            h = r[s],
                            u = new i(l, h);
                          return (
                            (u.left = t(e, r, n, s)),
                            (u.right = t(e, r, s + 1, o)),
                            u
                          );
                        }
                        return null;
                      })(t, e, 0, n)),
                        (this._size = n);
                    else {
                      var a = (function (t, e, r) {
                        for (
                          var n = new i(null, null), o = n, a = t, s = e;
                          null !== a && null !== s;

                        )
                          r(a.key, s.key) < 0
                            ? (a = (o.next = a).next)
                            : (s = (o.next = s).next),
                            (o = o.next);
                        return (
                          null !== a
                            ? (o.next = a)
                            : null !== s && (o.next = s),
                          n.next
                        );
                      })(
                        this.toList(),
                        (function (t, e) {
                          for (
                            var r = new i(null, null), n = r, o = 0;
                            o < t.length;
                            o++
                          )
                            n = n.next = new i(t[o], e[o]);
                          return (n.next = null), r.next;
                        })(t, e),
                        o
                      );
                      (n = this._size + n),
                        (this._root = (function t(e, r, n) {
                          var i = n - r;
                          if (0 < i) {
                            var o = r + Math.floor(i / 2),
                              a = t(e, r, o),
                              s = e.head;
                            return (
                              (s.left = a),
                              (e.head = e.head.next),
                              (s.right = t(e, o + 1, n)),
                              s
                            );
                          }
                          return null;
                        })({ head: a }, 0, n));
                    }
                    return this;
                  },
                },
                {
                  key: "isEmpty",
                  value: function () {
                    return null === this._root;
                  },
                },
                {
                  key: "toString",
                  value: function () {
                    var t =
                        0 < arguments.length && void 0 !== arguments[0]
                          ? arguments[0]
                          : function (t) {
                              return String(t.key);
                            },
                      e = [];
                    return (
                      (function t(e, r, n, i, o) {
                        if (e) {
                          i(
                            ""
                              .concat(r)
                              .concat(n ? " " : " ")
                              .concat(o(e), "\n")
                          );
                          var a = r + (n ? "    " : "   ");
                          e.left && t(e.left, a, !1, i, o),
                            e.right && t(e.right, a, !0, i, o);
                        }
                      })(
                        this._root,
                        "",
                        !0,
                        function (t) {
                          return e.push(t);
                        },
                        t
                      ),
                      e.join("")
                    );
                  },
                },
                {
                  key: "update",
                  value: function (t, e, r) {
                    var n = this._comparator,
                      i = l(t, this._root, n),
                      o = i.left,
                      h = i.right;
                    n(t, e) < 0 ? (h = s(e, r, h, n)) : (o = s(e, r, o, n)),
                      (this._root = (function (t, e, r) {
                        return null === e
                          ? t
                          : (null === t || ((e = a(t.key, e, r)).left = t), e);
                      })(o, h, n));
                  },
                },
                {
                  key: "split",
                  value: function (t) {
                    return l(t, this._root, this._comparator);
                  },
                },
                {
                  key: "size",
                  get: function () {
                    return this._size;
                  },
                },
                {
                  key: "root",
                  get: function () {
                    return this._root;
                  },
                },
              ]),
              e
            );
          })(),
          u = function (t, e) {
            return (
              t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y
            );
          },
          c = function (t, e) {
            if (
              e.ur.x < t.ll.x ||
              t.ur.x < e.ll.x ||
              e.ur.y < t.ll.y ||
              t.ur.y < e.ll.y
            )
              return null;
            var r = t.ll.x < e.ll.x ? e.ll.x : t.ll.x,
              n = t.ur.x < e.ur.x ? t.ur.x : e.ur.x;
            return {
              ll: { x: r, y: t.ll.y < e.ll.y ? e.ll.y : t.ll.y },
              ur: { x: n, y: t.ur.y < e.ur.y ? t.ur.y : e.ur.y },
            };
          },
          f = Number.EPSILON;
        void 0 === f && (f = Math.pow(2, -52));
        var p = f * f,
          d = function (t, e) {
            if (-f < t && t < f && -f < e && e < f) return 0;
            var r = t - e;
            return r * r < p * t * e ? 0 : t < e ? -1 : 1;
          },
          g = (function () {
            function e() {
              t(this, e), this.reset();
            }
            return (
              n(e, [
                {
                  key: "reset",
                  value: function () {
                    (this.xRounder = new m()), (this.yRounder = new m());
                  },
                },
                {
                  key: "round",
                  value: function (t, e) {
                    return {
                      x: this.xRounder.round(t),
                      y: this.yRounder.round(e),
                    };
                  },
                },
              ]),
              e
            );
          })(),
          m = (function () {
            function e() {
              t(this, e), (this.tree = new h()), this.round(0);
            }
            return (
              n(e, [
                {
                  key: "round",
                  value: function (t) {
                    var e = this.tree.add(t),
                      r = this.tree.prev(e);
                    if (null !== r && 0 === d(e.key, r.key))
                      return this.tree.remove(t), r.key;
                    var n = this.tree.next(e);
                    return null !== n && 0 === d(e.key, n.key)
                      ? (this.tree.remove(t), n.key)
                      : t;
                  },
                },
              ]),
              e
            );
          })(),
          y = new g(),
          _ = function (t, e) {
            return t.x * e.y - t.y * e.x;
          },
          v = function (t, e) {
            return t.x * e.x + t.y * e.y;
          },
          b = function (t, e, r) {
            var n = { x: e.x - t.x, y: e.y - t.y },
              i = { x: r.x - t.x, y: r.y - t.y },
              o = _(n, i);
            return d(o, 0);
          },
          L = function (t) {
            return Math.sqrt(v(t, t));
          },
          k = function (t, e, r) {
            var n = { x: e.x - t.x, y: e.y - t.y },
              i = { x: r.x - t.x, y: r.y - t.y };
            return _(i, n) / L(i) / L(n);
          },
          M = function (t, e, r) {
            var n = { x: e.x - t.x, y: e.y - t.y },
              i = { x: r.x - t.x, y: r.y - t.y };
            return v(i, n) / L(i) / L(n);
          },
          w = function (t, e, r) {
            return 0 === e.y
              ? null
              : { x: t.x + (e.x / e.y) * (r - t.y), y: r };
          },
          x = function (t, e, r) {
            return 0 === e.x
              ? null
              : { x: r, y: t.y + (e.y / e.x) * (r - t.x) };
          },
          S = (function () {
            function e(r, n) {
              t(this, e),
                void 0 === r.events ? (r.events = [this]) : r.events.push(this),
                (this.point = r),
                (this.isLeft = n);
            }
            return (
              n(e, null, [
                {
                  key: "compare",
                  value: function (t, r) {
                    var n = e.comparePoints(t.point, r.point);
                    return 0 !== n
                      ? n
                      : (t.point !== r.point && t.link(r),
                        t.isLeft !== r.isLeft
                          ? t.isLeft
                            ? 1
                            : -1
                          : C.compare(t.segment, r.segment));
                  },
                },
                {
                  key: "comparePoints",
                  value: function (t, e) {
                    return t.x < e.x
                      ? -1
                      : t.x > e.x
                      ? 1
                      : t.y < e.y
                      ? -1
                      : t.y > e.y
                      ? 1
                      : 0;
                  },
                },
              ]),
              n(e, [
                {
                  key: "link",
                  value: function (t) {
                    if (t.point === this.point)
                      throw new Error("Tried to link already linked events");
                    for (
                      var e = t.point.events, r = 0, n = e.length;
                      r < n;
                      r++
                    ) {
                      var i = e[r];
                      this.point.events.push(i), (i.point = this.point);
                    }
                    this.checkForConsuming();
                  },
                },
                {
                  key: "checkForConsuming",
                  value: function () {
                    for (var t = this.point.events.length, e = 0; e < t; e++) {
                      var r = this.point.events[e];
                      if (void 0 === r.segment.consumedBy)
                        for (var n = e + 1; n < t; n++) {
                          var i = this.point.events[n];
                          void 0 === i.consumedBy &&
                            r.otherSE.point.events === i.otherSE.point.events &&
                            r.segment.consume(i.segment);
                        }
                    }
                  },
                },
                {
                  key: "getAvailableLinkedEvents",
                  value: function () {
                    for (
                      var t = [], e = 0, r = this.point.events.length;
                      e < r;
                      e++
                    ) {
                      var n = this.point.events[e];
                      n !== this &&
                        !n.segment.ringOut &&
                        n.segment.isInResult() &&
                        t.push(n);
                    }
                    return t;
                  },
                },
                {
                  key: "getLeftmostComparator",
                  value: function (t) {
                    var e = this,
                      r = new Map(),
                      n = function (n) {
                        var i = n.otherSE;
                        r.set(n, {
                          sine: k(e.point, t.point, i.point),
                          cosine: M(e.point, t.point, i.point),
                        });
                      };
                    return function (t, e) {
                      r.has(t) || n(t), r.has(e) || n(e);
                      var i = r.get(t),
                        o = i.sine,
                        a = i.cosine,
                        s = r.get(e),
                        l = s.sine,
                        h = s.cosine;
                      return 0 <= o && 0 <= l
                        ? a < h
                          ? 1
                          : h < a
                          ? -1
                          : 0
                        : o < 0 && l < 0
                        ? a < h
                          ? -1
                          : h < a
                          ? 1
                          : 0
                        : l < o
                        ? -1
                        : o < l
                        ? 1
                        : 0;
                    };
                  },
                },
              ]),
              e
            );
          })(),
          E = 0,
          C = (function () {
            function e(r, n, i, o) {
              t(this, e),
                (this.id = ++E),
                ((this.leftSE = r).segment = this),
                (r.otherSE = n),
                ((this.rightSE = n).segment = this),
                (n.otherSE = r),
                (this.rings = i),
                (this.windings = o);
            }
            return (
              n(e, null, [
                {
                  key: "compare",
                  value: function (t, e) {
                    var r = t.leftSE.point.x,
                      n = e.leftSE.point.x,
                      i = t.rightSE.point.x,
                      o = e.rightSE.point.x;
                    if (o < r) return 1;
                    if (i < n) return -1;
                    var a = t.leftSE.point.y,
                      s = e.leftSE.point.y,
                      l = t.rightSE.point.y,
                      h = e.rightSE.point.y;
                    if (r < n) {
                      if (s < a && s < l) return 1;
                      if (a < s && l < s) return -1;
                      var u = t.comparePoint(e.leftSE.point);
                      if (u < 0) return 1;
                      if (0 < u) return -1;
                      var c = e.comparePoint(t.rightSE.point);
                      return 0 !== c ? c : -1;
                    }
                    if (n < r) {
                      if (a < s && a < h) return -1;
                      if (s < a && h < a) return 1;
                      var f = e.comparePoint(t.leftSE.point);
                      if (0 !== f) return f;
                      var p = t.comparePoint(e.rightSE.point);
                      return p < 0 ? 1 : 0 < p ? -1 : 1;
                    }
                    if (a < s) return -1;
                    if (s < a) return 1;
                    if (i < o) {
                      var d = e.comparePoint(t.rightSE.point);
                      if (0 !== d) return d;
                    }
                    if (o < i) {
                      var g = t.comparePoint(e.rightSE.point);
                      if (g < 0) return 1;
                      if (0 < g) return -1;
                    }
                    if (i !== o) {
                      var m = l - a,
                        y = i - r,
                        _ = h - s,
                        v = o - n;
                      if (y < m && _ < v) return 1;
                      if (m < y && v < _) return -1;
                    }
                    return o < i
                      ? 1
                      : i < o || l < h
                      ? -1
                      : h < l
                      ? 1
                      : t.id < e.id
                      ? -1
                      : t.id > e.id
                      ? 1
                      : 0;
                  },
                },
              ]),
              n(
                e,
                [
                  {
                    key: "replaceRightSE",
                    value: function (t) {
                      (this.rightSE = t),
                        ((this.rightSE.segment = this).rightSE.otherSE = this.leftSE),
                        (this.leftSE.otherSE = this.rightSE);
                    },
                  },
                  {
                    key: "bbox",
                    value: function () {
                      var t = this.leftSE.point.y,
                        e = this.rightSE.point.y;
                      return {
                        ll: { x: this.leftSE.point.x, y: t < e ? t : e },
                        ur: { x: this.rightSE.point.x, y: e < t ? t : e },
                      };
                    },
                  },
                  {
                    key: "vector",
                    value: function () {
                      return {
                        x: this.rightSE.point.x - this.leftSE.point.x,
                        y: this.rightSE.point.y - this.leftSE.point.y,
                      };
                    },
                  },
                  {
                    key: "isAnEndpoint",
                    value: function (t) {
                      return (
                        (t.x === this.leftSE.point.x &&
                          t.y === this.leftSE.point.y) ||
                        (t.x === this.rightSE.point.x &&
                          t.y === this.rightSE.point.y)
                      );
                    },
                  },
                  {
                    key: "comparePoint",
                    value: function (t) {
                      if (this.isAnEndpoint(t)) return 0;
                      var e = this.leftSE.point,
                        r = this.rightSE.point,
                        n = this.vector();
                      if (e.x === r.x)
                        return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;
                      var i = (t.y - e.y) / n.y,
                        o = e.x + i * n.x;
                      if (t.x === o) return 0;
                      var a = (t.x - e.x) / n.x,
                        s = e.y + a * n.y;
                      return t.y === s ? 0 : t.y < s ? -1 : 1;
                    },
                  },
                  {
                    key: "getIntersection",
                    value: function (t) {
                      var e = this.bbox(),
                        r = t.bbox(),
                        n = c(e, r);
                      if (null === n) return null;
                      var i = this.leftSE.point,
                        o = this.rightSE.point,
                        a = t.leftSE.point,
                        s = t.rightSE.point,
                        l = u(e, a) && 0 === this.comparePoint(a),
                        h = u(r, i) && 0 === t.comparePoint(i),
                        f = u(e, s) && 0 === this.comparePoint(s),
                        p = u(r, o) && 0 === t.comparePoint(o);
                      if (h && l) return p && !f ? o : !p && f ? s : null;
                      if (h) return f && i.x === s.x && i.y === s.y ? null : i;
                      if (l) return p && o.x === a.x && o.y === a.y ? null : a;
                      if (p && f) return null;
                      if (p) return o;
                      if (f) return s;
                      var d = (function (t, e, r, n) {
                        if (0 === e.x) return x(r, n, t.x);
                        if (0 === n.x) return x(t, e, r.x);
                        if (0 === e.y) return w(r, n, t.y);
                        if (0 === n.y) return w(t, e, r.y);
                        var i = _(e, n);
                        if (0 == i) return null;
                        var o = { x: r.x - t.x, y: r.y - t.y },
                          a = _(o, e) / i,
                          s = _(o, n) / i;
                        return {
                          x: (t.x + s * e.x + (r.x + a * n.x)) / 2,
                          y: (t.y + s * e.y + (r.y + a * n.y)) / 2,
                        };
                      })(i, this.vector(), a, t.vector());
                      return null === d
                        ? null
                        : u(n, d)
                        ? y.round(d.x, d.y)
                        : null;
                    },
                  },
                  {
                    key: "split",
                    value: function (t) {
                      var r = [],
                        n = void 0 !== t.events,
                        i = new S(t, !0),
                        o = new S(t, !1),
                        a = this.rightSE;
                      this.replaceRightSE(o), r.push(o), r.push(i);
                      var s = new e(
                        i,
                        a,
                        this.rings.slice(),
                        this.windings.slice()
                      );
                      return (
                        0 < S.comparePoints(s.leftSE.point, s.rightSE.point) &&
                          s.swapEvents(),
                        0 <
                          S.comparePoints(
                            this.leftSE.point,
                            this.rightSE.point
                          ) && this.swapEvents(),
                        n && (i.checkForConsuming(), o.checkForConsuming()),
                        r
                      );
                    },
                  },
                  {
                    key: "swapEvents",
                    value: function () {
                      var t = this.rightSE;
                      (this.rightSE = this.leftSE),
                        (this.leftSE = t),
                        (this.leftSE.isLeft = !0),
                        (this.rightSE.isLeft = !1);
                      for (var e = 0, r = this.windings.length; e < r; e++)
                        this.windings[e] *= -1;
                    },
                  },
                  {
                    key: "consume",
                    value: function (t) {
                      for (var r = this, n = t; r.consumedBy; )
                        r = r.consumedBy;
                      for (; n.consumedBy; ) n = n.consumedBy;
                      var i = e.compare(r, n);
                      if (0 !== i) {
                        if (0 < i) {
                          var o = r;
                          (r = n), (n = o);
                        }
                        if (r.prev === n) {
                          var a = r;
                          (r = n), (n = a);
                        }
                        for (var s = 0, l = n.rings.length; s < l; s++) {
                          var h = n.rings[s],
                            u = n.windings[s],
                            c = r.rings.indexOf(h);
                          -1 === c
                            ? (r.rings.push(h), r.windings.push(u))
                            : (r.windings[c] += u);
                        }
                        (n.rings = null),
                          (n.windings = null),
                          (n.consumedBy = r),
                          (n.leftSE.consumedBy = r.leftSE),
                          (n.rightSE.consumedBy = r.rightSE);
                      }
                    },
                  },
                  {
                    key: "prevInResult",
                    value: function () {
                      return (
                        void 0 !== this._prevInResult ||
                          (this.prev
                            ? this.prev.isInResult()
                              ? (this._prevInResult = this.prev)
                              : (this._prevInResult = this.prev.prevInResult())
                            : (this._prevInResult = null)),
                        this._prevInResult
                      );
                    },
                  },
                  {
                    key: "beforeState",
                    value: function () {
                      if (void 0 !== this._beforeState)
                        return this._beforeState;
                      if (this.prev) {
                        var t = this.prev.consumedBy || this.prev;
                        this._beforeState = t.afterState();
                      } else
                        this._beforeState = {
                          rings: [],
                          windings: [],
                          multiPolys: [],
                        };
                      return this._beforeState;
                    },
                  },
                  {
                    key: "afterState",
                    value: function () {
                      if (void 0 !== this._afterState) return this._afterState;
                      var t = this.beforeState();
                      this._afterState = {
                        rings: t.rings.slice(0),
                        windings: t.windings.slice(0),
                        multiPolys: [],
                      };
                      for (
                        var e = this._afterState.rings,
                          r = this._afterState.windings,
                          n = this._afterState.multiPolys,
                          i = 0,
                          o = this.rings.length;
                        i < o;
                        i++
                      ) {
                        var a = this.rings[i],
                          s = this.windings[i],
                          l = e.indexOf(a);
                        -1 === l ? (e.push(a), r.push(s)) : (r[l] += s);
                      }
                      for (var h = [], u = [], c = 0, f = e.length; c < f; c++)
                        if (0 !== r[c]) {
                          var p = e[c],
                            d = p.poly;
                          if (-1 === u.indexOf(d))
                            if (p.isExterior) h.push(d);
                            else {
                              -1 === u.indexOf(d) && u.push(d);
                              var g = h.indexOf(p.poly);
                              -1 !== g && h.splice(g, 1);
                            }
                        }
                      for (var m = 0, y = h.length; m < y; m++) {
                        var _ = h[m].multiPoly;
                        -1 === n.indexOf(_) && n.push(_);
                      }
                      return this._afterState;
                    },
                  },
                  {
                    key: "isInResult",
                    value: function () {
                      if (this.consumedBy) return !1;
                      if (void 0 !== this._isInResult) return this._isInResult;
                      var t = this.beforeState().multiPolys,
                        e = this.afterState().multiPolys;
                      switch (G.type) {
                        case "union":
                          var r = 0 === t.length,
                            n = 0 === e.length;
                          this._isInResult = r != n;
                          break;
                        case "intersection":
                          var i, o;
                          (o =
                            t.length < e.length
                              ? ((i = t.length), e.length)
                              : ((i = e.length), t.length)),
                            (this._isInResult = o === G.numMultiPolys && i < o);
                          break;
                        case "xor":
                          var a = Math.abs(t.length - e.length);
                          this._isInResult = a % 2 == 1;
                          break;
                        case "difference":
                          var s = function (t) {
                            return 1 === t.length && t[0].isSubject;
                          };
                          this._isInResult = s(t) !== s(e);
                          break;
                        default:
                          throw new Error(
                            "Unrecognized operation type found ".concat(G.type)
                          );
                      }
                      return this._isInResult;
                    },
                  },
                ],
                [
                  {
                    key: "fromRing",
                    value: function (t, r, n) {
                      var i,
                        o,
                        a,
                        s = S.comparePoints(t, r);
                      if (s < 0) (i = t), (o = r), (a = 1);
                      else {
                        if (!(0 < s))
                          throw new Error(
                            "Tried to create degenerate segment at ["
                              .concat(t.x, ", ")
                              .concat(t.y, "]")
                          );
                        (i = r), (o = t), (a = -1);
                      }
                      return new e(new S(i, !0), new S(o, !1), [n], [a]);
                    },
                  },
                ]
              ),
              e
            );
          })(),
          P = (function () {
            function e(r, n, i) {
              if ((t(this, e), !Array.isArray(r) || 0 === r.length))
                throw new Error(
                  "Input geometry is not a valid Polygon or MultiPolygon"
                );
              if (
                ((this.poly = n),
                (this.isExterior = i),
                (this.segments = []),
                "number" != typeof r[0][0] || "number" != typeof r[0][1])
              )
                throw new Error(
                  "Input geometry is not a valid Polygon or MultiPolygon"
                );
              var o = y.round(r[0][0], r[0][1]);
              this.bbox = { ll: { x: o.x, y: o.y }, ur: { x: o.x, y: o.y } };
              for (var a = o, s = 1, l = r.length; s < l; s++) {
                if ("number" != typeof r[s][0] || "number" != typeof r[s][1])
                  throw new Error(
                    "Input geometry is not a valid Polygon or MultiPolygon"
                  );
                var h = y.round(r[s][0], r[s][1]);
                (h.x === a.x && h.y === a.y) ||
                  (this.segments.push(C.fromRing(a, h, this)),
                  h.x < this.bbox.ll.x && (this.bbox.ll.x = h.x),
                  h.y < this.bbox.ll.y && (this.bbox.ll.y = h.y),
                  h.x > this.bbox.ur.x && (this.bbox.ur.x = h.x),
                  h.y > this.bbox.ur.y && (this.bbox.ur.y = h.y),
                  (a = h));
              }
              (o.x === a.x && o.y === a.y) ||
                this.segments.push(C.fromRing(a, o, this));
            }
            return (
              n(e, [
                {
                  key: "getSweepEvents",
                  value: function () {
                    for (
                      var t = [], e = 0, r = this.segments.length;
                      e < r;
                      e++
                    ) {
                      var n = this.segments[e];
                      t.push(n.leftSE), t.push(n.rightSE);
                    }
                    return t;
                  },
                },
              ]),
              e
            );
          })(),
          O = (function () {
            function e(r, n) {
              if ((t(this, e), !Array.isArray(r)))
                throw new Error(
                  "Input geometry is not a valid Polygon or MultiPolygon"
                );
              (this.exteriorRing = new P(r[0], this, !0)),
                (this.bbox = {
                  ll: {
                    x: this.exteriorRing.bbox.ll.x,
                    y: this.exteriorRing.bbox.ll.y,
                  },
                  ur: {
                    x: this.exteriorRing.bbox.ur.x,
                    y: this.exteriorRing.bbox.ur.y,
                  },
                }),
                (this.interiorRings = []);
              for (var i = 1, o = r.length; i < o; i++) {
                var a = new P(r[i], this, !1);
                a.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = a.bbox.ll.x),
                  a.bbox.ll.y < this.bbox.ll.y &&
                    (this.bbox.ll.y = a.bbox.ll.y),
                  a.bbox.ur.x > this.bbox.ur.x &&
                    (this.bbox.ur.x = a.bbox.ur.x),
                  a.bbox.ur.y > this.bbox.ur.y &&
                    (this.bbox.ur.y = a.bbox.ur.y),
                  this.interiorRings.push(a);
              }
              this.multiPoly = n;
            }
            return (
              n(e, [
                {
                  key: "getSweepEvents",
                  value: function () {
                    for (
                      var t = this.exteriorRing.getSweepEvents(),
                        e = 0,
                        r = this.interiorRings.length;
                      e < r;
                      e++
                    )
                      for (
                        var n = this.interiorRings[e].getSweepEvents(),
                          i = 0,
                          o = n.length;
                        i < o;
                        i++
                      )
                        t.push(n[i]);
                    return t;
                  },
                },
              ]),
              e
            );
          })(),
          B = (function () {
            function e(r, n) {
              if ((t(this, e), !Array.isArray(r)))
                throw new Error(
                  "Input geometry is not a valid Polygon or MultiPolygon"
                );
              try {
                "number" == typeof r[0][0][0] && (r = [r]);
              } catch (t) {}
              (this.polys = []),
                (this.bbox = {
                  ll: {
                    x: Number.POSITIVE_INFINITY,
                    y: Number.POSITIVE_INFINITY,
                  },
                  ur: {
                    x: Number.NEGATIVE_INFINITY,
                    y: Number.NEGATIVE_INFINITY,
                  },
                });
              for (var i = 0, o = r.length; i < o; i++) {
                var a = new O(r[i], this);
                a.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = a.bbox.ll.x),
                  a.bbox.ll.y < this.bbox.ll.y &&
                    (this.bbox.ll.y = a.bbox.ll.y),
                  a.bbox.ur.x > this.bbox.ur.x &&
                    (this.bbox.ur.x = a.bbox.ur.x),
                  a.bbox.ur.y > this.bbox.ur.y &&
                    (this.bbox.ur.y = a.bbox.ur.y),
                  this.polys.push(a);
              }
              this.isSubject = n;
            }
            return (
              n(e, [
                {
                  key: "getSweepEvents",
                  value: function () {
                    for (var t = [], e = 0, r = this.polys.length; e < r; e++)
                      for (
                        var n = this.polys[e].getSweepEvents(),
                          i = 0,
                          o = n.length;
                        i < o;
                        i++
                      )
                        t.push(n[i]);
                    return t;
                  },
                },
              ]),
              e
            );
          })(),
          T = (function () {
            function e(r) {
              t(this, e), (this.events = r);
              for (var n = 0, i = r.length; n < i; n++)
                r[n].segment.ringOut = this;
              this.poly = null;
            }
            return (
              n(e, null, [
                {
                  key: "factory",
                  value: function (t) {
                    for (var r = [], n = 0, i = t.length; n < i; n++) {
                      var o = t[n];
                      if (o.isInResult() && !o.ringOut) {
                        for (
                          var a = null,
                            s = o.leftSE,
                            l = o.rightSE,
                            h = [s],
                            u = s.point,
                            c = [];
                          (a = s), (s = l), h.push(s), s.point !== u;

                        )
                          for (;;) {
                            var f = s.getAvailableLinkedEvents();
                            if (0 === f.length) {
                              var p = h[0].point,
                                d = h[h.length - 1].point;
                              throw new Error(
                                "Unable to complete output ring starting at [".concat(
                                  p.x,
                                  ","
                                ) +
                                  " ".concat(
                                    p.y,
                                    "]. Last matching segment found ends at"
                                  ) +
                                  " [".concat(d.x, ", ").concat(d.y, "].")
                              );
                            }
                            if (1 === f.length) {
                              l = f[0].otherSE;
                              break;
                            }
                            for (var g = null, m = 0, y = c.length; m < y; m++)
                              if (c[m].point === s.point) {
                                g = m;
                                break;
                              }
                            if (null === g) {
                              c.push({ index: h.length, point: s.point });
                              var _ = s.getLeftmostComparator(a);
                              l = f.sort(_)[0].otherSE;
                              break;
                            }
                            var v = c.splice(g)[0],
                              b = h.splice(v.index);
                            b.unshift(b[0].otherSE), r.push(new e(b.reverse()));
                          }
                        r.push(new e(h));
                      }
                    }
                    return r;
                  },
                },
              ]),
              n(e, [
                {
                  key: "getGeom",
                  value: function () {
                    for (
                      var t = this.events[0].point,
                        e = [t],
                        r = 1,
                        n = this.events.length - 1;
                      r < n;
                      r++
                    ) {
                      var i = this.events[r].point,
                        o = this.events[r + 1].point;
                      0 !== b(i, t, o) && (e.push(i), (t = i));
                    }
                    if (1 === e.length) return null;
                    var a = e[0],
                      s = e[1];
                    0 === b(a, t, s) && e.shift(), e.push(e[0]);
                    for (
                      var l = this.isExteriorRing() ? 1 : -1,
                        h = this.isExteriorRing() ? 0 : e.length - 1,
                        u = this.isExteriorRing() ? e.length : -1,
                        c = [],
                        f = h;
                      f != u;
                      f += l
                    )
                      c.push([e[f].x, e[f].y]);
                    return c;
                  },
                },
                {
                  key: "isExteriorRing",
                  value: function () {
                    if (void 0 === this._isExteriorRing) {
                      var t = this.enclosingRing();
                      this._isExteriorRing = !t || !t.isExteriorRing();
                    }
                    return this._isExteriorRing;
                  },
                },
                {
                  key: "enclosingRing",
                  value: function () {
                    return (
                      void 0 === this._enclosingRing &&
                        (this._enclosingRing = this._calcEnclosingRing()),
                      this._enclosingRing
                    );
                  },
                },
                {
                  key: "_calcEnclosingRing",
                  value: function () {
                    for (
                      var t = this.events[0], e = 1, r = this.events.length;
                      e < r;
                      e++
                    ) {
                      var n = this.events[e];
                      0 < S.compare(t, n) && (t = n);
                    }
                    for (
                      var i = t.segment.prevInResult(),
                        o = i ? i.prevInResult() : null;
                      ;

                    ) {
                      if (!i) return null;
                      if (!o) return i.ringOut;
                      if (o.ringOut !== i.ringOut)
                        return o.ringOut.enclosingRing() !== i.ringOut
                          ? i.ringOut
                          : i.ringOut.enclosingRing();
                      o = (i = o.prevInResult()) ? i.prevInResult() : null;
                    }
                  },
                },
              ]),
              e
            );
          })(),
          D = (function () {
            function e(r) {
              t(this, e),
                (((this.exteriorRing = r).poly = this).interiorRings = []);
            }
            return (
              n(e, [
                {
                  key: "addInterior",
                  value: function (t) {
                    this.interiorRings.push(t), (t.poly = this);
                  },
                },
                {
                  key: "getGeom",
                  value: function () {
                    var t = [this.exteriorRing.getGeom()];
                    if (null === t[0]) return null;
                    for (var e = 0, r = this.interiorRings.length; e < r; e++) {
                      var n = this.interiorRings[e].getGeom();
                      null !== n && t.push(n);
                    }
                    return t;
                  },
                },
              ]),
              e
            );
          })(),
          I = (function () {
            function e(r) {
              t(this, e),
                (this.rings = r),
                (this.polys = this._composePolys(r));
            }
            return (
              n(e, [
                {
                  key: "getGeom",
                  value: function () {
                    for (var t = [], e = 0, r = this.polys.length; e < r; e++) {
                      var n = this.polys[e].getGeom();
                      null !== n && t.push(n);
                    }
                    return t;
                  },
                },
                {
                  key: "_composePolys",
                  value: function (t) {
                    for (var e = [], r = 0, n = t.length; r < n; r++) {
                      var i = t[r];
                      if (!i.poly)
                        if (i.isExteriorRing()) e.push(new D(i));
                        else {
                          var o = i.enclosingRing();
                          o.poly || e.push(new D(o)), o.poly.addInterior(i);
                        }
                    }
                    return e;
                  },
                },
              ]),
              e
            );
          })(),
          j = (function () {
            function e(r) {
              var n =
                1 < arguments.length && void 0 !== arguments[1]
                  ? arguments[1]
                  : C.compare;
              t(this, e),
                (this.queue = r),
                (this.tree = new h(n)),
                (this.segments = []);
            }
            return (
              n(e, [
                {
                  key: "process",
                  value: function (t) {
                    var e = t.segment,
                      r = [];
                    if (t.consumedBy)
                      return (
                        t.isLeft
                          ? this.queue.remove(t.otherSE)
                          : this.tree.remove(e),
                        r
                      );
                    var n = t.isLeft ? this.tree.insert(e) : this.tree.find(e);
                    if (!n)
                      throw new Error(
                        "Unable to find segment #".concat(e.id, " ") +
                          "["
                            .concat(e.leftSE.point.x, ", ")
                            .concat(e.leftSE.point.y, "] -> ") +
                          "["
                            .concat(e.rightSE.point.x, ", ")
                            .concat(e.rightSE.point.y, "] ") +
                          "in SweepLine tree. Please submit a bug report."
                      );
                    for (
                      var i = n, o = n, a = void 0, s = void 0;
                      void 0 === a;

                    )
                      null === (i = this.tree.prev(i))
                        ? (a = null)
                        : void 0 === i.key.consumedBy && (a = i.key);
                    for (; void 0 === s; )
                      null === (o = this.tree.next(o))
                        ? (s = null)
                        : void 0 === o.key.consumedBy && (s = o.key);
                    if (t.isLeft) {
                      var l = null;
                      if (a) {
                        var h = a.getIntersection(e);
                        if (
                          null !== h &&
                          (e.isAnEndpoint(h) || (l = h), !a.isAnEndpoint(h))
                        )
                          for (
                            var u = this._splitSafely(a, h),
                              c = 0,
                              f = u.length;
                            c < f;
                            c++
                          )
                            r.push(u[c]);
                      }
                      var p = null;
                      if (s) {
                        var d = s.getIntersection(e);
                        if (
                          null !== d &&
                          (e.isAnEndpoint(d) || (p = d), !s.isAnEndpoint(d))
                        )
                          for (
                            var g = this._splitSafely(s, d),
                              m = 0,
                              y = g.length;
                            m < y;
                            m++
                          )
                            r.push(g[m]);
                      }
                      if (null !== l || null !== p) {
                        var _ = null;
                        if (null === l) _ = p;
                        else if (null === p) _ = l;
                        else {
                          _ = S.comparePoints(l, p) <= 0 ? l : p;
                        }
                        this.queue.remove(e.rightSE), r.push(e.rightSE);
                        for (
                          var v = e.split(_), b = 0, L = v.length;
                          b < L;
                          b++
                        )
                          r.push(v[b]);
                      }
                      0 < r.length
                        ? (this.tree.remove(e), r.push(t))
                        : (this.segments.push(e), (e.prev = a));
                    } else {
                      if (a && s) {
                        var k = a.getIntersection(s);
                        if (null !== k) {
                          if (!a.isAnEndpoint(k))
                            for (
                              var M = this._splitSafely(a, k),
                                w = 0,
                                x = M.length;
                              w < x;
                              w++
                            )
                              r.push(M[w]);
                          if (!s.isAnEndpoint(k))
                            for (
                              var E = this._splitSafely(s, k),
                                C = 0,
                                P = E.length;
                              C < P;
                              C++
                            )
                              r.push(E[C]);
                        }
                      }
                      this.tree.remove(e);
                    }
                    return r;
                  },
                },
                {
                  key: "_splitSafely",
                  value: function (t, e) {
                    this.tree.remove(t);
                    var r = t.rightSE;
                    this.queue.remove(r);
                    var n = t.split(e);
                    return (
                      n.push(r),
                      void 0 === t.consumedBy && this.tree.insert(t),
                      n
                    );
                  },
                },
              ]),
              e
            );
          })(),
          A = (void 0 !== e && e.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE) || 1e6,
          R =
            (void 0 !== e && e.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) ||
            1e6,
          G = new ((function () {
            function e() {
              t(this, e);
            }
            return (
              n(e, [
                {
                  key: "run",
                  value: function (t, e, r) {
                    (G.type = t), y.reset();
                    for (
                      var n = [new B(e, !0)], i = 0, o = r.length;
                      i < o;
                      i++
                    )
                      n.push(new B(r[i], !1));
                    if (((G.numMultiPolys = n.length), "difference" === G.type))
                      for (var a = n[0], s = 1; s < n.length; )
                        null !== c(n[s].bbox, a.bbox) ? s++ : n.splice(s, 1);
                    if ("intersection" === G.type)
                      for (var l = 0, u = n.length; l < u; l++)
                        for (var f = n[l], p = l + 1, d = n.length; p < d; p++)
                          if (null === c(f.bbox, n[p].bbox)) return [];
                    for (
                      var g = new h(S.compare), m = 0, _ = n.length;
                      m < _;
                      m++
                    )
                      for (
                        var v = n[m].getSweepEvents(), b = 0, L = v.length;
                        b < L;
                        b++
                      )
                        if ((g.insert(v[b]), g.size > A))
                          throw new Error(
                            "Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report."
                          );
                    for (var k = new j(g), M = g.size, w = g.pop(); w; ) {
                      var x = w.key;
                      if (g.size === M) {
                        var E = x.segment;
                        throw new Error(
                          "Unable to pop() ".concat(
                            x.isLeft ? "left" : "right",
                            " SweepEvent "
                          ) +
                            "["
                              .concat(x.point.x, ", ")
                              .concat(x.point.y, "] from segment #")
                              .concat(E.id, " ") +
                            "["
                              .concat(E.leftSE.point.x, ", ")
                              .concat(E.leftSE.point.y, "] -> ") +
                            "["
                              .concat(E.rightSE.point.x, ", ")
                              .concat(E.rightSE.point.y, "] from queue. ") +
                            "Please file a bug report."
                        );
                      }
                      if (g.size > A)
                        throw new Error(
                          "Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report."
                        );
                      if (k.segments.length > R)
                        throw new Error(
                          "Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report."
                        );
                      for (
                        var C = k.process(x), P = 0, O = C.length;
                        P < O;
                        P++
                      ) {
                        var D = C[P];
                        void 0 === D.consumedBy && g.insert(D);
                      }
                      (M = g.size), (w = g.pop());
                    }
                    y.reset();
                    var N = T.factory(k.segments);
                    return new I(N).getGeom();
                  },
                },
              ]),
              e
            );
          })())();
        return {
          union: function (t) {
            for (
              var e = arguments.length, r = new Array(1 < e ? e - 1 : 0), n = 1;
              n < e;
              n++
            )
              r[n - 1] = arguments[n];
            return G.run("union", t, r);
          },
          intersection: function (t) {
            for (
              var e = arguments.length, r = new Array(1 < e ? e - 1 : 0), n = 1;
              n < e;
              n++
            )
              r[n - 1] = arguments[n];
            return G.run("intersection", t, r);
          },
          xor: function (t) {
            for (
              var e = arguments.length, r = new Array(1 < e ? e - 1 : 0), n = 1;
              n < e;
              n++
            )
              r[n - 1] = arguments[n];
            return G.run("xor", t, r);
          },
          difference: function (t) {
            for (
              var e = arguments.length, r = new Array(1 < e ? e - 1 : 0), n = 1;
              n < e;
              n++
            )
              r[n - 1] = arguments[n];
            return G.run("difference", t, r);
          },
        };
      })();
    }.call(this, r(144)));
  },
  function (t, e, r) {
    var n = r(19)(r(5), "Map");
    t.exports = n;
  },
  function (t, e, r) {
    (function (e) {
      var r = "object" == typeof e && e && e.Object === Object && e;
      t.exports = r;
    }.call(this, r(84)));
  },
  function (t, e, r) {
    var n = r(23),
      i = r(15);
    t.exports = function (t, e, r) {
      ((void 0 === r || i(t[e], r)) && (void 0 !== r || e in t)) || n(t, e, r);
    };
  },
  function (t, e, r) {
    var n = r(19),
      i = (function () {
        try {
          var t = n(Object, "defineProperty");
          return t({}, "", {}), t;
        } catch (t) {}
      })();
    t.exports = i;
  },
  function (t, e, r) {
    var n = r(113)(Object.getPrototypeOf, Object);
    t.exports = n;
  },
  function (t, e) {
    var r = Object.prototype;
    t.exports = function (t) {
      var e = t && t.constructor;
      return t === (("function" == typeof e && e.prototype) || r);
    };
  },
  function (t, e, r) {
    var n = r(26),
      i = r(6);
    t.exports = function (t) {
      return i(t) && n(t);
    };
  },
  function (t, e, r) {
    (function (t) {
      var n = r(5),
        i = r(115),
        o = e && !e.nodeType && e,
        a = o && "object" == typeof t && t && !t.nodeType && t,
        s = a && a.exports === o ? n.Buffer : void 0,
        l = (s ? s.isBuffer : void 0) || i;
      t.exports = l;
    }.call(this, r(24)(t)));
  },
  function (t, e, r) {
    var n = r(117),
      i = r(43),
      o = r(118),
      a = o && o.isTypedArray,
      s = a ? i(a) : n;
    t.exports = s;
  },
  function (t, e) {
    t.exports = function (t) {
      return function (e) {
        return t(e);
      };
    };
  },
  function (t, e) {
    t.exports = function (t, e) {
      if (
        ("constructor" !== e || "function" != typeof t[e]) &&
        "__proto__" != e
      )
        return t[e];
    };
  },
  function (t, e, r) {
    var n = r(23),
      i = r(15),
      o = Object.prototype.hasOwnProperty;
    t.exports = function (t, e, r) {
      var a = t[e];
      (o.call(t, e) && i(a, r) && (void 0 !== r || e in t)) || n(t, e, r);
    };
  },
  function (t, e, r) {
    var n = r(121),
      i = r(123),
      o = r(26);
    t.exports = function (t) {
      return o(t) ? n(t, !0) : i(t);
    };
  },
  function (t, e, r) {
    var n = r(48),
      i = r(126),
      o = r(128);
    t.exports = function (t, e) {
      return o(i(t, e, n), t + "");
    };
  },
  function (t, e) {
    t.exports = function (t) {
      return t;
    };
  },
  function (t, e, r) {
    "use strict";
    Object.defineProperty(e, "__esModule", { value: !0 });
    var n = r(11);
    e.default = function (t) {
      var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      return (
        n.coordEach(t, function (t) {
          e[0] > t[0] && (e[0] = t[0]),
            e[1] > t[1] && (e[1] = t[1]),
            e[2] < t[0] && (e[2] = t[0]),
            e[3] < t[1] && (e[3] = t[1]);
        }),
        e
      );
    };
  },
  function (t) {
    t.exports = JSON.parse('{"a":"2.4.0"}');
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Click to place marker","firstVertex":"Click to place first vertex","continueLine":"Click to continue drawing","finishLine":"Click any existing marker to finish","finishPoly":"Click first marker to finish","finishRect":"Click to finish","startCircle":"Click to place circle center","finishCircle":"Click to finish circle","placeCircleMarker":"Click to place circle marker"},"actions":{"finish":"Finish","cancel":"Cancel","removeLastVertex":"Remove Last Vertex"},"buttonTitles":{"drawMarkerButton":"Draw Marker","drawPolyButton":"Draw Polygons","drawLineButton":"Draw Polyline","drawCircleButton":"Draw Circle","drawRectButton":"Draw Rectangle","editButton":"Edit Layers","dragButton":"Drag Layers","cutButton":"Cut Layers","deleteButton":"Remove Layers","drawCircleMarkerButton":"Draw Circle Marker","snappingButton":"Snap dragged marker to other layers and vertices","pinningButton":"Pin shared vertices together"},"measurements":{"totalLength":"Length","segmentLength":"Segment length","area":"Area","radius":"Radius","perimeter":"Perimeter","height":"Height","width":"Width","coordinates":"Position","coordinatesMarker":"Position Marker"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Platziere den Marker mit Klick","firstVertex":"Platziere den ersten Marker mit Klick","continueLine":"Klicke, um weiter zu zeichnen","finishLine":"Beende mit Klick auf existierenden Marker","finishPoly":"Beende mit Klick auf ersten Marker","finishRect":"Beende mit Klick","startCircle":"Platziere das Kreiszentrum mit Klick","finishCircle":"Beende den Kreis mit Klick","placeCircleMarker":"Platziere den Kreismarker mit Klick"},"actions":{"finish":"Beenden","cancel":"Abbrechen","removeLastVertex":"Letzten Vertex lschen"},"buttonTitles":{"drawMarkerButton":"Marker zeichnen","drawPolyButton":"Polygon zeichnen","drawLineButton":"Polyline zeichnen","drawCircleButton":"Kreis zeichnen","drawRectButton":"Rechteck zeichnen","editButton":"Layer editieren","dragButton":"Layer bewegen","cutButton":"Layer schneiden","deleteButton":"Layer lschen","drawCircleMarkerButton":"Kreismarker zeichnen"},"measurements":{"totalLength":"Lnge","segmentLength":"Segment Lnge","area":"Flche","radius":"Radius","perimeter":"Umfang","height":"Hhe","width":"Breite","coordinates":"Position","coordinatesMarker":"Position Marker"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Clicca per posizionare un Marker","firstVertex":"Clicca per posizionare il primo vertice","continueLine":"Clicca per continuare a disegnare","finishLine":"Clicca qualsiasi marker esistente per terminare","finishPoly":"Clicca il primo marker per terminare","finishRect":"Clicca per terminare","startCircle":"Clicca per posizionare il punto centrale del cerchio","finishCircle":"Clicca per terminare il cerchio","placeCircleMarker":"Clicca per posizionare un Marker del cherchio"},"actions":{"finish":"Termina","cancel":"Annulla","removeLastVertex":"Rimuovi l\'ultimo vertice"},"buttonTitles":{"drawMarkerButton":"Disegna Marker","drawPolyButton":"Disegna Poligoni","drawLineButton":"Disegna Polilinea","drawCircleButton":"Disegna Cerchio","drawRectButton":"Disegna Rettangolo","editButton":"Modifica Livelli","dragButton":"Sposta Livelli","cutButton":"Ritaglia Livelli","deleteButton":"Elimina Livelli","drawCircleMarkerButton":"Disegna Marker del Cherchio"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Klik untuk menempatkan marker","firstVertex":"Klik untuk menempatkan vertex pertama","continueLine":"Klik untuk meneruskan digitasi","finishLine":"Klik pada sembarang marker yang ada untuk mengakhiri","finishPoly":"Klik marker pertama untuk mengakhiri","finishRect":"Klik untuk mengakhiri","startCircle":"Klik untuk menempatkan titik pusat lingkaran","finishCircle":"Klik untuk mengakhiri lingkaran"},"actions":{"finish":"Selesai","cancel":"Batal","removeLastVertex":"Hilangkan Vertex Terakhir"},"buttonTitles":{"drawMarkerButton":"Digitasi Marker","drawPolyButton":"Digitasi Polygon","drawLineButton":"Digitasi Polyline","drawCircleButton":"Digitasi Lingkaran","drawRectButton":"Digitasi Segi Empat","editButton":"Edit Layer","dragButton":"Geser Layer","cutButton":"Potong Layer","deleteButton":"Hilangkan Layer"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Adaug un punct","firstVertex":"Apas aici pentru a aduga primul Vertex","continueLine":"Apas aici pentru a continua desenul","finishLine":"Apas pe orice obiect pentru a finisa desenul","finishPoly":"Apas pe primul obiect pentru a finisa","finishRect":"Apas pentru a finisa","startCircle":"Apas pentru a desena un cerc","finishCircle":"Apas pentru a finisa un cerc","placeCircleMarker":"Adaug un punct"},"actions":{"finish":"Termin","cancel":"Anuleaz","removeLastVertex":"terge ultimul Vertex"},"buttonTitles":{"drawMarkerButton":"Adaug o bulin","drawPolyButton":"Deseneaz un poligon","drawLineButton":"Deseneaz o linie","drawCircleButton":"Deseneaz un cerc","drawRectButton":"Deseneaz un dreptunghi","editButton":"Editeaz straturile","dragButton":"Mut straturile","cutButton":"Taie straturile","deleteButton":"terge straturile","placeCircleMarker":"Adaug o bulin"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":",   ","firstVertex":",    ","continueLine":",   ","finishLine":"     ","finishPoly":"  ,  ","finishRect":",  ","startCircle":",    ","finishCircle":",   ","placeCircleMarker":",    "},"actions":{"finish":"","cancel":"","removeLastVertex":"  "},"buttonTitles":{"drawMarkerButton":" ","drawPolyButton":" ","drawLineButton":" ","drawCircleButton":" ","drawRectButton":" ","editButton":" ","dragButton":" ","cutButton":" ","deleteButton":" ","drawCircleMarkerButton":"  ","snappingButton":"       ","pinningButton":"   "}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Presiona para colocar un marcador","firstVertex":"Presiona para colocar el primer vrtice","continueLine":"Presiona para continuar dibujando","finishLine":"Presiona cualquier marcador existente para finalizar","finishPoly":"Presiona el primer marcador para finalizar","finishRect":"Presiona para finalizar","startCircle":"Presiona para colocar el centro del circulo","finishCircle":"Presiona para finalizar el circulo","placeCircleMarker":"Presiona para colocar un marcador de circulo"},"actions":{"finish":"Finalizar","cancel":"Cancelar","removeLastVertex":"Remover ultimo vrtice"},"buttonTitles":{"drawMarkerButton":"Dibujar Marcador","drawPolyButton":"Dibujar Polgono","drawLineButton":"Dibujar Lnea","drawCircleButton":"Dibujar Circulo","drawRectButton":"Dibujar Rectngulo","editButton":"Editar Capas","dragButton":"Arrastrar Capas","cutButton":"Cortar Capas","deleteButton":"Remover Capas","drawCircleMarkerButton":"Dibujar Marcador de Circulo"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Klik om een marker te plaatsen","firstVertex":"Klik om het eerste punt te plaatsen","continueLine":"Klik om te blijven tekenen","finishLine":"Klik op een bestaand punt om te beindigen","finishPoly":"Klik op het eerst punt om te beindigen","finishRect":"Klik om te beindigen","startCircle":"Klik om het middelpunt te plaatsen","finishCircle":"Klik om de cirkel te beindigen","placeCircleMarker":"Klik om een marker te plaatsen"},"actions":{"finish":"Bewaar","cancel":"Annuleer","removeLastVertex":"Verwijder laatste punt"},"buttonTitles":{"drawMarkerButton":"Plaats Marker","drawPolyButton":"Teken een vlak","drawLineButton":"Teken een lijn","drawCircleButton":"Teken een cirkel","drawRectButton":"Teken een vierkant","editButton":"Bewerk","dragButton":"Verplaats","cutButton":"Knip","deleteButton":"Verwijder","drawCircleMarkerButton":"Plaats Marker"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Cliquez pour placer un marqueur","firstVertex":"Cliquez pour placer le premier sommet","continueLine":"Cliquez pour continuer  dessiner","finishLine":"Cliquez sur n\'importe quel marqueur pour terminer","finishPoly":"Cliquez sur le premier marqueur pour terminer","finishRect":"Cliquez pour terminer","startCircle":"Cliquez pour placer le centre du cercle","finishCircle":"Cliquez pour finir le cercle"},"actions":{"finish":"Terminer","cancel":"Annuler","removeLastVertex":"Retirer le dernier sommet"},"buttonTitles":{"drawMarkerButton":"Placer des marqueurs","drawPolyButton":"Dessiner des polygones","drawLineButton":"Dessiner des polylignes","drawCircleButton":"Dessiner un cercle","drawRectButton":"Dessiner un rectangle","editButton":"diter des calques","dragButton":"Dplacer des calques","cutButton":"Couper des calques","deleteButton":"Supprimer des calques"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"","firstVertex":"","continueLine":"","finishLine":"","finishPoly":"","finishRect":"","startCircle":"","finishCircle":""},"actions":{"finish":"","cancel":"","removeLastVertex":""},"buttonTitles":{"drawMarkerButton":"","drawPolyButton":"","drawLineButton":"","drawCircleButton":"","drawRectButton":"","editButton":"","dragButton":"","cutButton":"","deleteButton":""}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Clique para posicionar o marcador","firstVertex":"Clique para posicionar o primeiro vrtice","continueLine":"Clique para continuar desenhando","finishLine":"Clique em qualquer marcador existente para finalizar","finishPoly":"Clique no primeiro ponto para fechar o polgono","finishRect":"Clique para finalizar","startCircle":"Clique para posicionar o centro do crculo","finishCircle":"Clique para fechar o crculo"},"actions":{"finish":"Finalizar","cancel":"Cancelar","removeLastVertex":"Remover ltimo vrtice"},"buttonTitles":{"drawMarkerButton":"Desenhar um marcador","drawPolyButton":"Desenhar um polgono","drawLineButton":"Desenhar uma polilinha","drawCircleButton":"Desenhar um crculo","drawRectButton":"Desenhar um retngulo","editButton":"Editar camada(s)","dragButton":"Mover camada(s)","cutButton":"Recortar camada(s)","deleteButton":"Remover camada(s)"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Kliknij, aby ustawi znacznik","firstVertex":"Kliknij, aby ustawi pierwszy punkt","continueLine":"Kliknij, aby kontynuowa rysowanie","finishLine":"Kliknij dowolny punkt, aby zakoczy","finishPoly":"Kliknij pierwszy punkt, aby zakoczy","finishRect":"Kliknij, aby zakoczy","startCircle":"Kliknij, aby ustawi rodek koa","finishCircle":"Kliknij, aby zakoczy rysowanie koa","placeCircleMarker":"Kliknij, aby ustawi okrgy znacznik"},"actions":{"finish":"Zakocz","cancel":"Anuluj","removeLastVertex":"Usu ostatni punkt"},"buttonTitles":{"drawMarkerButton":"Narysuj znacznik","drawPolyButton":"Narysuj wielokt","drawLineButton":"Narysuj ciek","drawCircleButton":"Narysuj koo","drawRectButton":"Narysuj prostokt","editButton":"Edytuj","dragButton":"Przesu","cutButton":"Wytnij","deleteButton":"Usu","drawCircleMarkerButton":"Narysuj okrgy znacznik"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Klicka fr att placera markr","firstVertex":"Klicka fr att placera frsta hrnet","continueLine":"Klicka fr att fortstta rita","finishLine":"Klicka p en existerande punkt fr att slutfra","finishPoly":"Klicka p den frsta punkten fr att slutfra","finishRect":"Klicka fr att slutfra","startCircle":"Klicka fr att placera cirkelns centrum","finishCircle":"Klicka fr att slutfra cirkeln","placeCircleMarker":"Klicka fr att placera cirkelmarkr"},"actions":{"finish":"Slutfr","cancel":"Avbryt","removeLastVertex":"Ta bort sista hrnet"},"buttonTitles":{"drawMarkerButton":"Rita Markr","drawPolyButton":"Rita Polygoner","drawLineButton":"Rita Linje","drawCircleButton":"Rita Cirkel","drawRectButton":"Rita Rektangel","editButton":"Redigera Lager","dragButton":"Dra Lager","cutButton":"Klipp i Lager","deleteButton":"Ta bort Lager","drawCircleMarkerButton":"Rita Cirkelmarkr"}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"     ","firstVertex":"       ","continueLine":"      ","finishLine":"        ","finishPoly":"       ","finishRect":"    ","startCircle":"      ","finishCircle":"      ","placeCircleMarker":"      "},"actions":{"finish":"","cancel":"","removeLastVertex":"  "},"buttonTitles":{"drawMarkerButton":" ","drawPolyButton":" ","drawLineButton":" ","drawCircleButton":" ","drawRectButton":" ","editButton":" ","dragButton":" ","cutButton":" ","deleteButton":" ","drawCircleMarkerButton":"  ","snappingButton":"        ","pinningButton":"   "}}'
    );
  },
  function (t) {
    t.exports = JSON.parse(
      '{"tooltips":{"placeMarker":"Kattintson a jell elhelyezshez","firstVertex":"Kattintson az els pont elhelyezshez","continueLine":"Kattintson a kvetkez pont elhelyezshez","finishLine":"A befejezshez kattintson egy meglv pontra","finishPoly":"A befejezshez kattintson az els pontra","finishRect":"Kattintson a befejezshez","startCircle":"Kattintson a kr kzppontjnak elhelyezshez","finishCircle":"Kattintson a kr befejezshez","placeCircleMarker":"Kattintson a krjell elhelyezshez"},"actions":{"finish":"Befejezs","cancel":"Mgse","removeLastVertex":"Utols pont eltvoltsa"},"buttonTitles":{"drawMarkerButton":"Jell rajzolsa","drawPolyButton":"Poligon rajzolsa","drawLineButton":"Vonal rajzolsa","drawCircleButton":"Kr rajzolsa","drawRectButton":"Ngyzet rajzolsa","editButton":"Elemek szerkesztse","dragButton":"Elemek mozgatsa","cutButton":"Elemek vgsa","deleteButton":"Elemek trlse","drawCircleMarkerButton":"Kr jell rajzolsa","snappingButton":"Kapcsolja a jelltt msik elemhez vagy ponthoz","pinningButton":"Kzs pontok sszektse"}}'
    );
  },
  function (t, e, r) {
    var n = r(133),
      i = r(134);
    t.exports = function (t, e) {
      return null != t && i(t, e, n);
    };
  },
  function (t, e, r) {
    var n = r(162);
    t.exports = function (t, e, r) {
      return null == t ? t : n(t, e, r);
    };
  },
  function (t, e, r) {
    "use strict";
    Object.defineProperty(e, "__esModule", { value: !0 });
    var n = r(11),
      i = 6378137;
    function o(t) {
      var e = 0;
      if (t && 0 < t.length) {
        e += Math.abs(a(t[0]));
        for (var r = 1; r < t.length; r++) e -= Math.abs(a(t[r]));
      }
      return e;
    }
    function a(t) {
      var e,
        r,
        n,
        o,
        a,
        l,
        h = 0,
        u = t.length;
      if (2 < u) {
        for (l = 0; l < u; l++)
          (a =
            l === u - 2
              ? ((n = u - 2), (o = u - 1), 0)
              : l === u - 1
              ? ((n = u - 1), (o = 0), 1)
              : ((o = (n = l) + 1), l + 2)),
            (e = t[n]),
            (r = t[o]),
            (h += (s(t[a][0]) - s(e[0])) * Math.sin(s(r[1])));
        h = (h * i * i) / 2;
      }
      return h;
    }
    function s(t) {
      return (t * Math.PI) / 180;
    }
    e.default = function (t) {
      return n.geomReduce(
        t,
        function (t, e) {
          return (
            t +
            (function (t) {
              var e,
                r = 0;
              switch (t.type) {
                case "Polygon":
                  return o(t.coordinates);
                case "MultiPolygon":
                  for (e = 0; e < t.coordinates.length; e++)
                    r += o(t.coordinates[e]);
                  return r;
                case "Point":
                case "MultiPoint":
                case "LineString":
                case "MultiLineString":
                  return 0;
              }
              return 0;
            })(e)
          );
        },
        0
      );
    };
  },
  function (t, e, r) {
    t.exports = r(165);
  },
  function (t, e) {
    (Array.prototype.findIndex =
      Array.prototype.findIndex ||
      function (t) {
        if (null === this)
          throw new TypeError(
            "Array.prototype.findIndex called on null or undefined"
          );
        if ("function" != typeof t)
          throw new TypeError("callback must be a function");
        for (
          var e = Object(this), r = e.length >>> 0, n = arguments[1], i = 0;
          i < r;
          i++
        )
          if (t.call(n, e[i], i, e)) return i;
        return -1;
      }),
      (Array.prototype.find =
        Array.prototype.find ||
        function (t) {
          if (null === this)
            throw new TypeError(
              "Array.prototype.find called on null or undefined"
            );
          if ("function" != typeof t)
            throw new TypeError("callback must be a function");
          for (
            var e = Object(this), r = e.length >>> 0, n = arguments[1], i = 0;
            i < r;
            i++
          ) {
            var o = e[i];
            if (t.call(n, o, i, e)) return o;
          }
        }),
      "function" != typeof Object.assign &&
        (Object.assign = function (t) {
          "use strict";
          if (null == t)
            throw new TypeError("Cannot convert undefined or null to object");
          t = Object(t);
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            if (null != r)
              for (var n in r)
                Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
          }
          return t;
        }),
      [
        Element.prototype,
        CharacterData.prototype,
        DocumentType.prototype,
      ].forEach(function (t) {
        t.hasOwnProperty("remove") ||
          Object.defineProperty(t, "remove", {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: function () {
              this.parentNode.removeChild(this);
            },
          });
      }),
      Array.prototype.includes ||
        Object.defineProperty(Array.prototype, "includes", {
          value: function (t, e) {
            if (null == this)
              throw new TypeError('"this" is null or not defined');
            var r = Object(this),
              n = r.length >>> 0;
            if (0 == n) return !1;
            for (
              var i,
                o,
                a = 0 | e,
                s = Math.max(0 <= a ? a : n - Math.abs(a), 0);
              s < n;

            ) {
              if (
                (i = r[s]) === (o = t) ||
                ("number" == typeof i &&
                  "number" == typeof o &&
                  isNaN(i) &&
                  isNaN(o))
              )
                return !0;
              s++;
            }
            return !1;
          },
        });
  },
  function (t, e, r) {
    var n = r(72),
      i = r(36),
      o = r(103),
      a = r(105),
      s = r(3),
      l = r(46),
      h = r(44);
    t.exports = function t(e, r, u, c, f) {
      e !== r &&
        o(
          r,
          function (o, l) {
            if (((f = f || new n()), s(o))) a(e, r, l, u, t, c, f);
            else {
              var p = c ? c(h(e, l), o, l + "", e, r, f) : void 0;
              void 0 === p && (p = o), i(e, l, p);
            }
          },
          l
        );
    };
  },
  function (t, e, r) {
    var n = r(13),
      i = r(78),
      o = r(79),
      a = r(80),
      s = r(81),
      l = r(82);
    function h(t) {
      var e = (this.__data__ = new n(t));
      this.size = e.size;
    }
    (h.prototype.clear = i),
      (h.prototype.delete = o),
      (h.prototype.get = a),
      (h.prototype.has = s),
      (h.prototype.set = l),
      (t.exports = h);
  },
  function (t, e) {
    t.exports = function () {
      (this.__data__ = []), (this.size = 0);
    };
  },
  function (t, e, r) {
    var n = r(14),
      i = Array.prototype.splice;
    t.exports = function (t) {
      var e = this.__data__,
        r = n(e, t);
      return !(
        r < 0 || (r == e.length - 1 ? e.pop() : i.call(e, r, 1), --this.size, 0)
      );
    };
  },
  function (t, e, r) {
    var n = r(14);
    t.exports = function (t) {
      var e = this.__data__,
        r = n(e, t);
      return r < 0 ? void 0 : e[r][1];
    };
  },
  function (t, e, r) {
    var n = r(14);
    t.exports = function (t) {
      return -1 < n(this.__data__, t);
    };
  },
  function (t, e, r) {
    var n = r(14);
    t.exports = function (t, e) {
      var r = this.__data__,
        i = n(r, t);
      return i < 0 ? (++this.size, r.push([t, e])) : (r[i][1] = e), this;
    };
  },
  function (t, e, r) {
    var n = r(13);
    t.exports = function () {
      (this.__data__ = new n()), (this.size = 0);
    };
  },
  function (t, e) {
    t.exports = function (t) {
      var e = this.__data__,
        r = e.delete(t);
      return (this.size = e.size), r;
    };
  },
  function (t, e) {
    t.exports = function (t) {
      return this.__data__.get(t);
    };
  },
  function (t, e) {
    t.exports = function (t) {
      return this.__data__.has(t);
    };
  },
  function (t, e, r) {
    var n = r(13),
      i = r(34),
      o = r(22);
    t.exports = function (t, e) {
      var r = this.__data__;
      if (r instanceof n) {
        var a = r.__data__;
        if (!i || a.length < 199)
          return a.push([t, e]), (this.size = ++r.size), this;
        r = this.__data__ = new o(a);
      }
      return r.set(t, e), (this.size = r.size), this;
    };
  },
  function (t, e, r) {
    var n = r(20),
      i = r(87),
      o = r(3),
      a = r(89),
      s = /^\[object .+?Constructor\]$/,
      l = Function.prototype,
      h = Object.prototype,
      u = l.toString,
      c = h.hasOwnProperty,
      f = RegExp(
        "^" +
          u
            .call(c)
            .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
            .replace(
              /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
              "$1.*?"
            ) +
          "$"
      );
    t.exports = function (t) {
      return !(!o(t) || i(t)) && (n(t) ? f : s).test(a(t));
    };
  },
  function (t, e) {
    var r;
    r = (function () {
      return this;
    })();
    try {
      r = r || new Function("return this")();
    } catch (t) {
      "object" == typeof window && (r = window);
    }
    t.exports = r;
  },
  function (t, e, r) {
    var n = r(21),
      i = Object.prototype,
      o = i.hasOwnProperty,
      a = i.toString,
      s = n ? n.toStringTag : void 0;
    t.exports = function (t) {
      var e = o.call(t, s),
        r = t[s];
      try {
        t[s] = void 0;
        var n = !0;
      } catch (t) {}
      var i = a.call(t);
      return n && (e ? (t[s] = r) : delete t[s]), i;
    };
  },
  function (t, e) {
    var r = Object.prototype.toString;
    t.exports = function (t) {
      return r.call(t);
    };
  },
  function (t, e, r) {
    var n,
      i = r(88),
      o = (n = /[^.]+$/.exec((i && i.keys && i.keys.IE_PROTO) || ""))
        ? "Symbol(src)_1." + n
        : "";
    t.exports = function (t) {
      return !!o && o in t;
    };
  },
  function (t, e, r) {
    var n = r(5)["__core-js_shared__"];
    t.exports = n;
  },
  function (t, e) {
    var r = Function.prototype.toString;
    t.exports = function (t) {
      if (null != t) {
        try {
          return r.call(t);
        } catch (t) {}
        try {
          return t + "";
        } catch (t) {}
      }
      return "";
    };
  },
  function (t, e) {
    t.exports = function (t, e) {
      return null == t ? void 0 : t[e];
    };
  },
  function (t, e, r) {
    var n = r(92),
      i = r(13),
      o = r(34);
    t.exports = function () {
      (this.size = 0),
        (this.__data__ = {
          hash: new n(),
          map: new (o || i)(),
          string: new n(),
        });
    };
  },
  function (t, e, r) {
    var n = r(93),
      i = r(94),
      o = r(95),
      a = r(96),
      s = r(97);
    function l(t) {
      var e = -1,
        r = null == t ? 0 : t.length;
      for (this.clear(); ++e < r; ) {
        var n = t[e];
        this.set(n[0], n[1]);
      }
    }
    (l.prototype.clear = n),
      (l.prototype.delete = i),
      (l.prototype.get = o),
      (l.prototype.has = a),
      (l.prototype.set = s),
      (t.exports = l);
  },
  function (t, e, r) {
    var n = r(16);
    t.exports = function () {
      (this.__data__ = n ? n(null) : {}), (this.size = 0);
    };
  },
  function (t, e) {
    t.exports = function (t) {
      var e = this.has(t) && delete this.__data__[t];
      return (this.size -= e ? 1 : 0), e;
    };
  },
  function (t, e, r) {
    var n = r(16),
      i = Object.prototype.hasOwnProperty;
    t.exports = function (t) {
      var e = this.__data__;
      if (n) {
        var r = e[t];
        return "__lodash_hash_undefined__" === r ? void 0 : r;
      }
      return i.call(e, t) ? e[t] : void 0;
    };
  },
  function (t, e, r) {
    var n = r(16),
      i = Object.prototype.hasOwnProperty;
    t.exports = function (t) {
      var e = this.__data__;
      return n ? void 0 !== e[t] : i.call(e, t);
    };
  },
  function (t, e, r) {
    var n = r(16);
    t.exports = function (t, e) {
      var r = this.__data__;
      return (
        (this.size += this.has(t) ? 0 : 1),
        (r[t] = n && void 0 === e ? "__lodash_hash_undefined__" : e),
        this
      );
    };
  },
  function (t, e, r) {
    var n = r(17);
    t.exports = function (t) {
      var e = n(this, t).delete(t);
      return (this.size -= e ? 1 : 0), e;
    };
  },
  function (t, e) {
    t.exports = function (t) {
      var e = typeof t;
      return "string" == e || "number" == e || "symbol" == e || "boolean" == e
        ? "__proto__" !== t
        : null === t;
    };
  },
  function (t, e, r) {
    var n = r(17);
    t.exports = function (t) {
      return n(this, t).get(t);
    };
  },
  function (t, e, r) {
    var n = r(17);
    t.exports = function (t) {
      return n(this, t).has(t);
    };
  },
  function (t, e, r) {
    var n = r(17);
    t.exports = function (t, e) {
      var r = n(this, t),
        i = r.size;
      return r.set(t, e), (this.size += r.size == i ? 0 : 1), this;
    };
  },
  function (t, e, r) {
    var n = r(104)();
    t.exports = n;
  },
  function (t, e) {
    t.exports = function (t) {
      return function (e, r, n) {
        for (var i = -1, o = Object(e), a = n(e), s = a.length; s--; ) {
          var l = a[t ? s : ++i];
          if (!1 === r(o[l], l, o)) break;
        }
        return e;
      };
    };
  },
  function (t, e, r) {
    var n = r(36),
      i = r(106),
      o = r(107),
      a = r(110),
      s = r(111),
      l = r(25),
      h = r(7),
      u = r(40),
      c = r(41),
      f = r(20),
      p = r(3),
      d = r(116),
      g = r(42),
      m = r(44),
      y = r(119);
    t.exports = function (t, e, r, _, v, b, L) {
      var k = m(t, r),
        M = m(e, r),
        w = L.get(M);
      if (w) n(t, r, w);
      else {
        var x = b ? b(k, M, r + "", t, e, L) : void 0,
          S = void 0 === x;
        if (S) {
          var E = h(M),
            C = !E && c(M),
            P = !E && !C && g(M);
          (x = M),
            E || C || P
              ? (x = h(k)
                  ? k
                  : u(k)
                  ? a(k)
                  : C
                  ? i(M, !(S = !1))
                  : P
                  ? o(M, !(S = !1))
                  : [])
              : d(M) || l(M)
              ? l((x = k))
                ? (x = y(k))
                : (p(k) && !f(k)) || (x = s(M))
              : (S = !1);
        }
        S && (L.set(M, x), v(x, M, _, b, L), L.delete(M)), n(t, r, x);
      }
    };
  },
  function (t, e, r) {
    (function (t) {
      var n = r(5),
        i = e && !e.nodeType && e,
        o = i && "object" == typeof t && t && !t.nodeType && t,
        a = o && o.exports === i ? n.Buffer : void 0,
        s = a ? a.allocUnsafe : void 0;
      t.exports = function (t, e) {
        if (e) return t.slice();
        var r = t.length,
          n = s ? s(r) : new t.constructor(r);
        return t.copy(n), n;
      };
    }.call(this, r(24)(t)));
  },
  function (t, e, r) {
    var n = r(108);
    t.exports = function (t, e) {
      var r = e ? n(t.buffer) : t.buffer;
      return new t.constructor(r, t.byteOffset, t.length);
    };
  },
  function (t, e, r) {
    var n = r(109);
    t.exports = function (t) {
      var e = new t.constructor(t.byteLength);
      return new n(e).set(new n(t)), e;
    };
  },
  function (t, e, r) {
    var n = r(5).Uint8Array;
    t.exports = n;
  },
  function (t, e) {
    t.exports = function (t, e) {
      var r = -1,
        n = t.length;
      for (e = e || Array(n); ++r < n; ) e[r] = t[r];
      return e;
    };
  },
  function (t, e, r) {
    var n = r(112),
      i = r(38),
      o = r(39);
    t.exports = function (t) {
      return "function" != typeof t.constructor || o(t) ? {} : n(i(t));
    };
  },
  function (t, e, r) {
    var n = r(3),
      i = Object.create;
    function o() {}
    t.exports = function (t) {
      if (!n(t)) return {};
      if (i) return i(t);
      o.prototype = t;
      var e = new o();
      return (o.prototype = void 0), e;
    };
  },
  function (t, e) {
    t.exports = function (t, e) {
      return function (r) {
        return t(e(r));
      };
    };
  },
  function (t, e, r) {
    var n = r(10),
      i = r(6);
    t.exports = function (t) {
      return i(t) && "[object Arguments]" == n(t);
    };
  },
  function (t, e) {
    t.exports = function () {
      return !1;
    };
  },
  function (t, e, r) {
    var n = r(10),
      i = r(38),
      o = r(6),
      a = Function.prototype,
      s = Object.prototype,
      l = a.toString,
      h = s.hasOwnProperty,
      u = l.call(Object);
    t.exports = function (t) {
      if (!o(t) || "[object Object]" != n(t)) return !1;
      var e = i(t);
      if (null === e) return !0;
      var r = h.call(e, "constructor") && e.constructor;
      return "function" == typeof r && r instanceof r && l.call(r) == u;
    };
  },
  function (t, e, r) {
    var n = r(10),
      i = r(27),
      o = r(6),
      a = {};
    (a["[object Float32Array]"] = a["[object Float64Array]"] = a[
      "[object Int8Array]"
    ] = a["[object Int16Array]"] = a["[object Int32Array]"] = a[
      "[object Uint8Array]"
    ] = a["[object Uint8ClampedArray]"] = a["[object Uint16Array]"] = a[
      "[object Uint32Array]"
    ] = !0),
      (a["[object Arguments]"] = a["[object Array]"] = a[
        "[object ArrayBuffer]"
      ] = a["[object Boolean]"] = a["[object DataView]"] = a[
        "[object Date]"
      ] = a["[object Error]"] = a["[object Function]"] = a["[object Map]"] = a[
        "[object Number]"
      ] = a["[object Object]"] = a["[object RegExp]"] = a["[object Set]"] = a[
        "[object String]"
      ] = a["[object WeakMap]"] = !1),
      (t.exports = function (t) {
        return o(t) && i(t.length) && !!a[n(t)];
      });
  },
  function (t, e, r) {
    (function (t) {
      var n = r(35),
        i = e && !e.nodeType && e,
        o = i && "object" == typeof t && t && !t.nodeType && t,
        a = o && o.exports === i && n.process,
        s = (function () {
          try {
            return (
              (o && o.require && o.require("util").types) ||
              (a && a.binding && a.binding("util"))
            );
          } catch (t) {}
        })();
      t.exports = s;
    }.call(this, r(24)(t)));
  },
  function (t, e, r) {
    var n = r(120),
      i = r(46);
    t.exports = function (t) {
      return n(t, i(t));
    };
  },
  function (t, e, r) {
    var n = r(45),
      i = r(23);
    t.exports = function (t, e, r, o) {
      var a = !r;
      r = r || {};
      for (var s = -1, l = e.length; ++s < l; ) {
        var h = e[s],
          u = o ? o(r[h], t[h], h, r, t) : void 0;
        void 0 === u && (u = t[h]), a ? i(r, h, u) : n(r, h, u);
      }
      return r;
    };
  },
  function (t, e, r) {
    var n = r(122),
      i = r(25),
      o = r(7),
      a = r(41),
      s = r(18),
      l = r(42),
      h = Object.prototype.hasOwnProperty;
    t.exports = function (t, e) {
      var r = o(t),
        u = !r && i(t),
        c = !r && !u && a(t),
        f = !r && !u && !c && l(t),
        p = r || u || c || f,
        d = p ? n(t.length, String) : [],
        g = d.length;
      for (var m in t)
        (!e && !h.call(t, m)) ||
          (p &&
            ("length" == m ||
              (c && ("offset" == m || "parent" == m)) ||
              (f &&
                ("buffer" == m || "byteLength" == m || "byteOffset" == m)) ||
              s(m, g))) ||
          d.push(m);
      return d;
    };
  },
  function (t, e) {
    t.exports = function (t, e) {
      for (var r = -1, n = Array(t); ++r < t; ) n[r] = e(r);
      return n;
    };
  },
  function (t, e, r) {
    var n = r(3),
      i = r(39),
      o = r(124),
      a = Object.prototype.hasOwnProperty;
    t.exports = function (t) {
      if (!n(t)) return o(t);
      var e = i(t),
        r = [];
      for (var s in t)
        ("constructor" != s || (!e && a.call(t, s))) && r.push(s);
      return r;
    };
  },
  function (t, e) {
    t.exports = function (t) {
      var e = [];
      if (null != t) for (var r in Object(t)) e.push(r);
      return e;
    };
  },
  function (t, e, r) {
    var n = r(47),
      i = r(132);
    t.exports = function (t) {
      return n(function (e, r) {
        var n = -1,
          o = r.length,
          a = 1 < o ? r[o - 1] : void 0,
          s = 2 < o ? r[2] : void 0;
        for (
          a = 3 < t.length && "function" == typeof a ? (o--, a) : void 0,
            s && i(r[0], r[1], s) && ((a = o < 3 ? void 0 : a), (o = 1)),
            e = Object(e);
          ++n < o;

        ) {
          var l = r[n];
          l && t(e, l, n, a);
        }
        return e;
      });
    };
  },
  function (t, e, r) {
    var n = r(127),
      i = Math.max;
    t.exports = function (t, e, r) {
      return (
        (e = i(void 0 === e ? t.length - 1 : e, 0)),
        function () {
          for (
            var o = arguments, a = -1, s = i(o.length - e, 0), l = Array(s);
            ++a < s;

          )
            l[a] = o[e + a];
          a = -1;
          for (var h = Array(e + 1); ++a < e; ) h[a] = o[a];
          return (h[e] = r(l)), n(t, this, h);
        }
      );
    };
  },
  function (t, e) {
    t.exports = function (t, e, r) {
      switch (r.length) {
        case 0:
          return t.call(e);
        case 1:
          return t.call(e, r[0]);
        case 2:
          return t.call(e, r[0], r[1]);
        case 3:
          return t.call(e, r[0], r[1], r[2]);
      }
      return t.apply(e, r);
    };
  },
  function (t, e, r) {
    var n = r(129),
      i = r(131)(n);
    t.exports = i;
  },
  function (t, e, r) {
    var n = r(130),
      i = r(37),
      o = r(48),
      a = i
        ? function (t, e) {
            return i(t, "toString", {
              configurable: !0,
              enumerable: !1,
              value: n(e),
              writable: !0,
            });
          }
        : o;
    t.exports = a;
  },
  function (t, e) {
    t.exports = function (t) {
      return function () {
        return t;
      };
    };
  },
  function (t, e) {
    var r = Date.now;
    t.exports = function (t) {
      var e = 0,
        n = 0;
      return function () {
        var i = r(),
          o = 16 - (i - n);
        if (((n = i), 0 < o)) {
          if (800 <= ++e) return arguments[0];
        } else e = 0;
        return t.apply(void 0, arguments);
      };
    };
  },
  function (t, e, r) {
    var n = r(15),
      i = r(26),
      o = r(18),
      a = r(3);
    t.exports = function (t, e, r) {
      if (!a(r)) return !1;
      var s = typeof e;
      return (
        !!("number" == s ? i(r) && o(e, r.length) : "string" == s && e in r) &&
        n(r[e], t)
      );
    };
  },
  function (t, e) {
    var r = Object.prototype.hasOwnProperty;
    t.exports = function (t, e) {
      return null != t && r.call(t, e);
    };
  },
  function (t, e, r) {
    var n = r(28),
      i = r(25),
      o = r(7),
      a = r(18),
      s = r(27),
      l = r(31);
    t.exports = function (t, e, r) {
      for (var h = -1, u = (e = n(e, t)).length, c = !1; ++h < u; ) {
        var f = l(e[h]);
        if (!(c = null != t && r(t, f))) break;
        t = t[f];
      }
      return c || ++h != u
        ? c
        : !!(u = null == t ? 0 : t.length) && s(u) && a(f, u) && (o(t) || i(t));
    };
  },
  function (t, e, r) {
    var n = r(7),
      i = r(29),
      o = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      a = /^\w*$/;
    t.exports = function (t, e) {
      if (n(t)) return !1;
      var r = typeof t;
      return (
        !(
          "number" != r &&
          "symbol" != r &&
          "boolean" != r &&
          null != t &&
          !i(t)
        ) ||
        a.test(t) ||
        !o.test(t) ||
        (null != e && t in Object(e))
      );
    };
  },
  function (t, e, r) {
    var n = r(137),
      i = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      o = /\\(\\)?/g,
      a = n(function (t) {
        var e = [];
        return (
          46 === t.charCodeAt(0) && e.push(""),
          t.replace(i, function (t, r, n, i) {
            e.push(n ? i.replace(o, "$1") : r || t);
          }),
          e
        );
      });
    t.exports = a;
  },
  function (t, e, r) {
    var n = r(138);
    t.exports = function (t) {
      var e = n(t, function (t) {
          return 500 === r.size && r.clear(), t;
        }),
        r = e.cache;
      return e;
    };
  },
  function (t, e, r) {
    var n = r(22);
    function i(t, e) {
      if ("function" != typeof t || (null != e && "function" != typeof e))
        throw new TypeError("Expected a function");
      var r = function () {
        var n = arguments,
          i = e ? e.apply(this, n) : n[0],
          o = r.cache;
        if (o.has(i)) return o.get(i);
        var a = t.apply(this, n);
        return (r.cache = o.set(i, a) || o), a;
      };
      return (r.cache = new (i.Cache || n)()), r;
    }
    (i.Cache = n), (t.exports = i);
  },
  function (t, e, r) {
    var n = r(140);
    t.exports = function (t) {
      return null == t ? "" : n(t);
    };
  },
  function (t, e, r) {
    var n = r(21),
      i = r(30),
      o = r(7),
      a = r(29),
      s = n ? n.prototype : void 0,
      l = s ? s.toString : void 0;
    t.exports = function t(e) {
      if ("string" == typeof e) return e;
      if (o(e)) return i(e, t) + "";
      if (a(e)) return l ? l.call(e) : "";
      var r = e + "";
      return "0" == r && 1 / e == -1 / 0 ? "-0" : r;
    };
  },
  function (t, e, r) {
    var n = r(28),
      i = r(31);
    t.exports = function (t, e) {
      for (var r = 0, o = (e = n(e, t)).length; null != t && r < o; )
        t = t[i(e[r++])];
      return r && r == o ? t : void 0;
    };
  },
  function (t, e, r) {
    "use strict";
    Object.defineProperty(e, "__esModule", { value: !0 });
    var n = r(12);
    function i(t, e, r) {
      var n = !1;
      e[0][0] === e[e.length - 1][0] &&
        e[0][1] === e[e.length - 1][1] &&
        (e = e.slice(0, e.length - 1));
      for (var i = 0, o = e.length - 1; i < e.length; o = i++) {
        var a = e[i][0],
          s = e[i][1],
          l = e[o][0],
          h = e[o][1];
        if (
          t[1] * (a - l) + s * (l - t[0]) + h * (t[0] - a) == 0 &&
          (a - t[0]) * (l - t[0]) <= 0 &&
          (s - t[1]) * (h - t[1]) <= 0
        )
          return !r;
        s > t[1] != h > t[1] &&
          t[0] < ((l - a) * (t[1] - s)) / (h - s) + a &&
          (n = !n);
      }
      return n;
    }
    e.default = function (t, e, r) {
      if ((void 0 === r && (r = {}), !t)) throw new Error("point is required");
      if (!e) throw new Error("polygon is required");
      var o = n.getCoord(t),
        a = n.getGeom(e),
        s = a.type,
        l = e.bbox,
        h = a.coordinates;
      if (
        l &&
        !1 ===
          (function (t, e) {
            return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1];
          })(o, l)
      )
        return !1;
      "Polygon" === s && (h = [h]);
      for (var u = !1, c = 0; c < h.length && !u; c++)
        if (i(o, h[c][0], r.ignoreBoundary)) {
          for (var f = !1, p = 1; p < h[c].length && !f; )
            i(o, h[c][p], !r.ignoreBoundary) && (f = !0), p++;
          f || (u = !0);
        }
      return u;
    };
  },
  function (t, e, r) {
    "use strict";
    Object.defineProperty(e, "__esModule", { value: !0 });
    var n = r(12);
    function i(t, e, r, n) {
      var i = r[0],
        o = r[1],
        a = t[0],
        s = t[1],
        l = e[0],
        h = e[1],
        u = l - a,
        c = h - s;
      return (
        0 == (r[0] - a) * c - (r[1] - s) * u &&
        (n
          ? "start" === n
            ? Math.abs(u) >= Math.abs(c)
              ? 0 < u
                ? a < i && i <= l
                : l <= i && i < a
              : 0 < c
              ? s < o && o <= h
              : h <= o && o < s
            : "end" === n
            ? Math.abs(u) >= Math.abs(c)
              ? 0 < u
                ? a <= i && i < l
                : l < i && i <= a
              : 0 < c
              ? s <= o && o < h
              : h < o && o <= s
            : "both" === n &&
              (Math.abs(u) >= Math.abs(c)
                ? 0 < u
                  ? a < i && i < l
                  : l < i && i < a
                : 0 < c
                ? s < o && o < h
                : h < o && o < s)
          : Math.abs(u) >= Math.abs(c)
          ? 0 < u
            ? a <= i && i <= l
            : l <= i && i <= a
          : 0 < c
          ? s <= o && o <= h
          : h <= o && o <= s)
      );
    }
    e.default = function (t, e, r) {
      void 0 === r && (r = {});
      for (
        var o = n.getCoord(t), a = n.getCoords(e), s = 0;
        s < a.length - 1;
        s++
      ) {
        var l = !1;
        if (
          (r.ignoreEndVertices &&
            (0 === s && (l = "start"),
            s === a.length - 2 && (l = "end"),
            0 === s && s + 1 === a.length - 1 && (l = "both")),
          i(a[s], a[s + 1], o, l))
        )
          return !0;
      }
      return !1;
    };
  },
  function (t, e) {
    var r,
      n,
      i = (t.exports = {});
    function o() {
      throw new Error("setTimeout has not been defined");
    }
    function a() {
      throw new Error("clearTimeout has not been defined");
    }
    function s(t) {
      if (r === setTimeout) return setTimeout(t, 0);
      if ((r === o || !r) && setTimeout)
        return (r = setTimeout), setTimeout(t, 0);
      try {
        return r(t, 0);
      } catch (e) {
        try {
          return r.call(null, t, 0);
        } catch (e) {
          return r.call(this, t, 0);
        }
      }
    }
    !(function () {
      try {
        r = "function" == typeof setTimeout ? setTimeout : o;
      } catch (t) {
        r = o;
      }
      try {
        n = "function" == typeof clearTimeout ? clearTimeout : a;
      } catch (t) {
        n = a;
      }
    })();
    var l,
      h = [],
      u = !1,
      c = -1;
    function f() {
      u &&
        l &&
        ((u = !1), l.length ? (h = l.concat(h)) : (c = -1), h.length && p());
    }
    function p() {
      if (!u) {
        var t = s(f);
        u = !0;
        for (var e = h.length; e; ) {
          for (l = h, h = []; ++c < e; ) l && l[c].run();
          (c = -1), (e = h.length);
        }
        (l = null),
          (u = !1),
          (function (t) {
            if (n === clearTimeout) return clearTimeout(t);
            if ((n === a || !n) && clearTimeout)
              return (n = clearTimeout), clearTimeout(t);
            try {
              n(t);
            } catch (e) {
              try {
                return n.call(null, t);
              } catch (e) {
                return n.call(this, t);
              }
            }
          })(t);
      }
    }
    function d(t, e) {
      (this.fun = t), (this.array = e);
    }
    function g() {}
    (i.nextTick = function (t) {
      var e = new Array(arguments.length - 1);
      if (1 < arguments.length)
        for (var r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
      h.push(new d(t, e)), 1 !== h.length || u || s(p);
    }),
      (d.prototype.run = function () {
        this.fun.apply(null, this.array);
      }),
      (i.title = "browser"),
      (i.browser = !0),
      (i.env = {}),
      (i.argv = []),
      (i.version = ""),
      (i.versions = {}),
      (i.on = g),
      (i.addListener = g),
      (i.once = g),
      (i.off = g),
      (i.removeListener = g),
      (i.removeAllListeners = g),
      (i.emit = g),
      (i.prependListener = g),
      (i.prependOnceListener = g),
      (i.listeners = function (t) {
        return [];
      }),
      (i.binding = function (t) {
        throw new Error("process.binding is not supported");
      }),
      (i.cwd = function () {
        return "/";
      }),
      (i.chdir = function (t) {
        throw new Error("process.chdir is not supported");
      }),
      (i.umask = function () {
        return 0;
      });
  },
  function (t, e, r) {
    "use strict";
    Object.defineProperty(e, "__esModule", { value: !0 });
    var n = r(8),
      i = r(12),
      o = r(11);
    e.default = function (t) {
      if (!t) throw new Error("geojson is required");
      var e = [];
      return (
        o.flattenEach(t, function (t) {
          !(function (t, e) {
            var r = [],
              o = t.geometry;
            if (null !== o) {
              switch (o.type) {
                case "Polygon":
                  r = i.getCoords(o);
                  break;
                case "LineString":
                  r = [i.getCoords(o)];
              }
              r.forEach(function (r) {
                (function (t, e) {
                  var r = [];
                  return (
                    t.reduce(function (t, i) {
                      var o = n.lineString([t, i], e);
                      return (
                        (o.bbox = (function (t, e) {
                          var r = t[0],
                            n = t[1],
                            i = e[0],
                            o = e[1];
                          return [
                            r < i ? r : i,
                            n < o ? n : o,
                            i < r ? r : i,
                            o < n ? n : o,
                          ];
                        })(t, i)),
                        r.push(o),
                        i
                      );
                    }),
                    r
                  );
                })(r, t.properties).forEach(function (t) {
                  (t.id = e.length), e.push(t);
                });
              });
            }
          })(t, e);
        }),
        n.featureCollection(e)
      );
    };
  },
  function (t, e, r) {
    var n = r(147),
      i = r(8),
      o = r(11),
      a = r(49).default,
      s = o.featureEach,
      l = (o.coordEach, i.polygon, i.featureCollection);
    function h(t) {
      var e = n(t);
      return (
        (e.insert = function (t) {
          if ("Feature" !== t.type) throw new Error("invalid feature");
          return (
            (t.bbox = t.bbox ? t.bbox : a(t)), n.prototype.insert.call(this, t)
          );
        }),
        (e.load = function (t) {
          var e = [];
          return (
            Array.isArray(t)
              ? t.forEach(function (t) {
                  if ("Feature" !== t.type) throw new Error("invalid features");
                  (t.bbox = t.bbox ? t.bbox : a(t)), e.push(t);
                })
              : s(t, function (t) {
                  if ("Feature" !== t.type) throw new Error("invalid features");
                  (t.bbox = t.bbox ? t.bbox : a(t)), e.push(t);
                }),
            n.prototype.load.call(this, e)
          );
        }),
        (e.remove = function (t, e) {
          if ("Feature" !== t.type) throw new Error("invalid feature");
          return (
            (t.bbox = t.bbox ? t.bbox : a(t)),
            n.prototype.remove.call(this, t, e)
          );
        }),
        (e.clear = function () {
          return n.prototype.clear.call(this);
        }),
        (e.search = function (t) {
          var e = n.prototype.search.call(this, this.toBBox(t));
          return l(e);
        }),
        (e.collides = function (t) {
          return n.prototype.collides.call(this, this.toBBox(t));
        }),
        (e.all = function () {
          var t = n.prototype.all.call(this);
          return l(t);
        }),
        (e.toJSON = function () {
          return n.prototype.toJSON.call(this);
        }),
        (e.fromJSON = function (t) {
          return n.prototype.fromJSON.call(this, t);
        }),
        (e.toBBox = function (t) {
          var e;
          if (t.bbox) e = t.bbox;
          else if (Array.isArray(t) && 4 === t.length) e = t;
          else if (Array.isArray(t) && 6 === t.length)
            e = [t[0], t[1], t[3], t[4]];
          else if ("Feature" === t.type) e = a(t);
          else {
            if ("FeatureCollection" !== t.type)
              throw new Error("invalid geojson");
            e = a(t);
          }
          return { minX: e[0], minY: e[1], maxX: e[2], maxY: e[3] };
        }),
        e
      );
    }
    (t.exports = h), (t.exports.default = h);
  },
  function (t, e, r) {
    "use strict";
    (t.exports = i), (t.exports.default = i);
    var n = r(148);
    function i(t, e) {
      if (!(this instanceof i)) return new i(t, e);
      (this._maxEntries = Math.max(4, t || 9)),
        (this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries))),
        e && this._initFormat(e),
        this.clear();
    }
    function o(t, e, r) {
      if (!r) return e.indexOf(t);
      for (var n = 0; n < e.length; n++) if (r(t, e[n])) return n;
      return -1;
    }
    function a(t, e) {
      s(t, 0, t.children.length, e, t);
    }
    function s(t, e, r, n, i) {
      ((i = i || g(null)).minX = 1 / 0),
        (i.minY = 1 / 0),
        (i.maxX = -1 / 0),
        (i.maxY = -1 / 0);
      for (var o, a = e; a < r; a++)
        (o = t.children[a]), l(i, t.leaf ? n(o) : o);
      return i;
    }
    function l(t, e) {
      return (
        (t.minX = Math.min(t.minX, e.minX)),
        (t.minY = Math.min(t.minY, e.minY)),
        (t.maxX = Math.max(t.maxX, e.maxX)),
        (t.maxY = Math.max(t.maxY, e.maxY)),
        t
      );
    }
    function h(t, e) {
      return t.minX - e.minX;
    }
    function u(t, e) {
      return t.minY - e.minY;
    }
    function c(t) {
      return (t.maxX - t.minX) * (t.maxY - t.minY);
    }
    function f(t) {
      return t.maxX - t.minX + (t.maxY - t.minY);
    }
    function p(t, e) {
      return (
        t.minX <= e.minX &&
        t.minY <= e.minY &&
        e.maxX <= t.maxX &&
        e.maxY <= t.maxY
      );
    }
    function d(t, e) {
      return (
        e.minX <= t.maxX &&
        e.minY <= t.maxY &&
        e.maxX >= t.minX &&
        e.maxY >= t.minY
      );
    }
    function g(t) {
      return {
        children: t,
        height: 1,
        leaf: !0,
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0,
      };
    }
    function m(t, e, r, i, o) {
      for (var a, s = [e, r]; s.length; )
        (r = s.pop()) - (e = s.pop()) <= i ||
          ((a = e + Math.ceil((r - e) / i / 2) * i),
          n(t, a, e, r, o),
          s.push(e, a, a, r));
    }
    i.prototype = {
      all: function () {
        return this._all(this.data, []);
      },
      search: function (t) {
        var e = this.data,
          r = [],
          n = this.toBBox;
        if (!d(t, e)) return r;
        for (var i, o, a, s, l = []; e; ) {
          for (i = 0, o = e.children.length; i < o; i++)
            (a = e.children[i]),
              d(t, (s = e.leaf ? n(a) : a)) &&
                (e.leaf ? r.push(a) : p(t, s) ? this._all(a, r) : l.push(a));
          e = l.pop();
        }
        return r;
      },
      collides: function (t) {
        var e = this.data,
          r = this.toBBox;
        if (!d(t, e)) return !1;
        for (var n, i, o, a, s = []; e; ) {
          for (n = 0, i = e.children.length; n < i; n++)
            if (((o = e.children[n]), d(t, (a = e.leaf ? r(o) : o)))) {
              if (e.leaf || p(t, a)) return !0;
              s.push(o);
            }
          e = s.pop();
        }
        return !1;
      },
      load: function (t) {
        if (!t || !t.length) return this;
        if (t.length < this._minEntries) {
          for (var e = 0, r = t.length; e < r; e++) this.insert(t[e]);
          return this;
        }
        var n = this._build(t.slice(), 0, t.length - 1, 0);
        if (this.data.children.length)
          if (this.data.height === n.height) this._splitRoot(this.data, n);
          else {
            if (this.data.height < n.height) {
              var i = this.data;
              (this.data = n), (n = i);
            }
            this._insert(n, this.data.height - n.height - 1, !0);
          }
        else this.data = n;
        return this;
      },
      insert: function (t) {
        return t && this._insert(t, this.data.height - 1), this;
      },
      clear: function () {
        return (this.data = g([])), this;
      },
      remove: function (t, e) {
        if (!t) return this;
        for (
          var r, n, i, a, s = this.data, l = this.toBBox(t), h = [], u = [];
          s || h.length;

        ) {
          if (
            (s ||
              ((s = h.pop()), (n = h[h.length - 1]), (r = u.pop()), (a = !0)),
            s.leaf && -1 !== (i = o(t, s.children, e)))
          )
            return s.children.splice(i, 1), h.push(s), this._condense(h), this;
          a || s.leaf || !p(s, l)
            ? n
              ? (r++, (s = n.children[r]), (a = !1))
              : (s = null)
            : (h.push(s), u.push(r), (r = 0), (s = (n = s).children[0]));
        }
        return this;
      },
      toBBox: function (t) {
        return t;
      },
      compareMinX: h,
      compareMinY: u,
      toJSON: function () {
        return this.data;
      },
      fromJSON: function (t) {
        return (this.data = t), this;
      },
      _all: function (t, e) {
        for (var r = []; t; )
          t.leaf ? e.push.apply(e, t.children) : r.push.apply(r, t.children),
            (t = r.pop());
        return e;
      },
      _build: function (t, e, r, n) {
        var i,
          o = r - e + 1,
          s = this._maxEntries;
        if (o <= s) return a((i = g(t.slice(e, r + 1))), this.toBBox), i;
        n ||
          ((n = Math.ceil(Math.log(o) / Math.log(s))),
          (s = Math.ceil(o / Math.pow(s, n - 1)))),
          ((i = g([])).leaf = !1),
          (i.height = n);
        var l,
          h,
          u,
          c,
          f = Math.ceil(o / s),
          p = f * Math.ceil(Math.sqrt(s));
        for (m(t, e, r, p, this.compareMinX), l = e; l <= r; l += p)
          for (
            m(t, l, (u = Math.min(l + p - 1, r)), f, this.compareMinY), h = l;
            h <= u;
            h += f
          )
            (c = Math.min(h + f - 1, u)),
              i.children.push(this._build(t, h, c, n - 1));
        return a(i, this.toBBox), i;
      },
      _chooseSubtree: function (t, e, r, n) {
        for (
          var i, o, a, s, l, h, u, f, p, d;
          n.push(e), !e.leaf && n.length - 1 !== r;

        ) {
          for (u = f = 1 / 0, i = 0, o = e.children.length; i < o; i++)
            (l = c((a = e.children[i]))),
              (p = t),
              (d = a),
              (h =
                (Math.max(d.maxX, p.maxX) - Math.min(d.minX, p.minX)) *
                  (Math.max(d.maxY, p.maxY) - Math.min(d.minY, p.minY)) -
                l) < f
                ? ((f = h), (u = l < u ? l : u), (s = a))
                : h === f && l < u && ((u = l), (s = a));
          e = s || e.children[0];
        }
        return e;
      },
      _insert: function (t, e, r) {
        var n = this.toBBox,
          i = r ? t : n(t),
          o = [],
          a = this._chooseSubtree(i, this.data, e, o);
        for (
          a.children.push(t), l(a, i);
          0 <= e && o[e].children.length > this._maxEntries;

        )
          this._split(o, e), e--;
        this._adjustParentBBoxes(i, o, e);
      },
      _split: function (t, e) {
        var r = t[e],
          n = r.children.length,
          i = this._minEntries;
        this._chooseSplitAxis(r, i, n);
        var o = this._chooseSplitIndex(r, i, n),
          s = g(r.children.splice(o, r.children.length - o));
        (s.height = r.height),
          (s.leaf = r.leaf),
          a(r, this.toBBox),
          a(s, this.toBBox),
          e ? t[e - 1].children.push(s) : this._splitRoot(r, s);
      },
      _splitRoot: function (t, e) {
        (this.data = g([t, e])),
          (this.data.height = t.height + 1),
          (this.data.leaf = !1),
          a(this.data, this.toBBox);
      },
      _chooseSplitIndex: function (t, e, r) {
        var n, i, o, a, l, h, u, f, p, d, g, m, y, _;
        for (h = u = 1 / 0, n = e; n <= r - e; n++)
          (p = i = s(t, 0, n, this.toBBox)),
            (d = o = s(t, n, r, this.toBBox)),
            (g = Math.max(p.minX, d.minX)),
            (m = Math.max(p.minY, d.minY)),
            (y = Math.min(p.maxX, d.maxX)),
            (_ = Math.min(p.maxY, d.maxY)),
            (a = Math.max(0, y - g) * Math.max(0, _ - m)),
            (l = c(i) + c(o)),
            a < h
              ? ((h = a), (f = n), (u = l < u ? l : u))
              : a === h && l < u && ((u = l), (f = n));
        return f;
      },
      _chooseSplitAxis: function (t, e, r) {
        var n = t.leaf ? this.compareMinX : h,
          i = t.leaf ? this.compareMinY : u;
        this._allDistMargin(t, e, r, n) < this._allDistMargin(t, e, r, i) &&
          t.children.sort(n);
      },
      _allDistMargin: function (t, e, r, n) {
        t.children.sort(n);
        var i,
          o,
          a = this.toBBox,
          h = s(t, 0, e, a),
          u = s(t, r - e, r, a),
          c = f(h) + f(u);
        for (i = e; i < r - e; i++)
          (o = t.children[i]), l(h, t.leaf ? a(o) : o), (c += f(h));
        for (i = r - e - 1; e <= i; i--)
          (o = t.children[i]), l(u, t.leaf ? a(o) : o), (c += f(u));
        return c;
      },
      _adjustParentBBoxes: function (t, e, r) {
        for (var n = r; 0 <= n; n--) l(e[n], t);
      },
      _condense: function (t) {
        for (var e, r = t.length - 1; 0 <= r; r--)
          0 === t[r].children.length
            ? 0 < r
              ? (e = t[r - 1].children).splice(e.indexOf(t[r]), 1)
              : this.clear()
            : a(t[r], this.toBBox);
      },
      _initFormat: function (t) {
        var e = ["return a", " - b", ";"];
        (this.compareMinX = new Function("a", "b", e.join(t[0]))),
          (this.compareMinY = new Function("a", "b", e.join(t[1]))),
          (this.toBBox = new Function(
            "a",
            "return {minX: a" +
              t[0] +
              ", minY: a" +
              t[1] +
              ", maxX: a" +
              t[2] +
              ", maxY: a" +
              t[3] +
              "};"
          ));
      },
    };
  },
  function (t, e, r) {
    t.exports = (function () {
      "use strict";
      function t(t, e, r) {
        var n = t[e];
        (t[e] = t[r]), (t[r] = n);
      }
      function e(t, e) {
        return t < e ? -1 : e < t ? 1 : 0;
      }
      return function (r, n, i, o, a) {
        !(function e(r, n, i, o, a) {
          for (; i < o; ) {
            if (600 < o - i) {
              var s = o - i + 1,
                l = n - i + 1,
                h = Math.log(s),
                u = 0.5 * Math.exp((2 * h) / 3),
                c =
                  0.5 *
                  Math.sqrt((h * u * (s - u)) / s) *
                  (l - s / 2 < 0 ? -1 : 1);
              e(
                r,
                n,
                Math.max(i, Math.floor(n - (l * u) / s + c)),
                Math.min(o, Math.floor(n + ((s - l) * u) / s + c)),
                a
              );
            }
            var f = r[n],
              p = i,
              d = o;
            for (t(r, i, n), 0 < a(r[o], f) && t(r, i, o); p < d; ) {
              for (t(r, p, d), p++, d--; a(r[p], f) < 0; ) p++;
              for (; 0 < a(r[d], f); ) d--;
            }
            0 === a(r[i], f) ? t(r, i, d) : t(r, ++d, o),
              d <= n && (i = d + 1),
              n <= d && (o = d - 1);
          }
        })(r, n, i || 0, o || r.length - 1, a || e);
      };
    })();
  },
  function (t, e, r) {
    var n = r(150),
      i = r(153),
      o = r(158),
      a = r(30),
      s = r(43),
      l = r(159),
      h = Math.min;
    t.exports = function (t, e, r) {
      for (
        var u = r ? o : i,
          c = t[0].length,
          f = t.length,
          p = f,
          d = Array(f),
          g = 1 / 0,
          m = [];
        p--;

      ) {
        var y = t[p];
        p && e && (y = a(y, s(e))),
          (g = h(y.length, g)),
          (d[p] =
            !r && (e || (120 <= c && 120 <= y.length))
              ? new n(p && y)
              : void 0);
      }
      y = t[0];
      var _ = -1,
        v = d[0];
      t: for (; ++_ < c && m.length < g; ) {
        var b = y[_],
          L = e ? e(b) : b;
        if (((b = r || 0 !== b ? b : 0), !(v ? l(v, L) : u(m, L, r)))) {
          for (p = f; --p; ) {
            var k = d[p];
            if (!(k ? l(k, L) : u(t[p], L, r))) continue t;
          }
          v && v.push(L), m.push(b);
        }
      }
      return m;
    };
  },
  function (t, e, r) {
    var n = r(22),
      i = r(151),
      o = r(152);
    function a(t) {
      var e = -1,
        r = null == t ? 0 : t.length;
      for (this.__data__ = new n(); ++e < r; ) this.add(t[e]);
    }
    (a.prototype.add = a.prototype.push = i),
      (a.prototype.has = o),
      (t.exports = a);
  },
  function (t, e) {
    t.exports = function (t) {
      return this.__data__.set(t, "__lodash_hash_undefined__"), this;
    };
  },
  function (t, e) {
    t.exports = function (t) {
      return this.__data__.has(t);
    };
  },
  function (t, e, r) {
    var n = r(154);
    t.exports = function (t, e) {
      return !(null == t || !t.length) && -1 < n(t, e, 0);
    };
  },
  function (t, e, r) {
    var n = r(155),
      i = r(156),
      o = r(157);
    t.exports = function (t, e, r) {
      return e == e ? o(t, e, r) : n(t, i, r);
    };
  },
  function (t, e) {
    t.exports = function (t, e, r, n) {
      for (var i = t.length, o = r + (n ? 1 : -1); n ? o-- : ++o < i; )
        if (e(t[o], o, t)) return o;
      return -1;
    };
  },
  function (t, e) {
    t.exports = function (t) {
      return t != t;
    };
  },
  function (t, e) {
    t.exports = function (t, e, r) {
      for (var n = r - 1, i = t.length; ++n < i; ) if (t[n] === e) return n;
      return -1;
    };
  },
  function (t, e) {
    t.exports = function (t, e, r) {
      for (var n = -1, i = null == t ? 0 : t.length; ++n < i; )
        if (r(e, t[n])) return !0;
      return !1;
    };
  },
  function (t, e) {
    t.exports = function (t, e) {
      return t.has(e);
    };
  },
  function (t, e, r) {
    var n = r(40);
    t.exports = function (t) {
      return n(t) ? t : [];
    };
  },
  function (t, e) {
    t.exports = function (t) {
      var e = null == t ? 0 : t.length;
      return e ? t[e - 1] : void 0;
    };
  },
  function (t, e, r) {
    var n = r(45),
      i = r(28),
      o = r(18),
      a = r(3),
      s = r(31);
    t.exports = function (t, e, r, l) {
      if (!a(t)) return t;
      for (
        var h = -1, u = (e = i(e, t)).length, c = u - 1, f = t;
        null != f && ++h < u;

      ) {
        var p = s(e[h]),
          d = r;
        if ("__proto__" === p || "constructor" === p || "prototype" === p)
          return t;
        if (h != c) {
          var g = f[p];
          void 0 === (d = l ? l(g, p, f) : void 0) &&
            (d = a(g) ? g : o(e[h + 1]) ? [] : {});
        }
        n(f, p, d), (f = f[p]);
      }
      return t;
    };
  },
  function (t, e, r) {},
  function (t, e, r) {},
  function (t, e, r) {
    "use strict";
    r.r(e), r(70);
    var n = r(50),
      i = r(32),
      o = r.n(i),
      a = r(51),
      s = r(52),
      l = r(53),
      h = r(54),
      u = r(55),
      c = r(56),
      f = r(57),
      p = r(58),
      d = r(59),
      g = r(60),
      m = {
        en: a,
        de: s,
        it: l,
        id: h,
        ro: u,
        ru: c,
        es: f,
        nl: p,
        fr: d,
        pt_br: r(61),
        zh: g,
        pl: r(62),
        sv: r(63),
        el: r(64),
        hu: r(65),
      },
      y = r(66),
      _ = r.n(y),
      v = r(0),
      b = r.n(v),
      k = r(2),
      M = r.n(k),
      w = r(33),
      x = r.n(w);
    function S(t) {
      var e = { type: "Feature" };
      return (e.geometry = t), e;
    }
    function E(t) {
      return "Feature" === t.type ? t.geometry : t;
    }
    function C(t, e) {
      var r = 1 < arguments.length && void 0 !== e ? e : -1;
      return (
        -1 < r &&
          ((t[0] = L.Util.formatNum(t[0], r)),
          (t[1] = L.Util.formatNum(t[1], r))),
        S({ type: "Point", coordinates: t })
      );
    }
    function P(t) {
      return S({ type: "Polygon", coordinates: t });
    }
    function O(t) {
      return S({ type: "MultiPolygon", coordinates: t });
    }
    var B = r(1),
      T = r.n(B),
      D = r(4),
      I = r.n(D),
      j = r(67),
      A = r.n(j);
    function R(t) {
      return (
        (function (t) {
          if (Array.isArray(t)) return N(t);
        })(t) ||
        (function (t) {
          if ("undefined" != typeof Symbol && Symbol.iterator in Object(t))
            return Array.from(t);
        })(t) ||
        G(t) ||
        (function () {
          throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        })()
      );
    }
    function G(t, e) {
      if (t) {
        if ("string" == typeof t) return N(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        return (
          "Object" === r && t.constructor && (r = t.constructor.name),
          "Map" === r || "Set" === r
            ? Array.from(t)
            : "Arguments" === r ||
              /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
            ? N(t, e)
            : void 0
        );
      }
    }
    function N(t, e) {
      (null == e || e > t.length) && (e = t.length);
      for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
      return n;
    }
    function F(t, e, r) {
      e.forEach(function (e) {
        var n = t.pm.Draw.Split._calcClosestLayer(e, [r]),
          i = r.getLatLngs();
        if (void 0 === at.findDeepCoordIndex(i, e).index) {
          var o = at._getIndexFromSegment(i, n.segment),
            a = o.indexPath,
            s = o.parentPath,
            l = o.newIndex;
          (1 < a.length ? b()(i, s) : i).splice(l, 0, e);
        }
      });
    }
    function z(t, e) {
      return e
        ? t.findIndex(function (t) {
            return !!t && L.latLng(t).equals(L.latLng(e));
          })
        : -1;
    }
    function q(t, e) {
      var r = !1;
      return (
        1 < t.getLatLngs().length &&
          t.getLatLngs().forEach(function (t, n) {
            if (0 !== n && !r) {
              var i = L.polygon(t).toGeoJSON(15);
              M()(i, C([e.lng, e.lat], 15)) && (r = !0);
            }
          }),
        r
      );
    }
    function Y(t) {
      t.forEach(function (t, e) {
        if (1 < t.length) {
          if (0 === e) return;
          t.reverse();
          var r = t.pop();
          t.unshift(r);
        }
      });
    }
    function X(t, e) {
      return t.filter(function (t) {
        var r = t.intersections;
        return !!r && void 0 !== at.findDeepCoordIndex(r, e).index;
      });
    }
    function U(t) {
      return Array.isArray(t) ? t.forEach(U, this) : (delete t.additional, !0);
    }
    function J(t, e, r, n) {
      var i = b()(r, n);
      if (0 < n[0]) {
        var o = I()(t.intersections, i, function (t, e) {
          return t.equals(e);
        }).find(function (t) {
          return !t.equals(e);
        });
        if (void 0 !== o) return [o];
        var a = I()(t.mainIntersections, i, function (t, e) {
          return t.equals(e);
        });
        a.sort(function (e, r) {
          return z(t.mainLine.getLatLngs(), e) - z(t.mainLine.getLatLngs(), r);
        });
        var s = z(a, e),
          l = null;
        return (
          s % 2 == 0 ? s < a.length && (l = a[s + 1]) : 0 < s && (l = a[s - 1]),
          [(l = l || e)]
        );
      }
      var h = I()(t.intersections, i, function (t, e) {
        return t.equals(e);
      }).filter(function (t) {
        return !t.equals(e);
      });
      return 0 === h.length
        ? (function (t, e, r) {
            var n = t.mainLine.getLatLngs(),
              i = I()(n, r, function (t, e) {
                return t.equals(e);
              });
            return (
              2 < i.length &&
                (i = i.filter(function (e) {
                  return -1 < z(t.intersections, e);
                })),
              i.length <= 1 &&
                (i = I()(t.intersections, r, function (t, e) {
                  return t.equals(e);
                })),
              i.filter(function (t) {
                return !t.equals(e);
              })
            );
          })(t, e, i)
        : h;
    }
    function V(t, e, r, n) {
      if (!e) return !1;
      if (e.length <= 2) return !1;
      var i = e.filter(function (t) {
          return !0 !== t.additional;
        }),
        o = (function (t, e, r) {
          return t.filter(function (t) {
            var n = t.useMain ? t.mainIntersections : t.intersections;
            if (!n) return !1;
            var i = at.findDeepCoordIndex(n, e).index,
              o = at.findDeepCoordIndex(n, r).index;
            return void 0 !== i && void 0 !== o;
          });
        })(
          t,
          i[0],
          (function (t, e) {
            return (
              (function (t) {
                if (Array.isArray(t)) return t;
              })(t) ||
              (function (t, e) {
                if (
                  "undefined" != typeof Symbol &&
                  Symbol.iterator in Object(t)
                ) {
                  var r = [],
                    n = !0,
                    i = !1,
                    o = void 0;
                  try {
                    for (
                      var a, s = t[Symbol.iterator]();
                      !(n = (a = s.next()).done) &&
                      (r.push(a.value), !e || r.length !== e);
                      n = !0
                    );
                  } catch (t) {
                    (i = !0), (o = t);
                  } finally {
                    try {
                      n || null == s.return || s.return();
                    } finally {
                      if (i) throw o;
                    }
                  }
                  return r;
                }
              })(t, e) ||
              G(t, e) ||
              (function () {
                throw new TypeError(
                  "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                );
              })()
            );
          })(i.slice(-1), 1)[0]
        ),
        a = [];
      return (
        o.forEach(function (t) {
          if (t.useMain) {
            var i = [];
            t.mainIntersections.forEach(function (t) {
              at.findDeepCoordIndex(n, t).parentPath[0] === r[0] && i.push(t);
            }),
              I()(t.mainIntersections, e, function (t, e) {
                return t.equals(e);
              }).length === i.length && a.push(t);
          } else a.push(t);
        }),
        0 < a.length
      );
    }
    function H(t, e, r, n, i, o) {
      for (
        var a,
          s = 3 < arguments.length && void 0 !== n ? n : 1,
          l = 4 < arguments.length ? i : void 0,
          h = 5 < arguments.length ? o : void 0,
          u = r + s;
        0 <= u;
        u += s
      )
        if (!V(t, b()(e, [u].concat(R(l))), l, h)) {
          a = u;
          break;
        }
      return a;
    }
    function K(t, e, r) {
      var n = b()(t, e.slice(0, -1));
      (void 0 !== n && -1 !== z(n, r)) || A()(t, e, r);
    }
    function $(t, e, r) {
      var n = [t].concat(R(e)),
        i = b()(r, n);
      return i ? n.push(i.length) : n.push(0), n;
    }
    function Z(t, e, r) {
      var n = t.getLatLngs(),
        i = r.pm.Draw.Split._calcClosestLayer(e[0], [t]),
        o = r.pm.Draw.Split._calcClosestLayer(e[1], [t]);
      return {
        lineIndexA: at._getIndexFromSegment(n, i.segment).indexB.index,
        lineIndexB: at._getIndexFromSegment(n, o.segment).indexB.index,
        lineCoords: n,
      };
    }
    function W(t, e) {
      return t.intersections.find(function (t) {
        return !t.equals(e);
      });
    }
    function Q(t, e) {
      return -1 < z(t, e);
    }
    function tt(t, e, r, n) {
      var i = [e],
        o = b()(t, i);
      o ? i.push(o.length) : i.push(0), n.push(r), K(t, i, r);
    }
    function et(t, e) {
      0 !== e && -1 === t.indexOf(e) && t.push(e);
    }
    function rt(t) {
      var e = L.PM.activeLang;
      return _()(m, e) || (e = "en"), b()(m[e], t);
    }
    function nt(t, e, r) {
      for (
        var n,
          i,
          o,
          a = 6378137,
          s = 6356752.3142,
          l = 1 / 298.257223563,
          h = t.lng,
          u = t.lat,
          c = r,
          f = Math.PI,
          p = (e * f) / 180,
          d = Math.sin(p),
          g = Math.cos(p),
          m = (1 - l) * Math.tan((u * f) / 180),
          y = 1 / Math.sqrt(1 + m * m),
          _ = m * y,
          v = Math.atan2(m, g),
          b = y * d,
          k = 1 - b * b,
          M = (k * (a * a - s * s)) / (s * s),
          w = 1 + (M / 16384) * (4096 + M * (M * (320 - 175 * M) - 768)),
          x = (M / 1024) * (256 + M * (M * (74 - 47 * M) - 128)),
          S = c / (s * w),
          E = 2 * Math.PI;
        1e-12 < Math.abs(S - E);

      )
        (n = Math.cos(2 * v + S)),
          (E = S),
          (S =
            c / (s * w) +
            x *
              (i = Math.sin(S)) *
              (n +
                (x / 4) *
                  ((o = Math.cos(S)) * (2 * n * n - 1) -
                    (x / 6) * n * (4 * i * i - 3) * (4 * n * n - 3))));
      var C = _ * i - y * o * g,
        P = Math.atan2(_ * o + y * i * g, (1 - l) * Math.sqrt(b * b + C * C)),
        O = (l / 16) * k * (4 + l * (4 - 3 * k)),
        B =
          h +
          (180 *
            (Math.atan2(i * d, y * o - _ * i * g) -
              (1 - O) * l * b * (S + O * i * (n + O * o * (2 * n * n - 1))))) /
            f,
        T = (180 * P) / f;
      return L.latLng(B, T);
    }
    function it(t, e, r, n) {
      for (var i, o, a = [], s = 0; s < r; s += 1)
        (i = nt(t, (360 * s) / r + n, e)),
          (o = L.latLng(i.lng, i.lat)),
          a.push(o);
      return a;
    }
    function ot(t, e, r) {
      var n = this,
        i = L.polygon(e.getLatLngs()),
        o = L.polyline(t.getLatLngs());
      if (o.getLatLngs().length < 2) return i;
      var a = L.polygon(i.getLatLngs());
      Y(a.getLatLngs());
      var s = a.toGeoJSON(15),
        l = (function (t, e, r, n) {
          var i = [],
            o = L.polyline([]),
            a = L.polyline([]);
          return (
            t.getLatLngs().forEach(function (s, l) {
              if (
                (a.addLatLng(s),
                !(
                  ((M()(r, C([s.lng, s.lat], 15)) ||
                    a.getLatLngs().length < 2) &&
                    l !== t.getLatLngs().length - 1) ||
                  (1 < e.getLatLngs().length &&
                    l !== t.getLatLngs().length - 1 &&
                    q(e, s))
                ))
              ) {
                (o = L.polyline(a.getLatLngs())), (a = L.polyline([s]));
                var h = T()(o.toGeoJSON(15), r);
                if (!(h.features.length < 2)) {
                  var u = (function (t) {
                    var e = [];
                    return (
                      t.features &&
                        t.features.forEach(function (t) {
                          e.push(
                            (function (t) {
                              var e = (function (t) {
                                return t && t.geometry && t.geometry.coordinates
                                  ? t.geometry.coordinates
                                  : t;
                              })(t);
                              return L.latLng(e[1], e[0]);
                            })(t)
                          );
                        }),
                      e
                    );
                  })(h);
                  F(n, u, e),
                    F(n, u, o),
                    u.sort(function (t, e) {
                      return z(o.getLatLngs(), t) - z(o.getLatLngs(), e);
                    });
                  for (var c = [], f = 0; f < u.length; f += 2)
                    if (u[f] && u[f + 1]) {
                      var p = u[f],
                        d = u[f + 1];
                      if (p.equals(d, 1e-8)) continue;
                      var g = at.findDeepCoordIndex(e.getLatLngs(), p)
                          .parentPath,
                        m = at.findDeepCoordIndex(e.getLatLngs(), d).parentPath;
                      g[0] === m[0] || g[0] < m[0]
                        ? c.push([p, d])
                        : c.push([d, p]);
                    }
                  for (
                    var y = function (t) {
                        var r = o.getLatLngs();
                        if (1 < c.length) {
                          var a = o.getLatLngs().findIndex(function (e) {
                              return e.equals(c[t][0]);
                            }),
                            s = o.getLatLngs().findIndex(function (e) {
                              return e.equals(c[t][1]);
                            }),
                            l = a < s ? [a, s] : [s, a],
                            h = l[0],
                            f = l[1];
                          0 < h && (h -= 1), (f += 1);
                          var p = function (t) {
                            return (
                              void 0 !==
                              u.find(function (e) {
                                return e.equals(t);
                              })
                            );
                          };
                          if (o.getLatLngs()[f] && p(o.getLatLngs()[f])) {
                            var d = at.calcMiddleLatLng(
                              n,
                              o.getLatLngs()[f - 1],
                              o.getLatLngs()[f]
                            );
                            o.getLatLngs().splice(f, 0, d);
                          }
                          if (
                            -1 < h &&
                            o.getLatLngs()[h] &&
                            p(o.getLatLngs()[h])
                          ) {
                            var g = at.calcMiddleLatLng(
                              n,
                              o.getLatLngs()[h],
                              o.getLatLngs()[h + 1]
                            );
                            o.getLatLngs().splice(h, 0, g), (h += 1), (f += 1);
                          }
                          r = o.getLatLngs().slice(h, f + 1);
                        }
                        var m = L.polyline(r),
                          y = at.findDeepCoordIndex(e.getLatLngs(), c[t][0])
                            .parentPath,
                          _ = at.findDeepCoordIndex(e.getLatLngs(), c[t][1])
                            .parentPath,
                          v = y[0] !== _[0];
                        if ((0 < y[0] || 0 < _[0]) && 1 === c.length)
                          return "continue";
                        i.push({
                          layer: m,
                          intersections: [c[t][0], c[t][1]],
                          mainLine: o,
                          mainIntersections: c.flat(),
                          useMain: v,
                        });
                      },
                      _ = 0;
                    _ < c.length;
                    _ += 1
                  )
                    y(_);
                }
              }
            }),
            i
          );
        })(o, a, s, r),
        h = L.polygon(a.getLatLngs()).getLatLngs(),
        u = [],
        c = [],
        f = [];
      (function t(e) {
        if (Array.isArray(e[0])) return e.forEach(t, n);
        var i = e[0],
          o = at.findDeepCoordIndex(h, i).parentPath,
          u = 0;
        if (0 < o[0]) {
          var p = -1,
            d = e[0];
          e.forEach(function (t) {
            (function (t, e) {
              return t.filter(function (t) {
                var r = JSON.parse(JSON.stringify(t));
                U(r);
                var n = L.polygon(r);
                return M()(n.toGeoJSON(15), C([e.lng, e.lat], 15));
              });
            })(f, t).forEach(function (e) {
              var r = f.indexOf(e);
              (-1 === p || r < p) && (0 < X(l, t).length || ((p = r), (d = t)));
            });
          }),
            -1 < p &&
              ((e = (function (t, e) {
                for (var r = [], n = 0; n < t.length; n += 1)
                  r.push(t[(n + e) % t.length]);
                return r;
              })(e, z(e, d))),
              (u = p));
        }
        var g = L.featureGroup();
        return (
          g.addTo(r),
          e.forEach(function (t) {
            var e = X(l, t),
              n = 0 < e.length;
            e.forEach(function (t) {
              g.addLayer(t.layer),
                g.addLayer(L.marker(t.intersections[0])),
                g.addLayer(L.marker(t.intersections[1]));
            });
            var i = at.findDeepCoordIndex(h, t).parentPath;
            if ((K(c, $(u, i, c), t), K(f, $(u, i, f), t), n)) {
              if (1 < e.length) {
                var o = J(e[0], t, h, i);
                void 0 !== at.findDeepCoordIndex(c, o[0]).index || e.reverse();
              }
              e.forEach(function (e) {
                var n = J(e, t, h, i),
                  o = !1;
                0 < n.length &&
                  (o = void 0 !== at.findDeepCoordIndex(c, n[0]).index);
                var p = [],
                  d = [];
                if (o) {
                  var g = Z(e.layer, e.intersections, r),
                    m = g.lineIndexA,
                    y = g.lineIndexB,
                    _ = g.lineCoords;
                  if (m + 1 !== y)
                    for (var v = m; v < y; v += 1)
                      M()(s, C([_[v].lng, _[v].lat], 15)) && p.push(_[v]);
                  if (e.useMain) {
                    var L = e.mainIntersections[0],
                      k = e.mainIntersections[e.mainIntersections.length - 1],
                      w = Z(e.mainLine, [L, k], r),
                      x = w.lineIndexA,
                      S = w.lineIndexB,
                      E = w.lineCoords;
                    if (x + 1 !== S)
                      for (var P = x; P < S; P += 1)
                        -1 === z(e.mainIntersections, E[P]) &&
                          q(a, E[P]) &&
                          d.push(E[P]);
                  }
                  e.intersections[0].equals(t) && (p.reverse(), d.reverse()),
                    p.reverse(),
                    d.reverse(),
                    p.forEach(function (t) {
                      (t.additional = !0), K(c, $(u, i, c), t);
                    }),
                    d.forEach(function (t) {
                      K(f, $(u, i, f), t);
                    });
                  var O = -1;
                  0 === u && (O = 1), (u = H(l, c, u, O, i, h));
                } else (u = H(l, c, u, 1, i, h)), 0 < i[0] && !b()(c, [u, 0]) && (u = H(l, c, u, -2, i, h));
                o &&
                  (p.reverse(),
                  d.reverse(),
                  p.forEach(function (t) {
                    (t.additional = !0), K(c, $(u, i, c), t);
                  }),
                  d.forEach(function (t) {
                    K(f, $(u, i, f), t);
                  })),
                  K(c, $(u, i, c), t),
                  K(f, $(u, i, f), t);
              });
            }
            g.clearLayers();
          }),
          e
        );
      })(h),
        (u = []);
      var p = L.featureGroup();
      return (
        c.forEach(function (t) {
          var e = [];
          U(t),
            t.forEach(function (t) {
              e.push(t);
            }),
            u.push(e);
        }),
        u.forEach(function (t, e) {
          if (1 < t.length) {
            var r = [],
              n = [],
              i = [],
              o = 0,
              a = function (a) {
                if (!Q(i, a) && i.length !== t.flat().length) {
                  var s = X(l, a),
                    h = 0 < s.length,
                    u = at.findDeepCoordIndex(t, a).parentPath;
                  if ((tt(n, o, a, i), h)) {
                    var c = W(s[0], a),
                      f = at.findDeepCoordIndex(t, c).parentPath;
                    if (!u || !f || u[0] === f[0]) return;
                    et(r, f[0]);
                    var p = b()(n, [o]).length;
                    a.equals(t[u][0]) &&
                      0 === e &&
                      u[0] !== f[0] &&
                      1 === p &&
                      (p = 2),
                      (function e(a, s, h, u) {
                        if (s && t[s]) {
                          var c = L.polyline(t[s]).getLatLngs(),
                            f = b()(n, [o, 0]);
                          ((a[0] === s[0] && 1 === u) ||
                            (1 !== u && a[0] !== s[0])) &&
                            c.reverse();
                          var p = at.findDeepCoordIndex(c, h).index,
                            d = c[(p + 0) % c.length];
                          if (a[0] !== s[0] || !f.equals(d)) {
                            tt(n, o, d, i);
                            for (var g = 1; g < c.length; g += 1) {
                              var m = c[(p + g) % c.length];
                              if (Q(i, m)) {
                                if (f.equals(m)) return;
                              } else {
                                tt(n, o, m, i);
                                var y = X(l, m);
                                if (0 < y.length) {
                                  var _ = W(y[0], m),
                                    v = at.findDeepCoordIndex(t, _).parentPath;
                                  return (
                                    et(r, s[0]),
                                    ((k = y[0].layer),
                                    (M = m),
                                    (w = _),
                                    (x = z(k.getLatLngs(), M)),
                                    (S = z(k.getLatLngs(), w)),
                                    (C = (E = x < S ? [x, S] : [S, x])[0]),
                                    (P = E[1]),
                                    k.getLatLngs().slice(C + 1, P)).forEach(
                                      function (t) {
                                        tt(n, o, t, i);
                                      }
                                    ),
                                    void e(a, v, _, u)
                                  );
                                }
                              }
                            }
                            var k, M, w, x, S, E, C, P;
                          }
                        }
                      })(u, f, c, p),
                      (o += 1);
                  }
                }
              };
            t[0].forEach(function (t) {
              a(t);
            });
            var s = [];
            i.length !== t.flat().length &&
              (function e(n) {
                if (Array.isArray(n[0]))
                  n.forEach(function (t) {
                    return e(t);
                  });
                else {
                  var o = !1;
                  n.forEach(function (e) {
                    if (!o && -1 === z(i, e)) {
                      var n = at.findDeepCoordIndex(t, e).parentPath[0];
                      -1 === s.indexOf(n) &&
                        -1 < r.indexOf(n) &&
                        (s.push(n), (o = !0));
                    }
                  });
                }
              })(t),
              s.forEach(function (e) {
                t[e].forEach(function (t) {
                  a(t);
                });
              }),
              r.sort().reverse(),
              r.forEach(function (e) {
                t.splice(e, 1);
              }),
              (t[0] = 1 === n.length ? n[0] : n);
          }
        }),
        u.forEach(function (t) {
          if (1 < t.length) {
            var e = [],
              r = L.polygon(t[0]).toGeoJSON(15);
            t.forEach(function (t, n) {
              var i = L.polygon(t).toGeoJSON(15);
              if (!M()(r, i)) {
                var o = !1;
                u.forEach(function (r) {
                  var a = L.polygon(r[0]).toGeoJSON(15);
                  !o && M()(a, i) && (r.push(t), (o = !0), e.push(n));
                });
              }
            }),
              e.sort().reverse(),
              e.forEach(function (e) {
                t.splice(e, 1);
              });
          }
        }),
        u.forEach(function (t) {
          Array.isArray(t[0][0]) &&
            (t[0].slice(1).forEach(function (t) {
              u.push(t);
            }),
            (t[0] = t[0].slice(0, 1)));
        }),
        u.forEach(function (t) {
          var e = L.polygon(t);
          Y(e.getLatLngs()), e.addTo(p);
        }),
        p
      );
    }
    var at = {
      calcMiddleLatLng: function (t, e, r) {
        var n = t.project(e),
          i = t.project(r);
        return t.unproject(n._add(i)._divideBy(2));
      },
      findLayers: function (t) {
        var e = [];
        return (
          t.eachLayer(function (t) {
            (t instanceof L.Polyline ||
              t instanceof L.Marker ||
              t instanceof L.Circle ||
              t instanceof L.CircleMarker) &&
              e.push(t);
          }),
          (e = (e = e.filter(function (t) {
            return !!t.pm;
          })).filter(function (t) {
            return !t._pmTempLayer;
          }))
        );
      },
      circleToPolygon: function (t) {
        for (
          var e =
              1 < arguments.length && void 0 !== arguments[1]
                ? arguments[1]
                : 60,
            r = it(t.getLatLng(), t.getRadius(), e, 0),
            n = [],
            i = 0;
          i < r.length;
          i += 1
        ) {
          var o = [r[i].lat, r[i].lng];
          n.push(o);
        }
        return L.polygon(n, t.options);
      },
      createGeodesicPolygon: it,
      getTranslation: rt,
      findDeepCoordIndex: function (t, e) {
        var r;
        t.some(
          (function t(n) {
            return function (i, o) {
              var a = n.concat(o);
              return i.lat && i.lat === e.lat && i.lng === e.lng
                ? ((r = a), !0)
                : Array.isArray(i) && i.some(t(a));
            };
          })([])
        );
        var n = {};
        return (
          r &&
            (n = {
              indexPath: r,
              index: r[r.length - 1],
              parentPath: r.slice(0, r.length - 1),
            }),
          n
        );
      },
      _getIndexFromSegment: function (t, e) {
        if (e && 2 === e.length) {
          var r = this.findDeepCoordIndex(t, e[0]),
            n = this.findDeepCoordIndex(t, e[1]),
            i = Math.max(r.index, n.index);
          return (
            (0 !== r.index && 0 !== n.index) || 1 === i || (i += 1),
            {
              indexA: r,
              indexB: n,
              newIndex: i,
              indexPath: r.indexPath,
              parentPath: r.parentPath,
            }
          );
        }
        return null;
      },
    };
    function st(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e &&
          (n = n.filter(function (e) {
            return Object.getOwnPropertyDescriptor(t, e).enumerable;
          })),
          r.push.apply(r, n);
      }
      return r;
    }
    function lt(t) {
      for (var e = 1; e < arguments.length; e++) {
        var r = null != arguments[e] ? arguments[e] : {};
        e % 2
          ? st(Object(r), !0).forEach(function (e) {
              ht(t, e, r[e]);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r))
          : st(Object(r)).forEach(function (e) {
              Object.defineProperty(
                t,
                e,
                Object.getOwnPropertyDescriptor(r, e)
              );
            });
      }
      return t;
    }
    function ht(t, e, r) {
      return (
        e in t
          ? Object.defineProperty(t, e, {
              value: r,
              enumerable: !0,
              configurable: !0,
              writable: !0,
            })
          : (t[e] = r),
        t
      );
    }
    var ut = at.findLayers,
      ct = {
        _globalEditMode: !1,
        globalEditEnabled: function () {
          return this.globalEditModeEnabled();
        },
        globalEditModeEnabled: function () {
          return this._globalEditMode;
        },
        setGlobalEditStatus: function (t) {
          (this._globalEditMode = t),
            this._fireEditModeEvent(this._globalEditMode);
        },
        enableGlobalEditMode: function (t) {
          var e = lt({ snappable: this._globalSnappingEnabled }, t);
          this.Toolbar.toggleButton("editMode", !0),
            ut(this.map).forEach(function (t) {
              t.pm.enable(e);
            }),
            this.throttledReInitEdit ||
              (this.throttledReInitEdit = L.Util.throttle(
                this.handleLayerAdditionInGlobalEditMode,
                100,
                this
              )),
            this.map.on("layeradd", this.throttledReInitEdit, this),
            this.setGlobalEditStatus(!0);
        },
        disableGlobalEditMode: function () {
          ut(this.map).forEach(function (t) {
            t.pm.disable();
          }),
            this.map.off("layeroff", this.throttledReInitEdit, this),
            this.Toolbar.toggleButton("editMode", !1),
            this.setGlobalEditStatus(!1);
        },
        toggleGlobalEditMode: function () {
          var t =
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : this.globalOptions;
          this.globalEditModeEnabled()
            ? this.disableGlobalEditMode()
            : this.enableGlobalEditMode(t);
        },
        handleLayerAdditionInGlobalEditMode: function (t) {
          var e = t.layer;
          !e.pm ||
            e._pmTempLayer ||
            !this.globalEditModeEnabled() ||
            e.pm.enable(
              lt(
                lt({}, this.globalOptions),
                {},
                { snappable: this._globalSnappingEnabled }
              )
            );
        },
        _fireEditModeEvent: function (t) {
          this.map.fire("pm:globaleditmodetoggled", {
            enabled: t,
            map: this.map,
          });
        },
      },
      ft = at.findLayers,
      pt = {
        globalDragModeEnabled: function () {
          return !!this._globalDragMode;
        },
        enableGlobalDragMode: function () {
          var t = ft(this.map);
          (this._globalDragMode = !0),
            t.forEach(function (t) {
              t.pm.enableLayerDrag();
            }),
            this.throttledReInitDrag ||
              (this.throttledReInitDrag = L.Util.throttle(
                this.reinitGlobalDragMode,
                100,
                this
              )),
            this.map.on("layeradd", this.throttledReInitDrag, this),
            this.Toolbar.toggleButton("dragMode", this._globalDragMode),
            this._fireDragModeEvent(!0);
        },
        disableGlobalDragMode: function () {
          var t = ft(this.map);
          (this._globalDragMode = !1),
            t.forEach(function (t) {
              t.pm.disableLayerDrag();
            }),
            this.map.off("layeradd", this.throttledReInitDrag, this),
            this.Toolbar.toggleButton("dragMode", this._globalDragMode),
            this._fireDragModeEvent(!1);
        },
        _fireDragModeEvent: function (t) {
          this.map.fire("pm:globaldragmodetoggled", {
            enabled: t,
            map: this.map,
          });
        },
        toggleGlobalDragMode: function () {
          this.globalDragModeEnabled()
            ? this.disableGlobalDragMode()
            : this.enableGlobalDragMode();
        },
        reinitGlobalDragMode: function (t) {
          var e = t.layer;
          !e.pm ||
            e._pmTempLayer ||
            !this.globalDragModeEnabled() ||
            (this.disableGlobalDragMode(), this.enableGlobalDragMode());
        },
      },
      dt = {
        disableGlobalRemovalMode: function () {
          var t = this;
          (this._globalRemovalMode = !1),
            this.map.eachLayer(function (e) {
              e.off("click", t.removeLayer, t);
            }),
            this.map.off("layeradd", this.throttledReInitRemoval, this),
            this.Toolbar.toggleButton("deleteLayer", this._globalRemovalMode),
            this._fireRemovalModeEvent(!1);
        },
        enableGlobalRemovalMode: function () {
          var t = this;
          (this._globalRemovalMode = !0),
            this.map.eachLayer(function (e) {
              (function (t) {
                return t.pm && !(t instanceof L.LayerGroup);
              })(e) && (e.pm.disable(), e.on("click", t.removeLayer, t));
            }),
            this.throttledReInitRemoval ||
              (this.throttledReInitRemoval = L.Util.throttle(
                this.reinitGlobalRemovalMode,
                100,
                this
              )),
            this.map.on("layeradd", this.throttledReInitRemoval, this),
            this.Toolbar.toggleButton("deleteLayer", this._globalRemovalMode),
            this._fireRemovalModeEvent(!0);
        },
        _fireRemovalModeEvent: function (t) {
          this.map.fire("pm:globalremovalmodetoggled", {
            enabled: t,
            map: this.map,
          });
        },
        toggleGlobalRemovalMode: function () {
          this.globalRemovalModeEnabled()
            ? this.disableGlobalRemovalMode()
            : this.enableGlobalRemovalMode();
        },
        globalRemovalEnabled: function () {
          return this.globalRemovalModeEnabled();
        },
        globalRemovalModeEnabled: function () {
          return !!this._globalRemovalMode;
        },
        removeLayer: function (t) {
          var e = t.target;
          e._pmTempLayer ||
            (e.pm && e.pm.dragging()) ||
            (e.remove(),
            e instanceof L.LayerGroup
              ? (e.fire("pm:remove", { layer: e, shape: void 0 }),
                this.map.fire("pm:remove", { layer: e, shape: void 0 }))
              : (e.fire("pm:remove", { layer: e, shape: e.pm.getShape() }),
                this.map.fire("pm:remove", {
                  layer: e,
                  shape: e.pm.getShape(),
                })));
        },
        reinitGlobalRemovalMode: function (t) {
          var e = t.layer;
          !e.pm ||
            e._pmTempLayer ||
            !this.globalRemovalModeEnabled() ||
            (this.disableGlobalRemovalMode(), this.enableGlobalRemovalMode());
        },
      };
    function gt(t, e) {
      (null == e || e > t.length) && (e = t.length);
      for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
      return n;
    }
    var mt = at.findLayers,
      yt = L.Class.extend({
        includes: [ct, pt, dt],
        initialize: function (t) {
          (this.map = t),
            (this.Draw = new L.PM.Draw(t)),
            (this.Toolbar = new L.PM.Toolbar(t)),
            (this._globalRemovalMode = !1),
            (this.globalOptions = {
              pinning: !1,
              snappable: !0,
              measurements: {
                measurement: !1,
                showTooltip: !0,
                showTooltipOnHover: !0,
                totalLength: !0,
                segmentLength: !0,
                area: !0,
                radius: !0,
                perimeter: !0,
                height: !0,
                width: !0,
                coordinates: !0,
                displayFormat: "metric",
              },
            }),
            this.map.on("zoomend", this._syncLayers, this);
        },
        setLang: function () {
          var t =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : "en",
            e = 1 < arguments.length ? arguments[1] : void 0,
            r =
              2 < arguments.length && void 0 !== arguments[2]
                ? arguments[2]
                : "en",
            n = L.PM.activeLang;
          e && (m[t] = o()(m[r], e)),
            (L.PM.activeLang = t),
            this.map.pm.Toolbar.reinit(),
            this.map.fire("pm:langchange", {
              oldLang: n,
              activeLang: t,
              fallback: r,
              translations: m[t],
            });
        },
        addControls: function (t) {
          this.Toolbar.addControls(t);
        },
        removeControls: function () {
          this.Toolbar.removeControls();
        },
        toggleControls: function () {
          this.Toolbar.toggleControls();
        },
        controlsVisible: function () {
          return this.Toolbar.isVisible;
        },
        enableDraw: function () {
          var t =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : "Polygon",
            e = 1 < arguments.length ? arguments[1] : void 0;
          "Poly" === t && (t = "Polygon"), this.Draw.enable(t, e);
        },
        disableDraw: function () {
          var t =
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : "Polygon";
          "Poly" === t && (t = "Polygon"), this.Draw.disable(t);
        },
        setPathOptions: function (t) {
          var e = this,
            r =
              (1 < arguments.length && void 0 !== arguments[1]
                ? arguments[1]
                : {}
              ).ignoreShapes || [];
          this.map.pm.Draw.shapes.forEach(function (n) {
            -1 === r.indexOf(n) && e.map.pm.Draw[n].setPathOptions(t);
          });
        },
        getGlobalOptions: function () {
          return this.globalOptions;
        },
        setGlobalOptions: function (t) {
          var e = this,
            r = o()(this.globalOptions, t);
          this.map.pm.Draw.shapes.forEach(function (t) {
            e.map.pm.Draw[t].setOptions(r);
          }),
            mt(this.map).forEach(function (t) {
              t.pm.setOptions(r);
            }),
            this.Toolbar.toggleButton("pinningOption", r.pinning, !1),
            this.Toolbar.toggleButton("snappingOption", r.snappable, !1),
            (this.globalOptions = r),
            this.applyGlobalOptions();
        },
        applyGlobalOptions: function () {
          mt(this.map).forEach(function (t) {
            t.pm.enabled() && t.pm.applyOptions();
          }),
            this.globalOptions.limitMarkersCountGlobally &&
              this.handleGlobalMarkerLimitation();
        },
        handleGlobalMarkerLimitation: function () {
          this.vertexMarkers = [];
        },
        _areMarkersClosestGlobally: function (t, e) {
          var r = this,
            n = this.globalOptions.limitMarkersToCount || -1,
            i = this.vertexMarkers;
          i.push.apply(
            i,
            (function (t) {
              return (
                (function (t) {
                  if (Array.isArray(t)) return gt(t);
                })(t) ||
                (function (t) {
                  if (
                    "undefined" != typeof Symbol &&
                    Symbol.iterator in Object(t)
                  )
                    return Array.from(t);
                })(t) ||
                (function (t, e) {
                  if (t) {
                    if ("string" == typeof t) return gt(t, e);
                    var r = Object.prototype.toString.call(t).slice(8, -1);
                    return (
                      "Object" === r &&
                        t.constructor &&
                        (r = t.constructor.name),
                      "Map" === r || "Set" === r
                        ? Array.from(t)
                        : "Arguments" === r ||
                          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
                        ? gt(t, e)
                        : void 0
                    );
                  }
                })(t) ||
                (function () {
                  throw new TypeError(
                    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                })()
              );
            })(t)
          );
          var o = i.filter(function (t, e, r) {
            return r.indexOf(t) === e;
          });
          o.sort(function (t, r) {
            return t._latlng.distanceTo(e) - r._latlng.distanceTo(e);
          });
          var a = o.filter(function (t, e) {
            return !(-1 < n) || e < n;
          });
          return (
            o
              .filter(function (t) {
                return !a.includes(t);
              })
              .map(function (t) {
                return r.map.removeLayer(t);
              }),
            (this.vertexMarkers = a),
            t.filter(function (t) {
              return a.includes(t);
            })
          );
        },
        globalDrawModeEnabled: function () {
          return !!this.Draw.getActiveShape();
        },
        globalCutModeEnabled: function () {
          return !!this.Draw.Cut.enabled();
        },
        enableGlobalCutMode: function (t) {
          return this.Draw.Cut.enable(t);
        },
        toggleGlobalCutMode: function (t) {
          return this.Draw.Cut.toggle(t);
        },
        disableGlobalCutMode: function () {
          return this.Draw.Cut.disable();
        },
        getGeomanLayers: function () {
          return mt(this.map);
        },
        getGeomanDrawLayers: function () {
          return mt(this.map).filter(function (t) {
            return !0 === t._drawnByGeoman;
          });
        },
        enableGlobalSplitMode: function (t) {
          return this.Draw.Split.enable(t);
        },
        toggleGlobalSplitMode: function (t) {
          return this.Draw.Split.toggle(t);
        },
        disableGlobalSplitMode: function () {
          return this.Draw.Split.disable();
        },
        _syncLayers: function () {
          mt(this.map)
            .filter(function (t) {
              return t instanceof L.CircleMarker && !(t instanceof L.Circle);
            })
            .forEach(function (t) {
              t.pm.addMeasurementTooltipToLayer(t);
            });
        },
      }),
      _t = L.Control.extend({
        options: { position: "topleft" },
        initialize: function (t) {
          this._button = Object.assign({}, this.options, t);
        },
        onAdd: function (t) {
          return (
            (this._map = t),
            this._map.pm.Toolbar.options.oneBlock
              ? (this._container = this._map.pm.Toolbar._createContainer(
                  this.options.position
                ))
              : "edit" === this._button.tool
              ? (this._container = this._map.pm.Toolbar.editContainer)
              : "options" === this._button.tool
              ? (this._container = this._map.pm.Toolbar.optionsContainer)
              : "custom" === this._button.tool
              ? (this._container = this._map.pm.Toolbar.customContainer)
              : (this._container = this._map.pm.Toolbar.drawContainer),
            (this.buttonsDomNode = this._makeButton(this._button)),
            this._container.appendChild(this.buttonsDomNode),
            this._container
          );
        },
        onRemove: function () {
          return this.buttonsDomNode.remove(), this._container;
        },
        getText: function () {
          return this._button.text;
        },
        getIconUrl: function () {
          return this._button.iconUrl;
        },
        destroy: function () {
          (this._button = {}), this._update();
        },
        toggle: function (t) {
          return (
            (this._button.toggleStatus =
              "boolean" == typeof t ? t : !this._button.toggleStatus),
            this._applyStyleClasses(),
            this._button.toggleStatus
          );
        },
        toggled: function () {
          return this._button.toggleStatus;
        },
        onCreate: function () {
          this.toggle(!1);
        },
        _triggerClick: function (t) {
          this._button.onClick(t, { button: this, event: t }),
            this._clicked(t),
            this._button.afterClick(t, { button: this, event: t });
        },
        _makeButton: function (t) {
          var e = this,
            r = -1 < this.options.position.indexOf("right") ? "pos-right" : "",
            n = L.DomUtil.create("div", "button-container", this._container),
            i = L.DomUtil.create("a", "leaflet-buttons-control-button", n),
            o = L.DomUtil.create(
              "div",
              "leaflet-pm-actions-container ".concat(r),
              n
            ),
            a = t.actions,
            s = {
              cancel: {
                text: rt("actions.cancel"),
                onClick: function () {
                  this._triggerClick();
                },
              },
              finishMode: {
                text: rt("actions.finish"),
                onClick: function () {
                  this._triggerClick();
                },
              },
              removeLastVertex: {
                text: rt("actions.removeLastVertex"),
                onClick: function () {
                  this._map.pm.Draw[t.jsClass]._removeLastVertex();
                },
              },
              finish: {
                text: rt("actions.finish"),
                onClick: function (e) {
                  this._map.pm.Draw[t.jsClass]._finishShape(e);
                },
              },
            };
          a.forEach(function (t) {
            var n;
            if (s[t]) n = s[t];
            else {
              if (!t.text) return;
              n = t;
            }
            var i = L.DomUtil.create(
              "a",
              "leaflet-pm-action ".concat(r, " action-").concat(t),
              o
            );
            (i.innerHTML = n.text),
              n.onClick && L.DomEvent.addListener(i, "click", n.onClick, e),
              L.DomEvent.disableClickPropagation(i);
          }),
            t.toggleStatus && L.DomUtil.addClass(n, "active");
          var l = L.DomUtil.create("div", "control-icon", i);
          return (
            t.title && l.setAttribute("title", t.title),
            t.iconUrl && l.setAttribute("src", t.iconUrl),
            t.className && L.DomUtil.addClass(l, t.className),
            L.DomEvent.addListener(i, "click", function () {
              e._button.disableOtherButtons &&
                e._map.pm.Toolbar.triggerClickOnToggledButtons(e);
            }),
            L.DomEvent.addListener(i, "click", this._triggerClick, this),
            L.DomEvent.disableClickPropagation(i),
            n
          );
        },
        _applyStyleClasses: function () {
          this._container &&
            (this._button.toggleStatus && !1 !== this._button.cssToggle
              ? (L.DomUtil.addClass(this.buttonsDomNode, "active"),
                L.DomUtil.addClass(this._container, "activeChild"))
              : (L.DomUtil.removeClass(this.buttonsDomNode, "active"),
                L.DomUtil.removeClass(this._container, "activeChild")));
        },
        _clicked: function () {
          this._button.doToggle && this.toggle();
        },
      });
    function vt(t) {
      return (vt =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t &&
                "function" == typeof Symbol &&
                t.constructor === Symbol &&
                t !== Symbol.prototype
                ? "symbol"
                : typeof t;
            })(t);
    }
    L.Control.PMButton = _t;
    var bt = L.Class.extend({
        options: {
          drawMarker: !0,
          drawRectangle: !0,
          drawPolyline: !0,
          drawPolygon: !0,
          drawCircle: !0,
          drawCircleMarker: !0,
          editMode: !0,
          dragMode: !0,
          cutPolygon: !0,
          splitMode: !0,
          removalMode: !0,
          pinningOption: !0,
          snappingOption: !0,
          drawControls: !0,
          editControls: !0,
          optionsControls: !0,
          customControls: !0,
          oneBlock: !1,
          position: "topleft",
          positions: { draw: "", edit: "", options: "", custom: "" },
        },
        customButtons: [],
        initialize: function (t) {
          this.init(t);
        },
        reinit: function () {
          var t = this.isVisible;
          this.removeControls(), this._defineButtons(), t && this.addControls();
        },
        init: function (t) {
          (this.map = t),
            (this.buttons = {}),
            (this.isVisible = !1),
            (this.drawContainer = L.DomUtil.create(
              "div",
              "leaflet-pm-toolbar leaflet-pm-draw leaflet-bar leaflet-control"
            )),
            (this.editContainer = L.DomUtil.create(
              "div",
              "leaflet-pm-toolbar leaflet-pm-edit leaflet-bar leaflet-control"
            )),
            (this.optionsContainer = L.DomUtil.create(
              "div",
              "leaflet-pm-toolbar leaflet-pm-options leaflet-bar leaflet-control"
            )),
            (this.customContainer = L.DomUtil.create(
              "div",
              "leaflet-pm-toolbar leaflet-pm-custom leaflet-bar leaflet-control"
            )),
            this._defineButtons();
        },
        _createContainer: function (t) {
          var e = "".concat(t, "Container");
          return (
            this[e] ||
              (this[e] = L.DomUtil.create(
                "div",
                "leaflet-pm-toolbar leaflet-pm-".concat(
                  t,
                  " leaflet-bar leaflet-control"
                )
              )),
            this[e]
          );
        },
        getButtons: function () {
          return this.buttons;
        },
        addControls: function () {
          var t =
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : this.options;
          void 0 !== t.editPolygon && (t.editMode = t.editPolygon),
            void 0 !== t.deleteLayer && (t.removalMode = t.deleteLayer),
            L.Util.setOptions(this, t),
            this.applyIconStyle(),
            this._showHideButtons(),
            (this.isVisible = !0);
        },
        applyIconStyle: function () {
          var t = this.getButtons(),
            e = {
              geomanIcons: {
                drawMarker: "control-icon leaflet-pm-icon-marker",
                drawPolyline: "control-icon leaflet-pm-icon-polyline",
                drawRectangle: "control-icon leaflet-pm-icon-rectangle",
                drawPolygon: "control-icon leaflet-pm-icon-polygon",
                drawCircle: "control-icon leaflet-pm-icon-circle",
                drawCircleMarker: "control-icon leaflet-pm-icon-circle-marker",
                editMode: "control-icon leaflet-pm-icon-edit",
                dragMode: "control-icon leaflet-pm-icon-drag",
                cutPolygon: "control-icon leaflet-pm-icon-cut",
                splitMode: "control-icon leaflet-pm-icon-split",
                removalMode: "control-icon leaflet-pm-icon-delete",
              },
            };
          for (var r in t) {
            var n = t[r];
            L.Util.setOptions(n, { className: e.geomanIcons[r] });
          }
        },
        removeControls: function () {
          var t = this.getButtons();
          for (var e in t) t[e].remove();
          this.isVisible = !1;
        },
        toggleControls: function () {
          var t =
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : this.options;
          this.isVisible ? this.removeControls() : this.addControls(t);
        },
        _addButton: function (t, e) {
          return (
            (this.buttons[t] = e),
            (this.options[t] = this.options[t] || !1),
            this.buttons[t]
          );
        },
        triggerClickOnToggledButtons: function (t) {
          var e = ["pinningOption", "snappingOption"];
          for (var r in this.buttons)
            !e.includes(r) &&
              this.buttons[r] !== t &&
              this.buttons[r].toggled() &&
              this.buttons[r]._triggerClick();
        },
        toggleButton: function (t, e) {
          return (
            "editPolygon" === t && (t = "editMode"),
            "deleteLayer" === t && (t = "removalMode"),
            (!(2 < arguments.length && void 0 !== arguments[2]) ||
              arguments[2]) &&
              this.triggerClickOnToggledButtons(this.buttons[t]),
            !!this.buttons[t] && this.buttons[t].toggle(e)
          );
        },
        _defineButtons: function () {
          var t = this,
            e = {
              className: "control-icon leaflet-pm-icon-marker",
              title: rt("buttonTitles.drawMarkerButton"),
              jsClass: "Marker",
              onClick: function () {},
              afterClick: function (e, r) {
                t.map.pm.Draw[r.button._button.jsClass].toggle();
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              actions: ["cancel"],
            },
            r = {
              title: rt("buttonTitles.drawPolyButton"),
              className: "control-icon leaflet-pm-icon-polygon",
              jsClass: "Polygon",
              onClick: function () {},
              afterClick: function (e, r) {
                t.map.pm.Draw[r.button._button.jsClass].toggle();
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              actions: ["finish", "removeLastVertex", "cancel"],
            },
            n = {
              className: "control-icon leaflet-pm-icon-polyline",
              title: rt("buttonTitles.drawLineButton"),
              jsClass: "Line",
              onClick: function () {},
              afterClick: function (e, r) {
                t.map.pm.Draw[r.button._button.jsClass].toggle();
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              actions: ["finish", "removeLastVertex", "cancel"],
            },
            i = {
              title: rt("buttonTitles.drawCircleButton"),
              className: "control-icon leaflet-pm-icon-circle",
              jsClass: "Circle",
              onClick: function () {},
              afterClick: function (e, r) {
                t.map.pm.Draw[r.button._button.jsClass].toggle();
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              actions: ["cancel"],
            },
            o = {
              title: rt("buttonTitles.drawCircleMarkerButton"),
              className: "control-icon leaflet-pm-icon-circle-marker",
              jsClass: "CircleMarker",
              onClick: function () {},
              afterClick: function (e, r) {
                t.map.pm.Draw[r.button._button.jsClass].toggle();
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              actions: ["cancel"],
            },
            a = {
              title: rt("buttonTitles.drawRectButton"),
              className: "control-icon leaflet-pm-icon-rectangle",
              jsClass: "Rectangle",
              onClick: function () {},
              afterClick: function (e, r) {
                t.map.pm.Draw[r.button._button.jsClass].toggle();
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              actions: ["cancel"],
            },
            s = {
              title: rt("buttonTitles.editButton"),
              className: "control-icon leaflet-pm-icon-edit",
              onClick: function () {},
              afterClick: function () {
                t.map.pm.toggleGlobalEditMode();
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              tool: "edit",
              actions: ["finishMode"],
            },
            l = {
              title: rt("buttonTitles.dragButton"),
              className: "control-icon leaflet-pm-icon-drag",
              onClick: function () {},
              afterClick: function () {
                t.map.pm.toggleGlobalDragMode();
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              tool: "edit",
              actions: ["finishMode"],
            },
            h = {
              title: rt("buttonTitles.cutButton"),
              className: "control-icon leaflet-pm-icon-cut",
              jsClass: "Cut",
              onClick: function () {},
              afterClick: function (e, r) {
                t.map.pm.Draw[r.button._button.jsClass].toggle({
                  snappable: !0,
                  cursorMarker: !0,
                  allowSelfIntersection: !1,
                });
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              tool: "edit",
              actions: ["finish", "removeLastVertex", "cancel"],
            },
            u = {
              title: rt("buttonTitles.deleteButton"),
              className: "control-icon leaflet-pm-icon-delete",
              onClick: function () {},
              afterClick: function () {
                t.map.pm.toggleGlobalRemovalMode();
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              tool: "edit",
              actions: ["finishMode"],
            };
          this._addButton("drawMarker", new L.Control.PMButton(e)),
            this._addButton("drawPolyline", new L.Control.PMButton(n)),
            this._addButton("drawRectangle", new L.Control.PMButton(a)),
            this._addButton("drawPolygon", new L.Control.PMButton(r)),
            this._addButton("drawCircle", new L.Control.PMButton(i)),
            this._addButton("drawCircleMarker", new L.Control.PMButton(o)),
            this._addButton("editMode", new L.Control.PMButton(s)),
            this._addButton("dragMode", new L.Control.PMButton(l)),
            this._addButton("cutPolygon", new L.Control.PMButton(h)),
            this._addButton("removalMode", new L.Control.PMButton(u));
          var c = {
              title: rt("buttonTitles.pinningButton"),
              className: "control-icon leaflet-pm-icon-pinning",
              onClick: function () {},
              afterClick: function () {
                var e = t.map.pm.getGlobalOptions().pinning;
                t.map.pm.setGlobalOptions({ pinning: !e });
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !1,
              position: this.options.position,
              tool: "options",
              actions: [],
            },
            f = {
              title: rt("buttonTitles.snappingButton"),
              className: "control-icon leaflet-pm-icon-snapping",
              onClick: function () {},
              afterClick: function () {
                var e = t.map.pm.getGlobalOptions().snappable;
                t.map.pm.setGlobalOptions({ snappable: !e });
              },
              doToggle: !0,
              toggleStatus: !0,
              disableOtherButtons: !1,
              position: this.options.position,
              tool: "options",
              actions: [],
            },
            p = {
              name: "splitMode",
              title: rt("buttonTitles.splitButton"),
              className: "control-icon leaflet-pm-icon-split",
              jsClass: "Split",
              onClick: function () {},
              afterClick: function (e, r) {
                t.map.pm.Draw[r.button._button.jsClass].toggle({
                  snappable: !0,
                  cursorMarker: !0,
                  allowSelfIntersection: !1,
                });
              },
              doToggle: !0,
              toggleStatus: !1,
              disableOtherButtons: !0,
              position: this.options.position,
              tool: "edit",
              actions: ["finish", "removeLastVertex", "cancel"],
            };
          this._addButton("splitMode", new L.Control.PMButton(p)),
            this._addButton("pinningOption", new L.Control.PMButton(c)),
            this._addButton("snappingOption", new L.Control.PMButton(f));
        },
        _showHideButtons: function () {
          this.removeControls();
          var t = this.getButtons(),
            e = [];
          for (var r in (!1 === this.options.drawControls &&
            (e = e.concat(
              Object.keys(t).filter(function (e) {
                return !t[e]._button.tool;
              })
            )),
          !1 === this.options.editControls &&
            (e = e.concat(
              Object.keys(t).filter(function (e) {
                return "edit" === t[e]._button.tool;
              })
            )),
          !1 === this.options.optionsControls &&
            (e = e.concat(
              Object.keys(t).filter(function (e) {
                return "options" === t[e]._button.tool;
              })
            )),
          !1 === this.options.customControls &&
            (e = e.concat(
              Object.keys(t).filter(function (e) {
                return "custom" === t[e]._button.tool;
              })
            )),
          t))
            if (this.options[r] && -1 === e.indexOf(r)) {
              var n = t[r]._button.tool;
              (n = n || "draw"),
                t[r].setPosition(this._getBtnPosition(n)),
                t[r].addTo(this.map);
            }
        },
        _getBtnPosition: function (t) {
          return this.options.positions && this.options.positions[t]
            ? this.options.positions[t]
            : this.options.position;
        },
        setBlockPosition: function (t, e) {
          (this.options.positions[t] = e),
            this._showHideButtons(),
            this.changeControlOrder();
        },
        getBlockPositions: function () {
          return this.options.positions;
        },
        copyDrawControl: function (t, e) {
          if (!e) throw new TypeError("Button has no name");
          "object" !== vt(e) && (e = { name: e });
          var r = {
              Marker: "drawMarker",
              Circle: "drawCircle",
              Polygon: "drawPolygon",
              Rectangle: "drawRectangle",
              Polyline: "drawPolyline",
              Line: "drawPolyline",
              CircleMarker: "drawCircleMarker",
              Edit: "editMode",
              Drag: "dragMode",
              Cut: "cutPolygon",
              Removal: "removalMode",
              Snap: "snappingOption",
              Pin: "pinningOption",
              Split: "splitMode",
            },
            n = r[t] ? r[t] : t;
          if (!e.name) throw new TypeError("Button has no name");
          if (this.buttons[e.name])
            throw new TypeError("Button with this name already exists");
          var i = this.map.pm.Draw.createNewDrawInstance(e.name, n),
            o = this.buttons[n]._button;
          return (
            (e = Object.assign({}, o, e)),
            { drawInstance: i, control: this.createCustomControl(e) }
          );
        },
        createCustomControl: function (t) {
          if (!t.name) throw new TypeError("Button has no name");
          if (this.buttons[t.name])
            throw new TypeError("Button with this name already exists");
          t.onClick || (t.onClick = function () {}),
            t.afterClick || (t.afterClick = function () {}),
            !1 !== t.toggle && (t.toggle = !0),
            t.block && (t.block = t.block.toLowerCase()),
            (t.block && "draw" !== t.block) || (t.block = ""),
            -1 === t.className.indexOf("control-icon") &&
              (t.className = "control-icon ".concat(t.className));
          var e = {
            tool: t.block,
            className: t.className,
            title: t.title || "",
            jsClass: t.name,
            onClick: t.onClick,
            afterClick: t.afterClick,
            doToggle: t.toggle,
            toggleStatus: !1,
            disableOtherButtons: !0,
            cssToggle: t.toggle,
            position: this.options.position,
            actions: t.actions || [],
          };
          !1 !== this.options[t.name] && (this.options[t.name] = !0);
          var r = this._addButton(t.name, new L.Control.PMButton(e));
          return this.changeControlOrder(), r;
        },
        changeControlOrder: function () {
          var t =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : [],
            e = {
              Marker: "drawMarker",
              Circle: "drawCircle",
              Polygon: "drawPolygon",
              Rectangle: "drawRectangle",
              Polyline: "drawPolyline",
              Line: "drawPolyline",
              CircleMarker: "drawCircleMarker",
              Edit: "editMode",
              Drag: "dragMode",
              Cut: "cutPolygon",
              Snap: "snappingOption",
              Pin: "pinningOption",
              Split: "splitMode",
            },
            r = [];
          t.forEach(function (t) {
            e[t] ? r.push(e[t]) : r.push(t);
          });
          var n = this.getButtons(),
            i = {};
          r.forEach(function (t) {
            n[t] && (i[t] = n[t]);
          }),
            Object.keys(n)
              .filter(function (t) {
                return !n[t]._button.tool;
              })
              .forEach(function (t) {
                -1 === r.indexOf(t) && (i[t] = n[t]);
              }),
            Object.keys(n)
              .filter(function (t) {
                return "edit" === n[t]._button.tool;
              })
              .forEach(function (t) {
                -1 === r.indexOf(t) && (i[t] = n[t]);
              }),
            Object.keys(n)
              .filter(function (t) {
                return "options" === n[t]._button.tool;
              })
              .forEach(function (t) {
                -1 === r.indexOf(t) && (i[t] = n[t]);
              }),
            Object.keys(n)
              .filter(function (t) {
                return "custom" === n[t]._button.tool;
              })
              .forEach(function (t) {
                -1 === r.indexOf(t) && (i[t] = n[t]);
              }),
            Object.keys(n).forEach(function (t) {
              -1 === r.indexOf(t) && (i[t] = n[t]);
            }),
            (this.map.pm.Toolbar.buttons = i),
            this._showHideButtons();
        },
        getControlOrder: function () {
          var t = this.getButtons(),
            e = [];
          for (var r in t) e.push(r);
          return e;
        },
        changeActionsOfControl: function (t, e) {
          var r = {
              Marker: "drawMarker",
              Circle: "drawCircle",
              Polygon: "drawPolygon",
              Rectangle: "drawRectangle",
              Polyline: "drawPolyline",
              Line: "drawPolyline",
              CircleMarker: "drawCircleMarker",
              Edit: "editMode",
              Drag: "dragMode",
              Cut: "cutPolygon",
              Removal: "removalMode",
              Snap: "snappingOption",
              Pin: "pinningOption",
              Split: "splitMode",
            },
            n = r[t] ? r[t] : t;
          if (!n) throw new TypeError("No name passed");
          if (!e) throw new TypeError("No actions passed");
          if (!this.buttons[n])
            throw new TypeError("Button with this name not exists");
          (this.buttons[n]._button.actions = e), this.changeControlOrder();
        },
      }),
      Lt = {
        _initSnappableMarkers: function () {
          (this.options.snapDistance = this.options.snapDistance || 30),
            this._assignEvents(this._markers),
            this._layer.off("pm:dragstart", this._unsnap, this),
            this._layer.on("pm:dragstart", this._unsnap, this);
        },
        _disableSnapping: function () {
          this._layer.off("pm:dragstart", this._unsnap, this);
        },
        _assignEvents: function (t) {
          var e = this;
          t.forEach(function (t) {
            Array.isArray(t)
              ? e._assignEvents(t)
              : (t.off("drag", e._handleSnapping, e),
                t.on("drag", e._handleSnapping, e),
                t.off("dragend", e._cleanupSnapping, e),
                t.on("dragend", e._cleanupSnapping, e));
          });
        },
        _unsnap: function () {
          delete this._snapLatLng;
        },
        _cleanupSnapping: function (t) {
          t && (t.target._snapped = !1),
            delete this._snapList,
            this._map.off("pm:remove", this._handleSnapLayerRemoval, this),
            this.debugIndicatorLines &&
              this.debugIndicatorLines.forEach(function (t) {
                t.remove();
              });
        },
        _handleSnapLayerRemoval: function (t) {
          var e = t.layer,
            r = this._snapList.findIndex(function (t) {
              return t._leaflet_id === e._leaflet_id;
            });
          this._snapList.splice(r, 1);
        },
        _handleSnapping: function (t) {
          var e = this;
          function r() {
            return L.Util.throttle(this._createSnapList, 100, this);
          }
          if (t.originalEvent.altKey) return !1;
          if (
            (void 0 === this._snapList &&
              (this._createSnapList(),
              this._map.off("layeradd", r, this),
              this._map.on("layeradd", r, this)),
            this._snapList.length <= 0)
          )
            return !1;
          var n = t.target,
            i = this._calcClosestLayer(n.getLatLng(), this._snapList);
          if (0 === Object.keys(i).length) return !1;
          var o,
            a =
              i.layer instanceof L.Marker || i.layer instanceof L.CircleMarker;
          o = a ? i.latlng : this._checkPrioritiySnapping(i);
          var s = this.options.snapDistance,
            l = {
              marker: n,
              shape: this._shape,
              snapLatLng: o,
              segment: i.segment,
              layer: this._layer,
              workingLayer: this._layer,
              layerInteractedWith: i.layer,
              distance: i.distance,
            };
          if (
            (l.marker.fire("pm:snapdrag", l),
            this._layer.fire("pm:snapdrag", l),
            i.distance < s)
          ) {
            n.setLatLng(o), (n._snapped = !0), (n._snapInfo = l);
            var h = this._snapLatLng || {},
              u = o || {};
            (h.lat === u.lat && h.lng === u.lng) ||
              ((e._snapLatLng = o),
              n.fire("pm:snap", l),
              e._layer.fire("pm:snap", l));
          } else
            this._snapLatLng &&
              (this._unsnap(l),
              (n._snapped = !1),
              (n._snapInfo = void 0),
              l.marker.fire("pm:unsnap", l),
              this._layer.fire("pm:unsnap", l));
          return !0;
        },
        _checkPrioritiySnapping: function (t) {
          var e,
            r = this._map,
            n = t.segment[0],
            i = t.segment[1],
            o = t.latlng,
            a = this._getDistance(r, n, o),
            s = this._getDistance(r, i, o),
            l = a < s ? n : i,
            h = a < s ? a : s;
          if (this.options.snapMiddle) {
            var u = at.calcMiddleLatLng(r, n, i),
              c = this._getDistance(r, u, o);
            c < a && c < s && ((l = u), (h = c));
          }
          return (
            (e = h < this.options.snapDistance ? l : o), Object.assign({}, e)
          );
        },
        _createSnapList: function () {
          var t = this,
            e = [],
            r = [],
            n = this._map;
          n.off("pm:remove", this._handleSnapLayerRemoval, this),
            n.on("pm:remove", this._handleSnapLayerRemoval, this),
            n.eachLayer(function (t) {
              if (
                (t instanceof L.Polyline ||
                  t instanceof L.Marker ||
                  t instanceof L.CircleMarker) &&
                !0 !== t.options.snapIgnore
              ) {
                (t instanceof L.Circle || t instanceof L.CircleMarker) &&
                  t.pm._hiddenPolyCircle &&
                  e.push(t.pm._hiddenPolyCircle),
                  e.push(t);
                var n = L.polyline([], { color: "red", pmIgnore: !0 });
                (n._pmTempLayer = !0),
                  r.push(n),
                  (t instanceof L.Circle || t instanceof L.CircleMarker) &&
                    r.push(n);
              }
            }),
            (e = (e = (e = e.filter(function (e) {
              return t._layer !== e;
            })).filter(function (t) {
              return t._latlng || (t._latlngs && 0 < t._latlngs.length);
            })).filter(function (t) {
              return !t._pmTempLayer;
            })),
            this._otherSnapLayers
              ? (this._snapList = e.concat(this._otherSnapLayers))
              : (this._snapList = e),
            (this.debugIndicatorLines = r);
        },
        _calcClosestLayer: function (t, e) {
          var r = this,
            n = {};
          return (
            e.forEach(function (e, i) {
              if (!e._parentCopy || e._parentCopy !== r._layer) {
                var o = r._calcLayerDistances(t, e);
                if (r.debugIndicatorLines) {
                  if (!r.debugIndicatorLines[i]) {
                    var a = L.polyline([], { color: "red", pmIgnore: !0 });
                    (a._pmTempLayer = !0), (r.debugIndicatorLines[i] = a);
                  }
                  r.debugIndicatorLines[i].setLatLngs([t, o.latlng]);
                }
                (void 0 === n.distance || o.distance < n.distance) &&
                  ((n = o).layer = e);
              }
            }),
            n
          );
        },
        _calcLayerDistances: function (t, e) {
          var r,
            n,
            i,
            o = this,
            a = this._map,
            s = e instanceof L.Marker || e instanceof L.CircleMarker,
            l = e instanceof L.Polygon,
            h = t;
          if (((r = s ? e.getLatLng() : e.getLatLngs()), s))
            return {
              latlng: Object.assign({}, r),
              distance: this._getDistance(a, r, h),
            };
          !(function t(e) {
            e.forEach(function (r, s) {
              if (Array.isArray(r)) t(r);
              else {
                var u,
                  c = r;
                u = l
                  ? s + 1 === e.length
                    ? 0
                    : s + 1
                  : s + 1 === e.length
                  ? void 0
                  : s + 1;
                var f = e[u];
                if (f) {
                  var p = o._getDistanceToSegment(a, h, c, f);
                  (void 0 === i || p < i) && ((i = p), (n = [c, f]));
                }
              }
            });
          })(r);
          var u = this._getClosestPointOnSegment(a, t, n[0], n[1]);
          return { latlng: Object.assign({}, u), segment: n, distance: i };
        },
        _getClosestPointOnSegment: function (t, e, r, n) {
          var i = t.getMaxZoom();
          i === 1 / 0 && (i = t.getZoom());
          var o = t.project(e, i),
            a = t.project(r, i),
            s = t.project(n, i),
            l = L.LineUtil.closestPointOnSegment(o, a, s);
          return t.unproject(l, i);
        },
        _getDistanceToSegment: function (t, e, r, n) {
          var i = t.latLngToContainerPoint(e),
            o = t.latLngToContainerPoint(r),
            a = t.latLngToContainerPoint(n);
          return L.LineUtil.pointToSegmentDistance(i, o, a);
        },
        _getDistance: function (t, e, r) {
          return t
            .latLngToContainerPoint(e)
            .distanceTo(t.latLngToContainerPoint(r));
        },
      },
      kt = r(68),
      Mt = r.n(kt),
      wt = {
        defaultOptions: {
          units: {
            metric: {
              distance: [
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round(100 * t * 100) / 100;
                  },
                  until: 1,
                },
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round(100 * t) / 100;
                  },
                  until: 1e3,
                },
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round((t / 1e3) * 100) / 100;
                  },
                },
              ],
              area: [
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round(1e4 * t * 100) / 100;
                  },
                  until: 1,
                },
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round(100 * t) / 100;
                  },
                  until: 1e4,
                },
                {
                  unit: "",
                  calculation: function (t) {
                    return Math.round((t / 1e4) * 100) / 100;
                  },
                  until: 1e6,
                },
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round((t / 1e6) * 100) / 100;
                  },
                },
              ],
            },
            imperial: {
              distance: [
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round(39.37 * t * 100) / 100;
                  },
                  until: 0.3048,
                },
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round(3.281 * t * 100) / 100;
                  },
                  until: 0.9144,
                },
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round(1.094 * t * 100) / 100;
                  },
                  until: 1609.344,
                },
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round((t / 1609) * 100) / 100;
                  },
                },
              ],
              area: [
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round(1550 * t * 100) / 100;
                  },
                  until: 0.092903,
                },
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round(10.764 * t * 100) / 100;
                  },
                  until: 0.836127,
                },
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round(1.196 * t * 100) / 100;
                  },
                  until: 2591994.816,
                },
                {
                  unit: "ft",
                  calculation: function (t) {
                    return Math.round((t / 259e4) * 100) / 100;
                  },
                },
              ],
            },
          },
        },
        initMeasurement: function () {
          var t = this.options.measurements;
          t &&
            t.measurement &&
            (t.showTooltip || t.showTooltipOnHover) &&
            L.Util.setOptions(this, this.defaultOptions);
        },
        calcMeasurement: function (t) {
          var e = this.options.measurements;
          if (e && e.measurement && (e.showTooltip || e.showTooltipOnHover)) {
            if (!t.pm) return {};
            this._map || (this._map = t._map);
            var r = {};
            return (
              "Rectangle" === t.pm._shape
                ? (r = this._measureRectangle(t))
                : "Polygon" === t.pm._shape
                ? (r = this._measurePolygon(t))
                : "Line" === t.pm._shape
                ? (r = this._measurePolyline(t))
                : "Circle" === t.pm._shape ||
                  (this.options.editable && "CircleMarker" === t.pm._shape)
                ? (r = this._measureCircle(t))
                : "Marker" === t.pm._shape || t.pm._shape,
              (t.pm.measurements = r),
              t.pm.measurements
            );
          }
          return {};
        },
        showMeasurementTooltip: function (t, e) {
          this.unbindTooltips(), t.unbindTooltip();
          var r = this.options.measurements;
          if (r && r.measurement && (r.showTooltip || r.showTooltipOnHover)) {
            var n = {};
            r.totalLength &&
              (n.totalLength = this._createInfoField(
                rt("measurements.totalLength"),
                this._formatDistance(t.pm.measurements.distance)
              )),
              r.segmentLength &&
                (n.segmentLength = this._createInfoField(
                  rt("measurements.segmentLength"),
                  this._formatDistance(t.pm.measurements.segmentdistance)
                )),
              r.area &&
                (n.area = this._createInfoField(
                  rt("measurements.area"),
                  this._formatArea(t.pm.measurements.area)
                )),
              r.radius &&
                (n.radius = this._createInfoField(
                  rt("measurements.radius"),
                  this._formatDistance(t.pm.measurements.radius)
                )),
              r.perimeter &&
                (n.perimeter = this._createInfoField(
                  rt("measurements.perimeter"),
                  this._formatDistance(t.pm.measurements.distance)
                )),
              r.height &&
                (n.height = this._createInfoField(
                  rt("measurements.height"),
                  this._formatDistance(t.pm.measurements.height)
                )),
              r.width &&
                (n.width = this._createInfoField(
                  rt("measurements.width"),
                  this._formatDistance(t.pm.measurements.width)
                )),
              r.coordinates &&
                (e &&
                  (n.coordinatesMarker = this._createInfoField(
                    rt("measurements.coordinatesMarker"),
                    this._formatLatLng(e.getLatLng())
                  )),
                t.getLatLng &&
                  (n.coordinates = this._createInfoField(
                    rt("measurements.coordinates"),
                    this._formatLatLng(t.getLatLng())
                  )));
            var i = [];
            switch (t.pm._shape) {
              case "Rectangle":
                (i = ["area", "perimeter", "height", "width"]),
                  e && i.push("coordinatesMarker");
                break;
              case "Polygon":
                (i = ["area", "perimeter"]),
                  e && (i.push("segmentLength"), i.push("coordinatesMarker"));
                break;
              case "Line":
                (i = ["totalLength"]),
                  e && (i.push("segmentLength"), i.push("coordinatesMarker"));
                break;
              case "Circle":
                (i = ["radius", "area", "perimeter"]),
                  e && i.push("coordinatesMarker");
                break;
              case "Marker":
                i = ["coordinates"];
                break;
              case "CircleMarker":
                this.options.editable
                  ? ((i = ["radius", "area", "perimeter"]),
                    e && i.push("coordinatesMarker"))
                  : (i = ["coordinates"]);
            }
            var o = "<p class='leaflet-geoman-measurements'>";
            return (
              i.forEach(function (t, e) {
                n[t] && ((o += n[t]), e < i.length && (o += "<br>"));
              }),
              "<p class='leaflet-geoman-measurements'></p>" == (o += "</p>") &&
                (o = ""),
              e && r.showTooltip && this.setTooltip(o, e),
              o
            );
          }
          return "";
        },
        addMeasurementTooltipToLayer: function (t) {
          this.unbindTooltips(), t.unbindTooltip();
          var e = this.options.measurements;
          if (e && e.measurement && e.showTooltipOnHover) {
            this.calcMeasurement(t);
            var r = this.showMeasurementTooltip(t);
            if (!r) return;
            t
              .bindTooltip("", {
                offset: L.point(0, 10),
                direction: "bottom",
                opacity: 0.8,
              })
              .openTooltip(),
              t.setTooltipContent(r);
          }
        },
        _createInfoField: function (t, e) {
          var r =
            2 < arguments.length && void 0 !== arguments[2] && arguments[2];
          if (e) {
            var n = "<strong>".concat(t, ": </strong>").concat(e);
            return r ? "".concat(n, "<br>") : n;
          }
          return "";
        },
        _measurePolygon: function (t) {
          var e,
            r,
            n,
            i = this,
            o = [];
          return (
            (function t(e) {
              if (Array.isArray(e) && 0 < e.length && Array.isArray(e[0]))
                e.forEach(function (e) {
                  t(e);
                });
              else {
                var r = e;
                if ((r.push(r[0]), 0 < r.length)) {
                  var n = i._measureDistance(r),
                    a = i._measureDistance(r.slice(-3, -1));
                  if (3 <= r.length) {
                    var s = i._measureArea(r);
                    o.push({ distance: n, segmentdistance: a, area: s });
                  }
                  o.push({ distance: n, segmentdistance: a });
                }
              }
            })(L.polygon(t.getLatLngs()).getLatLngs()),
            o.forEach(function (t, i) {
              0 === i
                ? (t.area && (e = t.area),
                  t.distance && (r = t.distance),
                  t.segmentdistance && (n = t.segmentdistance))
                : (t.area && e && (e -= t.area),
                  t.distance && r && (r += t.distance));
            }),
            e
              ? { distance: r, segmentdistance: n, area: e }
              : { segmentdistance: n, area: e }
          );
        },
        _measureRectangle: function (t) {
          var e = this._measurePolygon(t),
            r = e.distance,
            n = e.area,
            i = JSON.parse(JSON.stringify(t.pm._findCorners()));
          return {
            height: L.latLng(i[1]).distanceTo(L.latLng(i[2])),
            width: L.latLng(i[0]).distanceTo(L.latLng(i[1])),
            distance: r,
            area: n,
          };
        },
        _measurePolyline: function (t) {
          var e = JSON.parse(JSON.stringify(t.getLatLngs().flat()));
          return 0 < e.length
            ? {
                distance: this._measureDistance(e),
                segmentdistance: this._measureDistance(e.slice(-2)),
              }
            : {};
        },
        _measureCircle: function (t) {
          var e;
          return (
            (e =
              t instanceof L.Circle
                ? t.getRadius()
                : (function (t) {
                    var e = t.getLatLng(),
                      r = t._map.project(e),
                      n = L.point(r.x + t.getRadius(), r.y);
                    return t._map.unproject(n).distanceTo(e);
                  })(t)),
            {
              area: Math.pow(e, 2) * Math.PI,
              distance: 2 * e * Math.PI,
              radius: e,
            }
          );
        },
        _measureDistance: function (t) {
          var e = this,
            r = 0,
            n = null;
          return (
            t.forEach(function (t) {
              t && n && (r += e._map.distance(n, t)), (n = t);
            }),
            r
          );
        },
        _measureArea: function (t) {
          var e = L.polygon(t);
          return Mt()(e.toGeoJSON(15));
        },
        _formatDistance: function (t) {
          if (!t) return "";
          var e = this.options.units[this.options.measurements.displayFormat];
          if (0 < e.distance.length) {
            var r = e.distance,
              n = this._formatUnit(t, r);
            return "".concat(
              Number(n.calculation(t)).toLocaleString() + n.unit
            );
          }
          return t < 1e3
            ? "".concat(Number(Math.round(t)).toLocaleString(), "m")
            : "".concat(
                Number(Math.round(((t / 1e3) * 100) / 100)).toLocaleString(),
                "km"
              );
        },
        _formatArea: function (t) {
          if (!t) return "";
          var e = this.options.units[this.options.measurements.displayFormat];
          if (0 < e.area.length) {
            var r = e.area,
              n = this._formatUnit(t, r);
            return "".concat(
              Number(n.calculation(t)).toLocaleString() + n.unit
            );
          }
          return t < 1e3
            ? "".concat(
                Number(Math.round(100 * t) / 100).toLocaleString(),
                "m"
              )
            : "".concat(
                Number(Math.round((t / 1e6) * 100) / 100).toLocaleString(),
                "km"
              );
        },
        _formatUnit: function (t, e) {
          var r = null;
          if (
            (e
              .filter(function (t) {
                return t.until;
              })
              .forEach(function (e) {
                t < e.until && (null == r || r.until > e.until) && (r = e);
              }),
            !r)
          ) {
            var n = e.filter(function (t) {
              return !t.until;
            });
            r = 0 < n.length ? n[0] : e[0];
          }
          return (
            r.calculation ||
              (r.calculation = function (t) {
                return t;
              }),
            r
          );
        },
        setTooltip: function (t, e) {
          if (t) {
            e.getTooltip() ||
              (this.unbindTooltips(),
              e
                .bindTooltip("", {
                  permanent: !0,
                  offset: L.point(0, 10),
                  direction: "bottom",
                  opacity: 0.8,
                })
                .openTooltip(),
              (this._bindedTooltipMarkes = [e]));
            var r = e.getTooltip().getContent();
            (r =
              r
                .replace(/<p class='leaflet-geoman-measurements'>.*?<\/p>/, "")
                .trim() + t),
              e.setTooltipContent(r);
          }
        },
        unbindTooltips: function () {
          this._bindedTooltipMarkes &&
            this._bindedTooltipMarkes.forEach(function (t) {
              t.unbindTooltip();
            });
        },
        _formatLatLng: function (t) {
          return t
            ? "Lat: "
                .concat(t.lat.toFixed(6), ", Lon: ")
                .concat(t.lng.toFixed(6))
            : "";
        },
      },
      xt = L.Class.extend({
        includes: [Lt, wt],
        options: {
          snappable: !0,
          snapDistance: 20,
          tooltips: !0,
          cursorMarker: !0,
          finishOnDoubleClick: !1,
          finishOn: null,
          allowSelfIntersection: !0,
          templineStyle: {},
          hintlineStyle: { color: "#3388ff", dashArray: "5,5" },
          markerStyle: { draggable: !0 },
        },
        setOptions: function (t) {
          L.Util.setOptions(this, t);
        },
        initialize: function (t) {
          var e = this;
          (this._map = t),
            (this.shapes = [
              "Marker",
              "CircleMarker",
              "Line",
              "Polygon",
              "Rectangle",
              "Circle",
              "Cut",
              "Split",
            ]),
            this.shapes.forEach(function (t) {
              e[t] = new L.PM.Draw[t](e._map);
            });
        },
        setPathOptions: function (t) {
          this.options.pathOptions = t;
        },
        getShapes: function () {
          return this.shapes;
        },
        enable: function (t, e) {
          if (!t)
            throw new Error(
              "Error: Please pass a shape as a parameter. Possible shapes are: ".concat(
                this.getShapes().join(",")
              )
            );
          this.disable(), this[t].enable(e);
        },
        disable: function () {
          var t = this;
          this.shapes.forEach(function (e) {
            t[e].disable();
          });
        },
        addControls: function () {
          var t = this;
          this.shapes.forEach(function (e) {
            t[e].addButton();
          });
        },
        getActiveShape: function () {
          var t,
            e = this;
          return (
            this.shapes.forEach(function (r) {
              e[r]._enabled && (t = r);
            }),
            t
          );
        },
        _setGlobalDrawMode: function () {
          "Cut" === this._shape
            ? this._map.fire("pm:globalcutmodetoggled", {
                enabled: !!this._enabled,
                map: this._map,
              })
            : "Split" === this._shape
            ? this._map.fire("pm:globalsplitmodetoggled", {
                enabled: !!this._enabled,
                map: this._map,
              })
            : this._map.fire("pm:globaldrawmodetoggled", {
                enabled: this._enabled,
                shape: this._shape,
                map: this._map,
              });
        },
        createNewDrawInstance: function (t, e) {
          var r = this._getShapeFromBtnName(e);
          if (this[t]) throw new TypeError("Draw Type already exists");
          if (!L.PM.Draw[r])
            throw new TypeError("There is no class L.PM.Draw.".concat(r));
          return (
            (this[t] = new L.PM.Draw[r](this._map)),
            (this[t].toolbarButtonName = t),
            (this[t]._shape = t),
            this.shapes.push(t),
            this[e] && this[t].setOptions(this[e].options),
            this[t].setOptions(this[t].options),
            this[t]
          );
        },
        _getShapeFromBtnName: function (t) {
          var e = {
            drawMarker: "Marker",
            drawCircle: "Circle",
            drawPolygon: "Polygon",
            drawPolyline: "Line",
            drawRectangle: "Rectangle",
            drawCircleMarker: "CircleMarker",
            editMode: "Edit",
            dragMode: "Drag",
            cutPolygon: "Cut",
            removalMode: "Removal",
            snappingOption: "Snap",
            pinningOption: "Pin",
            splitMode: "Split",
          };
          return e[t] ? e[t] : this[t] ? this[t]._shape : t;
        },
        _addDrawnLayerProp: function (t) {
          t._drawnByGeoman = !0;
        },
        _setShapeForFinishLayer: function (t) {
          t.pm._shape = this._shape;
        },
      });
    xt.Marker = xt.extend({
      initialize: function (t) {
        (this._map = t),
          (this._shape = "Marker"),
          (this.toolbarButtonName = "drawMarker");
      },
      enable: function (t) {
        var e = this;
        L.Util.setOptions(this, t),
          this.initMeasurement(),
          (this._enabled = !0),
          this._map.on("click", this._createMarker, this),
          this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0),
          (this._hintMarker = L.marker([0, 0], this.options.markerStyle)),
          (this._hintMarker._pmTempLayer = !0),
          this._hintMarker.addTo(this._map),
          this.options.tooltips &&
            this._hintMarker
              .bindTooltip(rt("tooltips.placeMarker"), {
                permanent: !0,
                offset: L.point(0, 10),
                direction: "bottom",
                opacity: 0.8,
              })
              .openTooltip(),
          (this._layer = this._hintMarker),
          this._map.on("mousemove", this._syncHintMarker, this),
          this._map.fire("pm:drawstart", {
            shape: this._shape,
            workingLayer: this._layer,
          }),
          this._setGlobalDrawMode(),
          this._map.eachLayer(function (t) {
            e.isRelevantMarker(t) && t.pm.enable();
          });
      },
      disable: function () {
        var t = this;
        this._enabled &&
          ((this._enabled = !1),
          this._map.off("click", this._createMarker, this),
          this._hintMarker.remove(),
          this._map.off("mousemove", this._syncHintMarker, this),
          this._map.eachLayer(function (e) {
            t.isRelevantMarker(e) && e.pm.disable();
          }),
          this._map.fire("pm:drawend", { shape: this._shape }),
          this._setGlobalDrawMode(),
          this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1),
          this.options.snappable && this._cleanupSnapping());
      },
      isRelevantMarker: function (t) {
        return t instanceof L.Marker && t.pm && !t._pmTempLayer;
      },
      enabled: function () {
        return this._enabled;
      },
      toggle: function (t) {
        this.enabled() ? this.disable() : this.enable(t);
      },
      _createMarker: function (t) {
        if (t.latlng) {
          this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
          var e = this._hintMarker.getLatLng(),
            r = new L.Marker(e, this.options.markerStyle);
          this._setShapeForFinishLayer(r),
            this._addDrawnLayerProp(r),
            this.addMeasurementTooltipToLayer(r),
            r.addTo(this._map),
            r.pm.enable(),
            this._map.fire("pm:create", {
              shape: this._shape,
              marker: r,
              layer: r,
            }),
            this._cleanupSnapping();
        }
      },
      _syncHintMarker: function (t) {
        if ((this._hintMarker.setLatLng(t.latlng), this.options.snappable)) {
          var e = t;
          (e.target = this._hintMarker), this._handleSnapping(e);
        }
        this.calcMeasurement(this._hintMarker),
          this.showMeasurementTooltip(this._hintMarker, this._hintMarker);
      },
    });
    var St = r(9),
      Et = r.n(St);
    function Ct(t, e, r) {
      var n = t[e];
      (t[e] = t[r]), (t[r] = n);
    }
    function Pt(t, e) {
      return t < e ? -1 : e < t ? 1 : 0;
    }
    (xt.Line = xt.extend({
      initialize: function (t) {
        (this._map = t),
          (this._shape = "Line"),
          (this.toolbarButtonName = "drawPolyline"),
          (this._doesSelfIntersect = !1);
      },
      enable: function (t) {
        L.Util.setOptions(this, t),
          this.initMeasurement(),
          this.options.finishOnDoubleClick &&
            !this.options.finishOn &&
            (this.options.finishOn = "dblclick"),
          (this._enabled = !0),
          (this._layerGroup = new L.LayerGroup()),
          (this._layerGroup._pmTempLayer = !0),
          this._layerGroup.addTo(this._map),
          (this._layer = L.polyline([], this.options.templineStyle)),
          (this._layer._pmTempLayer = !0),
          this._layerGroup.addLayer(this._layer),
          (this._hintline = L.polyline([], this.options.hintlineStyle)),
          (this._hintline._pmTempLayer = !0),
          this._layerGroup.addLayer(this._hintline),
          (this._hintMarker = L.marker(this._map.getCenter(), {
            icon: L.divIcon({ className: "marker-icon cursor-marker" }),
          })),
          (this._hintMarker._pmTempLayer = !0),
          this._layerGroup.addLayer(this._hintMarker),
          this.options.cursorMarker &&
            L.DomUtil.addClass(this._hintMarker._icon, "visible"),
          this.options.tooltips &&
            this._hintMarker
              .bindTooltip(rt("tooltips.firstVertex"), {
                permanent: !0,
                offset: L.point(0, 10),
                direction: "bottom",
                opacity: 0.8,
              })
              .openTooltip(),
          (this._map._container.style.cursor = "crosshair"),
          this._map.on("click", this._createVertex, this),
          this.options.finishOn &&
            this._map.on(this.options.finishOn, this._finishShape, this),
          "dblclick" === this.options.finishOn &&
            ((this.tempMapDoubleClickZoomState = this._map.doubleClickZoom._enabled),
            this.tempMapDoubleClickZoomState &&
              this._map.doubleClickZoom.disable()),
          this._map.on("mousemove", this._syncHintMarker, this),
          this._hintMarker.on("move", this._syncHintLine, this),
          this._map.fire("pm:drawstart", {
            shape: this._shape,
            workingLayer: this._layer,
          }),
          this._setGlobalDrawMode(),
          this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0),
          (this._otherSnapLayers = []);
      },
      disable: function () {
        this._enabled &&
          ((this._enabled = !1),
          (this._map._container.style.cursor = ""),
          this._map.off("click", this._createVertex, this),
          this._map.off("mousemove", this._syncHintMarker, this),
          this.options.finishOn &&
            this._map.off(this.options.finishOn, this._finishShape, this),
          this.tempMapDoubleClickZoomState &&
            this._map.doubleClickZoom.enable(),
          this._map.removeLayer(this._layerGroup),
          this._map.fire("pm:drawend", { shape: this._shape }),
          this._setGlobalDrawMode(),
          this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1),
          this.options.snappable && this._cleanupSnapping());
      },
      enabled: function () {
        return this._enabled;
      },
      toggle: function (t) {
        this.enabled() ? this.disable() : this.enable(t);
      },
      hasSelfIntersection: function () {
        return 0 < Et()(this._layer.toGeoJSON(15)).features.length;
      },
      _syncHintLine: function () {
        var t = this._layer.getLatLngs();
        if (0 < t.length) {
          var e = t[t.length - 1];
          this._hintline.setLatLngs([e, this._hintMarker.getLatLng()]);
        }
      },
      _syncHintMarker: function (t) {
        if ((this._hintMarker.setLatLng(t.latlng), this.options.snappable)) {
          var e = t;
          (e.target = this._hintMarker), this._handleSnapping(e);
        }
        var r =
          "Line" === this._layer.pm._shape
            ? L.polyline(this._layer.getLatLngs())
            : L.polygon(this._layer.getLatLngs());
        r.addLatLng(this._hintMarker.getLatLng()),
          (this._layer.pm.measurements = this.calcMeasurement(r)),
          1 < r.getLatLngs().flat().length &&
            this.showMeasurementTooltip(this._layer, this._hintMarker),
          this.options.allowSelfIntersection ||
            this._handleSelfIntersection(!0, this._hintMarker.getLatLng());
      },
      _handleSelfIntersection: function (t, e) {
        var r = L.polyline(this._layer.getLatLngs());
        t && ((e = e || this._hintMarker.getLatLng()), r.addLatLng(e));
        var n = Et()(r.toGeoJSON(15));
        (this._doesSelfIntersect = 0 < n.features.length),
          this._doesSelfIntersect
            ? this._hintline.setStyle({ color: "red" })
            : this._hintline.isEmpty() ||
              this._hintline.setStyle(this.options.hintlineStyle);
      },
      _removeLastVertex: function () {
        var t = this._layer.getLatLngs(),
          e = t.pop();
        if (t.length < 1) this.disable();
        else {
          var r = this._layerGroup
            .getLayers()
            .filter(function (t) {
              return t instanceof L.Marker;
            })
            .filter(function (t) {
              return !L.DomUtil.hasClass(t._icon, "cursor-marker");
            })
            .find(function (t) {
              return t.getLatLng() === e;
            });
          this._layerGroup.removeLayer(r),
            this._layer.setLatLngs(t),
            this._layer._latlngInfo.pop(),
            this.calcMeasurement(this._layer),
            this.showMeasurementTooltip(this._layer, this._hintMarker),
            this._syncHintLine();
        }
      },
      _createVertex: function (t) {
        if (
          (this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng),
          this.options.allowSelfIntersection ||
            (this._handleSelfIntersection(!0, this._hintMarker.getLatLng()),
            !this._doesSelfIntersect))
        ) {
          var e = this._hintMarker.getLatLng(),
            r = this._layer.getLatLngs();
          if (e.equals(r[0]) || (0 < r.length && e.equals(r[r.length - 1])))
            this._finishShape(t);
          else {
            var n = 0 === r.length;
            (this._layer._latlngInfo = this._layer._latlngInfo || []),
              this._layer._latlngInfo.push({
                latlng: e,
                snapInfo: this._hintMarker._snapInfo,
              }),
              this._layer.addLatLng(e);
            var i = this._createMarker(e, n);
            this._hintline.setLatLngs([e, e]),
              this.calcMeasurement(this._layer),
              this.showMeasurementTooltip(this._layer, this._hintMarker),
              this._layer.fire("pm:vertexadded", {
                shape: this._shape,
                workingLayer: this._layer,
                marker: i,
                latlng: e,
              });
          }
        }
      },
      _finishShape: function () {
        if (
          this.options.allowSelfIntersection ||
          (this._handleSelfIntersection(!1), !this._doesSelfIntersect)
        ) {
          var t = this._layer.getLatLngs();
          if (!(t.length <= 1)) {
            var e = L.polyline(t, this.options.pathOptions).addTo(this._map);
            this._setShapeForFinishLayer(e),
              this._addDrawnLayerProp(e),
              this.addMeasurementTooltipToLayer(e),
              this.disable(),
              this._map.fire("pm:create", { shape: this._shape, layer: e }),
              this.options.snappable && this._cleanupSnapping();
          }
        }
      },
      _createMarker: function (t, e) {
        var r = new L.Marker(t, {
          draggable: !1,
          icon: L.divIcon({ className: "marker-icon" }),
        });
        return (
          (r._pmTempLayer = !0),
          this._layerGroup.addLayer(r),
          r.on("click", this._finishShape, this),
          e && this._hintMarker.setTooltipContent(rt("tooltips.continueLine")),
          2 === this._layer.getLatLngs().length &&
            this._hintMarker.setTooltipContent(rt("tooltips.finishLine")),
          r
        );
      },
    })),
      (xt.Polygon = xt.Line.extend({
        initialize: function (t) {
          (this._map = t),
            (this._shape = "Polygon"),
            (this.toolbarButtonName = "drawPolygon");
        },
        _finishShape: function (t) {
          if (
            this.options.allowSelfIntersection ||
            (this._handleSelfIntersection(!0, this._layer.getLatLngs()[0]),
            !this._doesSelfIntersect)
          ) {
            var e = this._layer.getLatLngs();
            if (!(e.length <= 2)) {
              var r = L.polygon(e, this.options.pathOptions).addTo(this._map);
              this._setShapeForFinishLayer(r),
                this._addDrawnLayerProp(r),
                this.addMeasurementTooltipToLayer(r),
                this.disable(),
                this._map.fire("pm:create", { shape: this._shape, layer: r }),
                this._cleanupSnapping(),
                this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1),
                delete this._tempSnapLayerIndex;
            }
          }
        },
        _createMarker: function (t, e) {
          this._layer.pm._shape = "Polygon";
          var r = new L.Marker(t, {
            draggable: !1,
            icon: L.divIcon({ className: "marker-icon" }),
          });
          return (
            (r._pmTempLayer = !0),
            this._layerGroup.addLayer(r),
            e
              ? (r.on("click", this._finishShape, this),
                (this._tempSnapLayerIndex = this._otherSnapLayers.push(r) - 1),
                this.options.snappable && this._cleanupSnapping())
              : r.on("click", function () {
                  return 1;
                }),
            e &&
              this._hintMarker.setTooltipContent(rt("tooltips.continueLine")),
            3 === this._layer.getLatLngs().length &&
              this._hintMarker.setTooltipContent(rt("tooltips.finishPoly")),
            r
          );
        },
      })),
      (xt.Rectangle = xt.extend({
        initialize: function (t) {
          (this._map = t),
            (this._shape = "Rectangle"),
            (this.toolbarButtonName = "drawRectangle");
        },
        enable: function (t) {
          if (
            (L.Util.setOptions(this, t),
            this.initMeasurement(),
            (this._enabled = !0),
            (this._layerGroup = new L.LayerGroup()),
            (this._layerGroup._pmTempLayer = !0),
            this._layerGroup.addTo(this._map),
            (this._layer = L.rectangle(
              [
                [0, 0],
                [0, 0],
              ],
              this.options.pathOptions
            )),
            (this._layer._pmTempLayer = !0),
            (this._startMarker = L.marker([0, 0], {
              icon: L.divIcon({ className: "marker-icon rect-start-marker" }),
              draggable: !1,
              zIndexOffset: 100,
              opacity: this.options.cursorMarker ? 1 : 0,
            })),
            (this._startMarker._pmTempLayer = !0),
            this._layerGroup.addLayer(this._startMarker),
            (this._hintMarker = L.marker([0, 0], {
              icon: L.divIcon({ className: "marker-icon cursor-marker" }),
            })),
            (this._hintMarker._pmTempLayer = !0),
            this._layerGroup.addLayer(this._hintMarker),
            this.options.tooltips &&
              this._hintMarker
                .bindTooltip(rt("tooltips.firstVertex"), {
                  permanent: !0,
                  offset: L.point(0, 10),
                  direction: "bottom",
                  opacity: 0.8,
                })
                .openTooltip(),
            this.options.cursorMarker)
          ) {
            L.DomUtil.addClass(this._hintMarker._icon, "visible"),
              (this._styleMarkers = []);
            for (var e = 0; e < 2; e += 1) {
              var r = L.marker([0, 0], {
                icon: L.divIcon({ className: "marker-icon rect-style-marker" }),
                draggable: !1,
                zIndexOffset: 100,
              });
              (r._pmTempLayer = !0),
                this._layerGroup.addLayer(r),
                this._styleMarkers.push(r);
            }
          }
          (this._map._container.style.cursor = "crosshair"),
            this._map.on("click", this._placeStartingMarkers, this),
            this._map.on("mousemove", this._syncHintMarker, this),
            this._map.fire("pm:drawstart", {
              shape: this._shape,
              workingLayer: this._layer,
            }),
            this._setGlobalDrawMode(),
            this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0),
            (this._otherSnapLayers = []);
        },
        disable: function () {
          this._enabled &&
            ((this._enabled = !1),
            (this._map._container.style.cursor = ""),
            this._map.off("click", this._finishShape, this),
            this._map.off("click", this._placeStartingMarkers, this),
            this._map.off("mousemove", this._syncHintMarker, this),
            this._map.removeLayer(this._layerGroup),
            this._map.fire("pm:drawend", { shape: this._shape }),
            this._setGlobalDrawMode(),
            this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1),
            this.options.snappable && this._cleanupSnapping());
        },
        enabled: function () {
          return this._enabled;
        },
        toggle: function (t) {
          this.enabled() ? this.disable() : this.enable(t);
        },
        _placeStartingMarkers: function (t) {
          this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
          var e = this._hintMarker.getLatLng();
          L.DomUtil.addClass(this._startMarker._icon, "visible"),
            this._startMarker.setLatLng(e),
            this.options.cursorMarker &&
              this._styleMarkers &&
              this._styleMarkers.forEach(function (t) {
                L.DomUtil.addClass(t._icon, "visible"), t.setLatLng(e);
              }),
            this._map.off("click", this._placeStartingMarkers, this),
            this._map.on("click", this._finishShape, this),
            this._hintMarker.setTooltipContent(rt("tooltips.finishRect")),
            this._setRectangleOrigin();
        },
        _setRectangleOrigin: function () {
          var t = this._startMarker.getLatLng();
          t &&
            (this._layerGroup.addLayer(this._layer),
            this._layer.setLatLngs([t, t]),
            this._hintMarker.on("move", this._syncRectangleSize, this));
        },
        _syncHintMarker: function (t) {
          if ((this._hintMarker.setLatLng(t.latlng), this.options.snappable)) {
            var e = t;
            (e.target = this._hintMarker), this._handleSnapping(e);
          }
        },
        _syncRectangleSize: function () {
          var t = this,
            e = this._startMarker.getLatLng(),
            r = this._hintMarker.getLatLng();
          if (
            (this._layer.setBounds([e, r]),
            this.options.cursorMarker && this._styleMarkers)
          ) {
            var n = this._findCorners(),
              i = [];
            n.forEach(function (e) {
              e.equals(t._startMarker.getLatLng()) ||
                e.equals(t._hintMarker.getLatLng()) ||
                i.push(e);
            }),
              i.forEach(function (e, r) {
                t._styleMarkers[r].setLatLng(e);
              });
          }
          this.calcMeasurement(this._layer),
            this.showMeasurementTooltip(this._layer, this._hintMarker);
        },
        _finishShape: function (t) {
          this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
          var e = this._hintMarker.getLatLng(),
            r = this._startMarker.getLatLng(),
            n = L.rectangle([r, e], this.options.pathOptions).addTo(this._map);
          this._setShapeForFinishLayer(n),
            this._addDrawnLayerProp(n),
            this.addMeasurementTooltipToLayer(n),
            this.disable(),
            this._map.fire("pm:create", { shape: this._shape, layer: n });
        },
        _findCorners: function () {
          var t = this._layer.getBounds();
          return [
            t.getNorthWest(),
            t.getNorthEast(),
            t.getSouthEast(),
            t.getSouthWest(),
          ];
        },
      })),
      (xt.Circle = xt.extend({
        initialize: function (t) {
          (this._map = t),
            (this._shape = "Circle"),
            (this.toolbarButtonName = "drawCircle");
        },
        enable: function (t) {
          L.Util.setOptions(this, t),
            (this.options.radius = 0),
            this.initMeasurement(),
            (this._enabled = !0),
            (this._layerGroup = new L.LayerGroup()),
            (this._layerGroup._pmTempLayer = !0),
            this._layerGroup.addTo(this._map),
            (this._layer = L.circle([0, 0], this.options.templineStyle)),
            (this._layer._pmTempLayer = !0),
            this._layerGroup.addLayer(this._layer),
            (this._centerMarker = L.marker([0, 0], {
              icon: L.divIcon({ className: "marker-icon" }),
              draggable: !1,
              zIndexOffset: 100,
            })),
            (this._centerMarker._pmTempLayer = !0),
            this._layerGroup.addLayer(this._centerMarker),
            (this._hintMarker = L.marker([0, 0], {
              icon: L.divIcon({ className: "marker-icon cursor-marker" }),
            })),
            (this._hintMarker._pmTempLayer = !0),
            this._layerGroup.addLayer(this._hintMarker),
            this.options.cursorMarker &&
              L.DomUtil.addClass(this._hintMarker._icon, "visible"),
            this.options.tooltips &&
              this._hintMarker
                .bindTooltip(rt("tooltips.startCircle"), {
                  permanent: !0,
                  offset: L.point(0, 10),
                  direction: "bottom",
                  opacity: 0.8,
                })
                .openTooltip(),
            (this._hintline = L.polyline([], this.options.hintlineStyle)),
            (this._hintline._pmTempLayer = !0),
            this._layerGroup.addLayer(this._hintline),
            (this._map._container.style.cursor = "crosshair"),
            this._map.on("click", this._placeCenterMarker, this),
            this._map.on("mousemove", this._syncHintMarker, this),
            this._map.fire("pm:drawstart", {
              shape: this._shape,
              workingLayer: this._layer,
            }),
            this._setGlobalDrawMode(),
            this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0),
            (this._otherSnapLayers = []);
        },
        disable: function () {
          this._enabled &&
            ((this._enabled = !1),
            (this._map._container.style.cursor = ""),
            this._map.off("click", this._finishShape, this),
            this._map.off("click", this._placeCenterMarker, this),
            this._map.off("mousemove", this._syncHintMarker, this),
            this._map.removeLayer(this._layerGroup),
            this._map.fire("pm:drawend", { shape: this._shape }),
            this._setGlobalDrawMode(),
            this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1),
            this.options.snappable && this._cleanupSnapping());
        },
        enabled: function () {
          return this._enabled;
        },
        toggle: function (t) {
          this.enabled() ? this.disable() : this.enable(t);
        },
        _syncHintLine: function () {
          var t = this._centerMarker.getLatLng();
          this._hintline.setLatLngs([t, this._hintMarker.getLatLng()]);
        },
        _syncCircleRadius: function () {
          var t = this._centerMarker.getLatLng(),
            e = this._hintMarker.getLatLng(),
            r = t.distanceTo(e);
          this._layer.setRadius(r),
            this.calcMeasurement(this._layer),
            this.showMeasurementTooltip(this._layer, this._hintMarker);
        },
        _syncHintMarker: function (t) {
          if ((this._hintMarker.setLatLng(t.latlng), this.options.snappable)) {
            var e = t;
            (e.target = this._hintMarker), this._handleSnapping(e);
          }
        },
        _placeCenterMarker: function (t) {
          this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
          var e = this._hintMarker.getLatLng();
          this._centerMarker.setLatLng(e),
            this._map.off("click", this._placeCenterMarker, this),
            this._map.on("click", this._finishShape, this),
            this._placeCircleCenter();
        },
        _placeCircleCenter: function () {
          var t = this._centerMarker.getLatLng();
          t &&
            (this._layer.setLatLng(t),
            this._hintMarker.on("move", this._syncHintLine, this),
            this._hintMarker.on("move", this._syncCircleRadius, this),
            this._hintMarker.setTooltipContent(rt("tooltips.finishCircle")),
            this._layer.fire("pm:centerplaced", {
              workingLayer: this._layer,
              latlng: t,
              shape: this._shape,
            }));
        },
        _finishShape: function (t) {
          this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
          var e = this._centerMarker.getLatLng(),
            r = this._hintMarker.getLatLng(),
            n = e.distanceTo(r),
            i = Object.assign({}, this.options.pathOptions, { radius: n }),
            o = L.circle(e, i).addTo(this._map);
          this._setShapeForFinishLayer(o),
            this._addDrawnLayerProp(o),
            this.addMeasurementTooltipToLayer(o),
            o.pm._updateHiddenPolyCircle(),
            this.disable(),
            this._map.fire("pm:create", { shape: this._shape, layer: o });
        },
        _createMarker: function (t) {
          var e = new L.Marker(t, {
            draggable: !1,
            icon: L.divIcon({ className: "marker-icon" }),
          });
          return (e._pmTempLayer = !0), this._layerGroup.addLayer(e), e;
        },
      })),
      (xt.CircleMarker = xt.Marker.extend({
        initialize: function (t) {
          (this._map = t),
            (this._shape = "CircleMarker"),
            (this.toolbarButtonName = "drawCircleMarker");
        },
        enable: function (t) {
          var e = this;
          L.Util.setOptions(this, t),
            this.initMeasurement(),
            (this._enabled = !0),
            this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0),
            this.options.editable
              ? ((this._layerGroup = new L.LayerGroup()),
                (this._layerGroup._pmTempLayer = !0),
                this._layerGroup.addTo(this._map),
                (this._layer = L.circleMarker(
                  [0, 0],
                  this.options.templineStyle
                )),
                (this._layer._pmTempLayer = !0),
                this._layerGroup.addLayer(this._layer),
                this._layer.setRadius(0),
                (this._centerMarker = L.marker([0, 0], {
                  icon: L.divIcon({ className: "marker-icon" }),
                  draggable: !1,
                  zIndexOffset: 100,
                })),
                (this._centerMarker._pmTempLayer = !0),
                this._layerGroup.addLayer(this._centerMarker),
                (this._hintMarker = L.marker([0, 0], {
                  icon: L.divIcon({ className: "marker-icon cursor-marker" }),
                })),
                (this._hintMarker._pmTempLayer = !0),
                this._layerGroup.addLayer(this._hintMarker),
                this.options.cursorMarker &&
                  L.DomUtil.addClass(this._hintMarker._icon, "visible"),
                this.options.tooltips &&
                  this._hintMarker
                    .bindTooltip(rt("tooltips.startCircle"), {
                      permanent: !0,
                      offset: L.point(0, 10),
                      direction: "bottom",
                      opacity: 0.8,
                    })
                    .openTooltip(),
                (this._hintline = L.polyline([], this.options.hintlineStyle)),
                (this._hintline._pmTempLayer = !0),
                this._layerGroup.addLayer(this._hintline),
                this._map.on("click", this._placeCenterMarker, this),
                (this._map._container.style.cursor = "crosshair"))
              : (this._map.on("click", this._createMarker, this),
                (this._hintMarker = L.circleMarker(
                  [0, 0],
                  this.options.templineStyle
                )),
                (this._hintMarker._pmTempLayer = !0),
                this._hintMarker.addTo(this._map),
                (this._layer = this._hintMarker),
                this.options.tooltips &&
                  this._hintMarker
                    .bindTooltip(rt("tooltips.placeCircleMarker"), {
                      permanent: !0,
                      offset: L.point(0, 10),
                      direction: "bottom",
                      opacity: 0.8,
                    })
                    .openTooltip()),
            this._map.on("mousemove", this._syncHintMarker, this),
            this._map.fire("pm:drawstart", {
              shape: this._shape,
              workingLayer: this._layer,
            }),
            this._setGlobalDrawMode(),
            this.options.editable ||
              this._map.eachLayer(function (t) {
                e.isRelevantMarker(t) && t.pm.enable();
              });
        },
        disable: function () {
          var t = this;
          this._enabled &&
            (this.options.editable
              ? ((this._map._container.style.cursor = ""),
                this._map.off("click", this._finishShape, this),
                this._map.off("click", this._placeCenterMarker, this),
                this._map.removeLayer(this._layerGroup))
              : (this._map.off("click", this._createMarker, this),
                this._map.eachLayer(function (e) {
                  t.isRelevantMarker(e) && e.pm.disable();
                }),
                this._hintMarker.remove()),
            this._map.off("mousemove", this._syncHintMarker, this),
            this._map.fire("pm:drawend", { shape: this._shape }),
            this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1),
            this.options.snappable && this._cleanupSnapping(),
            (this._enabled = !1));
        },
        _placeCenterMarker: function (t) {
          this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
          var e = this._hintMarker.getLatLng();
          this._centerMarker.setLatLng(e),
            this._map.off("click", this._placeCenterMarker, this),
            this._map.on("click", this._finishShape, this),
            this._placeCircleCenter();
        },
        _placeCircleCenter: function () {
          var t = this._centerMarker.getLatLng();
          t &&
            (this._layer.setLatLng(t),
            this._hintMarker.on("move", this._syncHintLine, this),
            this._hintMarker.on("move", this._syncCircleRadius, this),
            this._hintMarker.setTooltipContent(rt("tooltips.finishCircle")),
            this._layer.fire("pm:centerplaced", {
              shape: this._shape,
              workingLayer: this._layer,
              latlng: t,
            }));
        },
        _syncHintLine: function () {
          var t = this._centerMarker.getLatLng();
          this._hintline.setLatLngs([t, this._hintMarker.getLatLng()]);
        },
        _syncCircleRadius: function () {
          var t = this._centerMarker.getLatLng(),
            e = this._hintMarker.getLatLng(),
            r = this._map.project(t).distanceTo(this._map.project(e));
          this._layer.setRadius(r),
            this.calcMeasurement(this._layer),
            this.showMeasurementTooltip(this._layer, this._hintMarker);
        },
        _syncHintMarker: function (t) {
          if ((this._hintMarker.setLatLng(t.latlng), this.options.snappable)) {
            var e = t;
            (e.target = this._hintMarker), this._handleSnapping(e);
          }
          this.options.editable
            ? this.calcMeasurement(this._layer)
            : (this.calcMeasurement(this._hintMarker),
              this.showMeasurementTooltip(this._hintMarker, this._hintMarker));
        },
        isRelevantMarker: function (t) {
          return (
            t instanceof L.CircleMarker &&
            !(t instanceof L.Circle) &&
            t.pm &&
            !t._pmTempLayer
          );
        },
        _createMarker: function (t) {
          if (t.latlng) {
            this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
            var e = this._hintMarker.getLatLng(),
              r = L.circleMarker(e, this.options.pathOptions);
            this._setShapeForFinishLayer(r),
              this._addDrawnLayerProp(r),
              this.addMeasurementTooltipToLayer(r),
              r.addTo(this._map),
              r.pm.enable(),
              this._map.fire("pm:create", {
                shape: this._shape,
                marker: r,
                layer: r,
              }),
              this._cleanupSnapping();
          }
        },
        _finishShape: function (t) {
          this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
          var e = this._centerMarker.getLatLng(),
            r = this._hintMarker.getLatLng(),
            n = this._map.project(e).distanceTo(this._map.project(r)),
            i = Object.assign({}, this.options.pathOptions, { radius: n }),
            o = L.circleMarker(e, i).addTo(this._map);
          this._setShapeForFinishLayer(o),
            this._addDrawnLayerProp(o),
            o.pm._updateHiddenPolyCircle(),
            this.options.editable && this.addMeasurementTooltipToLayer(o),
            this.disable(),
            this._map.fire("pm:create", { shape: this._shape, layer: o });
        },
      }));
    var Ot = function (t, e, r, n, i) {
      !(function t(e, r, n, i, o) {
        for (; n < i; ) {
          if (600 < i - n) {
            var a = i - n + 1,
              s = r - n + 1,
              l = Math.log(a),
              h = 0.5 * Math.exp((2 * l) / 3),
              u =
                0.5 *
                Math.sqrt((l * h * (a - h)) / a) *
                (s - a / 2 < 0 ? -1 : 1);
            t(
              e,
              r,
              Math.max(n, Math.floor(r - (s * h) / a + u)),
              Math.min(i, Math.floor(r + ((a - s) * h) / a + u)),
              o
            );
          }
          var c = e[r],
            f = n,
            p = i;
          for (Ct(e, n, r), 0 < o(e[i], c) && Ct(e, n, i); f < p; ) {
            for (Ct(e, f, p), f++, p--; o(e[f], c) < 0; ) f++;
            for (; 0 < o(e[p], c); ) p--;
          }
          0 === o(e[n], c) ? Ct(e, n, p) : Ct(e, ++p, i),
            p <= r && (n = p + 1),
            r <= p && (i = p - 1);
        }
      })(t, e, r || 0, n || t.length - 1, i || Pt);
    };
    function Bt(t, e) {
      if (!(this instanceof Bt)) return new Bt(t, e);
      (this._maxEntries = Math.max(4, t || 9)),
        (this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries))),
        e && this._initFormat(e),
        this.clear();
    }
    function Tt(t, e, r) {
      if (!r) return e.indexOf(t);
      for (var n = 0; n < e.length; n++) if (r(t, e[n])) return n;
      return -1;
    }
    function Dt(t, e) {
      It(t, 0, t.children.length, e, t);
    }
    function It(t, e, r, n, i) {
      ((i = i || qt(null)).minX = 1 / 0),
        (i.minY = 1 / 0),
        (i.maxX = -1 / 0),
        (i.maxY = -1 / 0);
      for (var o, a = e; a < r; a++)
        (o = t.children[a]), jt(i, t.leaf ? n(o) : o);
      return i;
    }
    function jt(t, e) {
      return (
        (t.minX = Math.min(t.minX, e.minX)),
        (t.minY = Math.min(t.minY, e.minY)),
        (t.maxX = Math.max(t.maxX, e.maxX)),
        (t.maxY = Math.max(t.maxY, e.maxY)),
        t
      );
    }
    function At(t, e) {
      return t.minX - e.minX;
    }
    function Rt(t, e) {
      return t.minY - e.minY;
    }
    function Gt(t) {
      return (t.maxX - t.minX) * (t.maxY - t.minY);
    }
    function Nt(t) {
      return t.maxX - t.minX + (t.maxY - t.minY);
    }
    function Ft(t, e) {
      return (
        t.minX <= e.minX &&
        t.minY <= e.minY &&
        e.maxX <= t.maxX &&
        e.maxY <= t.maxY
      );
    }
    function zt(t, e) {
      return (
        e.minX <= t.maxX &&
        e.minY <= t.maxY &&
        e.maxX >= t.minX &&
        e.maxY >= t.minY
      );
    }
    function qt(t) {
      return {
        children: t,
        height: 1,
        leaf: !0,
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0,
      };
    }
    function Yt(t, e, r, n, i) {
      for (var o, a = [e, r]; a.length; )
        (r = a.pop()) - (e = a.pop()) <= n ||
          ((o = e + Math.ceil((r - e) / n / 2) * n),
          Ot(t, o, e, r, i),
          a.push(e, o, o, r));
    }
    Bt.prototype = {
      all: function () {
        return this._all(this.data, []);
      },
      search: function (t) {
        var e = this.data,
          r = [],
          n = this.toBBox;
        if (!zt(t, e)) return r;
        for (var i, o, a, s, l = []; e; ) {
          for (i = 0, o = e.children.length; i < o; i++)
            (a = e.children[i]),
              zt(t, (s = e.leaf ? n(a) : a)) &&
                (e.leaf ? r.push(a) : Ft(t, s) ? this._all(a, r) : l.push(a));
          e = l.pop();
        }
        return r;
      },
      collides: function (t) {
        var e = this.data,
          r = this.toBBox;
        if (!zt(t, e)) return !1;
        for (var n, i, o, a, s = []; e; ) {
          for (n = 0, i = e.children.length; n < i; n++)
            if (((o = e.children[n]), zt(t, (a = e.leaf ? r(o) : o)))) {
              if (e.leaf || Ft(t, a)) return !0;
              s.push(o);
            }
          e = s.pop();
        }
        return !1;
      },
      load: function (t) {
        if (!t || !t.length) return this;
        if (t.length < this._minEntries) {
          for (var e = 0, r = t.length; e < r; e++) this.insert(t[e]);
          return this;
        }
        var n = this._build(t.slice(), 0, t.length - 1, 0);
        if (this.data.children.length)
          if (this.data.height === n.height) this._splitRoot(this.data, n);
          else {
            if (this.data.height < n.height) {
              var i = this.data;
              (this.data = n), (n = i);
            }
            this._insert(n, this.data.height - n.height - 1, !0);
          }
        else this.data = n;
        return this;
      },
      insert: function (t) {
        return t && this._insert(t, this.data.height - 1), this;
      },
      clear: function () {
        return (this.data = qt([])), this;
      },
      remove: function (t, e) {
        if (!t) return this;
        for (
          var r, n, i, o, a = this.data, s = this.toBBox(t), l = [], h = [];
          a || l.length;

        ) {
          if (
            (a ||
              ((a = l.pop()), (n = l[l.length - 1]), (r = h.pop()), (o = !0)),
            a.leaf && -1 !== (i = Tt(t, a.children, e)))
          )
            return a.children.splice(i, 1), l.push(a), this._condense(l), this;
          o || a.leaf || !Ft(a, s)
            ? n
              ? (r++, (a = n.children[r]), (o = !1))
              : (a = null)
            : (l.push(a), h.push(r), (r = 0), (a = (n = a).children[0]));
        }
        return this;
      },
      toBBox: function (t) {
        return t;
      },
      compareMinX: At,
      compareMinY: Rt,
      toJSON: function () {
        return this.data;
      },
      fromJSON: function (t) {
        return (this.data = t), this;
      },
      _all: function (t, e) {
        for (var r = []; t; )
          t.leaf ? e.push.apply(e, t.children) : r.push.apply(r, t.children),
            (t = r.pop());
        return e;
      },
      _build: function (t, e, r, n) {
        var i,
          o = r - e + 1,
          a = this._maxEntries;
        if (o <= a) return Dt((i = qt(t.slice(e, r + 1))), this.toBBox), i;
        n ||
          ((n = Math.ceil(Math.log(o) / Math.log(a))),
          (a = Math.ceil(o / Math.pow(a, n - 1)))),
          ((i = qt([])).leaf = !1),
          (i.height = n);
        var s,
          l,
          h,
          u,
          c = Math.ceil(o / a),
          f = c * Math.ceil(Math.sqrt(a));
        for (Yt(t, e, r, f, this.compareMinX), s = e; s <= r; s += f)
          for (
            Yt(t, s, (h = Math.min(s + f - 1, r)), c, this.compareMinY), l = s;
            l <= h;
            l += c
          )
            (u = Math.min(l + c - 1, h)),
              i.children.push(this._build(t, l, u, n - 1));
        return Dt(i, this.toBBox), i;
      },
      _chooseSubtree: function (t, e, r, n) {
        for (
          var i, o, a, s, l, h, u, c, f, p;
          n.push(e), !e.leaf && n.length - 1 !== r;

        ) {
          for (u = c = 1 / 0, i = 0, o = e.children.length; i < o; i++)
            (l = Gt((a = e.children[i]))),
              (f = t),
              (p = a),
              (h =
                (Math.max(p.maxX, f.maxX) - Math.min(p.minX, f.minX)) *
                  (Math.max(p.maxY, f.maxY) - Math.min(p.minY, f.minY)) -
                l) < c
                ? ((c = h), (u = l < u ? l : u), (s = a))
                : h === c && l < u && ((u = l), (s = a));
          e = s || e.children[0];
        }
        return e;
      },
      _insert: function (t, e, r) {
        var n = this.toBBox,
          i = r ? t : n(t),
          o = [],
          a = this._chooseSubtree(i, this.data, e, o);
        for (
          a.children.push(t), jt(a, i);
          0 <= e && o[e].children.length > this._maxEntries;

        )
          this._split(o, e), e--;
        this._adjustParentBBoxes(i, o, e);
      },
      _split: function (t, e) {
        var r = t[e],
          n = r.children.length,
          i = this._minEntries;
        this._chooseSplitAxis(r, i, n);
        var o = this._chooseSplitIndex(r, i, n),
          a = qt(r.children.splice(o, r.children.length - o));
        (a.height = r.height),
          (a.leaf = r.leaf),
          Dt(r, this.toBBox),
          Dt(a, this.toBBox),
          e ? t[e - 1].children.push(a) : this._splitRoot(r, a);
      },
      _splitRoot: function (t, e) {
        (this.data = qt([t, e])),
          (this.data.height = t.height + 1),
          (this.data.leaf = !1),
          Dt(this.data, this.toBBox);
      },
      _chooseSplitIndex: function (t, e, r) {
        var n, i, o, a, s, l, h, u, c, f, p, d, g, m;
        for (l = h = 1 / 0, n = e; n <= r - e; n++)
          (c = i = It(t, 0, n, this.toBBox)),
            (f = o = It(t, n, r, this.toBBox)),
            (p = Math.max(c.minX, f.minX)),
            (d = Math.max(c.minY, f.minY)),
            (g = Math.min(c.maxX, f.maxX)),
            (m = Math.min(c.maxY, f.maxY)),
            (a = Math.max(0, g - p) * Math.max(0, m - d)),
            (s = Gt(i) + Gt(o)),
            a < l
              ? ((l = a), (u = n), (h = s < h ? s : h))
              : a === l && s < h && ((h = s), (u = n));
        return u;
      },
      _chooseSplitAxis: function (t, e, r) {
        var n = t.leaf ? this.compareMinX : At,
          i = t.leaf ? this.compareMinY : Rt;
        this._allDistMargin(t, e, r, n) < this._allDistMargin(t, e, r, i) &&
          t.children.sort(n);
      },
      _allDistMargin: function (t, e, r, n) {
        t.children.sort(n);
        var i,
          o,
          a = this.toBBox,
          s = It(t, 0, e, a),
          l = It(t, r - e, r, a),
          h = Nt(s) + Nt(l);
        for (i = e; i < r - e; i++)
          (o = t.children[i]), jt(s, t.leaf ? a(o) : o), (h += Nt(s));
        for (i = r - e - 1; e <= i; i--)
          (o = t.children[i]), jt(l, t.leaf ? a(o) : o), (h += Nt(l));
        return h;
      },
      _adjustParentBBoxes: function (t, e, r) {
        for (var n = r; 0 <= n; n--) jt(e[n], t);
      },
      _condense: function (t) {
        for (var e, r = t.length - 1; 0 <= r; r--)
          0 === t[r].children.length
            ? 0 < r
              ? (e = t[r - 1].children).splice(e.indexOf(t[r]), 1)
              : this.clear()
            : Dt(t[r], this.toBBox);
      },
      _initFormat: function (t) {
        var e = ["return a", " - b", ";"];
        (this.compareMinX = new Function("a", "b", e.join(t[0]))),
          (this.compareMinY = new Function("a", "b", e.join(t[1]))),
          (this.toBBox = new Function(
            "a",
            "return {minX: a" +
              t[0] +
              ", minY: a" +
              t[1] +
              ", maxX: a" +
              t[2] +
              ", maxY: a" +
              t[3] +
              "};"
          ));
      },
    };
    var Xt = Bt;
    function Ut(t, e, r) {
      if (!Kt((r = r || {}))) throw new Error("options is invalid");
      var n = r.bbox,
        i = r.id;
      if (void 0 === t) throw new Error("geometry is required");
      if (e && e.constructor !== Object)
        throw new Error("properties must be an Object");
      n && $t(n), i && Zt(i);
      var o = { type: "Feature" };
      return (
        i && (o.id = i),
        n && (o.bbox = n),
        (o.properties = e || {}),
        (o.geometry = t),
        o
      );
    }
    function Jt(t, e, r) {
      if (!t) throw new Error("coordinates is required");
      if (t.length < 2)
        throw new Error(
          "coordinates must be an array of two or more positions"
        );
      if (!Ht(t[0][1]) || !Ht(t[0][1]))
        throw new Error("coordinates must contain numbers");
      return Ut({ type: "LineString", coordinates: t }, e, r);
    }
    function Vt(t, e) {
      if (!Kt((e = e || {}))) throw new Error("options is invalid");
      var r = e.bbox,
        n = e.id;
      if (!t) throw new Error("No features passed");
      if (!Array.isArray(t)) throw new Error("features must be an Array");
      r && $t(r), n && Zt(n);
      var i = { type: "FeatureCollection" };
      return n && (i.id = n), r && (i.bbox = r), (i.features = t), i;
    }
    function Ht(t) {
      return !isNaN(t) && null !== t && !Array.isArray(t);
    }
    function Kt(t) {
      return !!t && t.constructor === Object;
    }
    function $t(t) {
      if (!t) throw new Error("bbox is required");
      if (!Array.isArray(t)) throw new Error("bbox must be an Array");
      if (4 !== t.length && 6 !== t.length)
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      t.forEach(function (t) {
        if (!Ht(t)) throw new Error("bbox must only contain numbers");
      });
    }
    function Zt(t) {
      if (!t) throw new Error("id is required");
      if (-1 === ["string", "number"].indexOf(typeof t))
        throw new Error("id must be a number or a string");
    }
    function Wt(t, e, r) {
      if (null !== t)
        for (
          var n,
            i,
            o,
            a,
            s,
            l,
            h,
            u,
            c = 0,
            f = 0,
            p = t.type,
            d = "FeatureCollection" === p,
            g = "Feature" === p,
            m = d ? t.features.length : 1,
            y = 0;
          y < m;
          y++
        ) {
          s = (u =
            !!(h = d ? t.features[y].geometry : g ? t.geometry : t) &&
            "GeometryCollection" === h.type)
            ? h.geometries.length
            : 1;
          for (var _ = 0; _ < s; _++) {
            var v = 0,
              b = 0;
            if (null !== (a = u ? h.geometries[_] : h)) {
              l = a.coordinates;
              var L = a.type;
              switch (
                ((c = !r || ("Polygon" !== L && "MultiPolygon" !== L) ? 0 : 1),
                L)
              ) {
                case null:
                  break;
                case "Point":
                  if (!1 === e(l, f, y, v, b)) return !1;
                  f++, v++;
                  break;
                case "LineString":
                case "MultiPoint":
                  for (n = 0; n < l.length; n++) {
                    if (!1 === e(l[n], f, y, v, b)) return !1;
                    f++, "MultiPoint" === L && v++;
                  }
                  "LineString" === L && v++;
                  break;
                case "Polygon":
                case "MultiLineString":
                  for (n = 0; n < l.length; n++) {
                    for (i = 0; i < l[n].length - c; i++) {
                      if (!1 === e(l[n][i], f, y, v, b)) return !1;
                      f++;
                    }
                    "MultiLineString" === L && v++, "Polygon" === L && b++;
                  }
                  "Polygon" === L && v++;
                  break;
                case "MultiPolygon":
                  for (n = 0; n < l.length; n++) {
                    for (
                      "MultiPolygon" === L && (b = 0), i = 0;
                      i < l[n].length;
                      i++
                    ) {
                      for (o = 0; o < l[n][i].length - c; o++) {
                        if (!1 === e(l[n][i][o], f, y, v, b)) return !1;
                        f++;
                      }
                      b++;
                    }
                    v++;
                  }
                  break;
                case "GeometryCollection":
                  for (n = 0; n < a.geometries.length; n++)
                    if (!1 === Wt(a.geometries[n], e, r)) return !1;
                  break;
                default:
                  throw new Error("Unknown Geometry Type");
              }
            }
          }
        }
    }
    function Qt(t, e) {
      if ("Feature" === t.type) e(t, 0);
      else if ("FeatureCollection" === t.type)
        for (
          var r = 0;
          r < t.features.length && !1 !== e(t.features[r], r);
          r++
        );
    }
    function te(t, e) {
      !(function (t, e) {
        var r,
          n,
          i,
          o,
          a,
          s,
          l,
          h,
          u,
          c,
          f = 0,
          p = "FeatureCollection" === t.type,
          d = "Feature" === t.type,
          g = p ? t.features.length : 1;
        for (r = 0; r < g; r++) {
          for (
            s = p ? t.features[r].geometry : d ? t.geometry : t,
              h = p ? t.features[r].properties : d ? t.properties : {},
              u = p ? t.features[r].bbox : d ? t.bbox : void 0,
              c = p ? t.features[r].id : d ? t.id : void 0,
              a = (l = !!s && "GeometryCollection" === s.type)
                ? s.geometries.length
                : 1,
              i = 0;
            i < a;
            i++
          )
            if (null !== (o = l ? s.geometries[i] : s))
              switch (o.type) {
                case "Point":
                case "LineString":
                case "MultiPoint":
                case "Polygon":
                case "MultiLineString":
                case "MultiPolygon":
                  if (!1 === e(o, f, h, u, c)) return !1;
                  break;
                case "GeometryCollection":
                  for (n = 0; n < o.geometries.length; n++)
                    if (!1 === e(o.geometries[n], f, h, u, c)) return !1;
                  break;
                default:
                  throw new Error("Unknown Geometry Type");
              }
            else if (!1 === e(null, f, h, u, c)) return !1;
          f++;
        }
      })(t, function (t, r, n, i, o) {
        var a,
          s = null === t ? null : t.type;
        switch (s) {
          case null:
          case "Point":
          case "LineString":
          case "Polygon":
            return !1 !== e(Ut(t, n, { bbox: i, id: o }), r, 0) && void 0;
        }
        switch (s) {
          case "MultiPoint":
            a = "Point";
            break;
          case "MultiLineString":
            a = "LineString";
            break;
          case "MultiPolygon":
            a = "Polygon";
        }
        for (var l = 0; l < t.coordinates.length; l++) {
          var h = t.coordinates[l];
          if (!1 === e(Ut({ type: a, coordinates: h }, n), r, l)) return !1;
        }
      });
    }
    function ee(t) {
      var e = [t[0], t[1]],
        r = [t[0], t[3]],
        n = [t[2], t[3]];
      return {
        type: "Feature",
        bbox: t,
        properties: {},
        geometry: {
          type: "Polygon",
          coordinates: [[e, [t[2], t[1]], n, r, e]],
        },
      };
    }
    function re(t) {
      var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      return (
        Wt(t, function (t) {
          e[0] > t[0] && (e[0] = t[0]),
            e[1] > t[1] && (e[1] = t[1]),
            e[2] < t[0] && (e[2] = t[0]),
            e[3] < t[1] && (e[3] = t[1]);
        }),
        e
      );
    }
    var ne = function (t) {
        var e = Xt(t);
        return (
          (e.insert = function (t) {
            if (Array.isArray(t)) {
              var e = t;
              (t = ee(e)).bbox = e;
            } else t.bbox = t.bbox ? t.bbox : re(t);
            return Xt.prototype.insert.call(this, t);
          }),
          (e.load = function (t) {
            var e = [];
            return (
              Array.isArray(t)
                ? t.forEach(function (t) {
                    var r = ee(t);
                    (r.bbox = t), e.push(r);
                  })
                : Qt(t, function (t) {
                    (t.bbox = t.bbox ? t.bbox : re(t)), e.push(t);
                  }),
              Xt.prototype.load.call(this, e)
            );
          }),
          (e.remove = function (t) {
            if (Array.isArray(t)) {
              var e = t;
              (t = ee(e)).bbox = e;
            }
            return Xt.prototype.remove.call(this, t);
          }),
          (e.clear = function () {
            return Xt.prototype.clear.call(this);
          }),
          (e.search = function (t) {
            return {
              type: "FeatureCollection",
              features: Xt.prototype.search.call(this, this.toBBox(t)),
            };
          }),
          (e.collides = function (t) {
            return Xt.prototype.collides.call(this, this.toBBox(t));
          }),
          (e.all = function () {
            return {
              type: "FeatureCollection",
              features: Xt.prototype.all.call(this),
            };
          }),
          (e.toJSON = function () {
            return Xt.prototype.toJSON.call(this);
          }),
          (e.fromJSON = function (t) {
            return Xt.prototype.fromJSON.call(this, t);
          }),
          (e.toBBox = function (t) {
            var e;
            return {
              minX: (e = t.bbox
                ? t.bbox
                : Array.isArray(t) && 4 === t.length
                ? t
                : re(t))[0],
              minY: e[1],
              maxX: e[2],
              maxY: e[3],
            };
          }),
          e
        );
      },
      ie = 6371008.8,
      oe = {
        meters: ie,
        metres: ie,
        millimeters: 1e3 * ie,
        millimetres: 1e3 * ie,
        centimeters: 100 * ie,
        centimetres: 100 * ie,
        kilometers: ie / 1e3,
        kilometres: ie / 1e3,
        miles: ie / 1609.344,
        nauticalmiles: ie / 1852,
        inches: 39.37 * ie,
        yards: ie / 1.0936,
        feet: 3.28084 * ie,
        radians: 1,
        degrees: ie / 111325,
      };
    function ae(t) {
      if (null == t) throw new Error("degrees is required");
      return ((t % 360) * Math.PI) / 180;
    }
    function se(t) {
      if (!t) throw new Error("coord is required");
      if (
        "Feature" === t.type &&
        null !== t.geometry &&
        "Point" === t.geometry.type
      )
        return t.geometry.coordinates;
      if ("Point" === t.type) return t.coordinates;
      if (
        Array.isArray(t) &&
        2 <= t.length &&
        void 0 === t[0].length &&
        void 0 === t[1].length
      )
        return t;
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }
    var le = function (t, e, r) {
      if (
        !(function (t) {
          return !!t && t.constructor === Object;
        })((r = r || {}))
      )
        throw new Error("options is invalid");
      var n = r.units,
        i = se(t),
        o = se(e),
        a = ae(o[1] - i[1]),
        s = ae(o[0] - i[0]),
        l = ae(i[1]),
        h = ae(o[1]),
        u =
          Math.pow(Math.sin(a / 2), 2) +
          Math.pow(Math.sin(s / 2), 2) * Math.cos(l) * Math.cos(h);
      return (function (t, e) {
        if (null == t) throw new Error("radians is required");
        if (e && "string" != typeof e)
          throw new Error("units must be a string");
        var r = oe[e || "kilometers"];
        if (!r) throw new Error(e + " units is invalid");
        return t * r;
      })(2 * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u)), n);
    };
    var he = function (t, e) {
      if (
        !(function (t) {
          return !!t && t.constructor === Object;
        })((e = e || {}))
      )
        throw new Error("options is invalid");
      var r = e.precision,
        n = e.coordinates,
        i = e.mutate;
      if (
        ((r = null == r || isNaN(r) ? 6 : r),
        (n = null == n || isNaN(n) ? 3 : n),
        !t)
      )
        throw new Error("<geojson> is required");
      if ("number" != typeof r) throw new Error("<precision> must be a number");
      if ("number" != typeof n)
        throw new Error("<coordinates> must be a number");
      (!1 !== i && void 0 !== i) || (t = JSON.parse(JSON.stringify(t)));
      var o = Math.pow(10, r);
      return (
        (function t(e, r, n) {
          if (null !== e)
            for (
              var i,
                o,
                a,
                s,
                l,
                h,
                u,
                c,
                f = 0,
                p = 0,
                d = e.type,
                g = "FeatureCollection" === d,
                m = "Feature" === d,
                y = g ? e.features.length : 1,
                _ = 0;
              _ < y;
              _++
            ) {
              l = (c =
                !!(u = g ? e.features[_].geometry : m ? e.geometry : e) &&
                "GeometryCollection" === u.type)
                ? u.geometries.length
                : 1;
              for (var v = 0; v < l; v++) {
                var b = 0,
                  L = 0;
                if (null !== (s = c ? u.geometries[v] : u)) {
                  h = s.coordinates;
                  var k = s.type;
                  switch (
                    ((f =
                      !n || ("Polygon" !== k && "MultiPolygon" !== k) ? 0 : 1),
                    k)
                  ) {
                    case null:
                      break;
                    case "Point":
                      if (!1 === r(h, p, _, b, L)) return !1;
                      p++, b++;
                      break;
                    case "LineString":
                    case "MultiPoint":
                      for (i = 0; i < h.length; i++) {
                        if (!1 === r(h[i], p, _, b, L)) return !1;
                        p++, "MultiPoint" === k && b++;
                      }
                      "LineString" === k && b++;
                      break;
                    case "Polygon":
                    case "MultiLineString":
                      for (i = 0; i < h.length; i++) {
                        for (o = 0; o < h[i].length - f; o++) {
                          if (!1 === r(h[i][o], p, _, b, L)) return !1;
                          p++;
                        }
                        "MultiLineString" === k && b++, "Polygon" === k && L++;
                      }
                      "Polygon" === k && b++;
                      break;
                    case "MultiPolygon":
                      for (i = 0; i < h.length; i++) {
                        for (
                          "MultiPolygon" === k && (L = 0), o = 0;
                          o < h[i].length;
                          o++
                        ) {
                          for (a = 0; a < h[i][o].length - f; a++) {
                            if (!1 === r(h[i][o][a], p, _, b, L)) return !1;
                            p++;
                          }
                          L++;
                        }
                        b++;
                      }
                      break;
                    case "GeometryCollection":
                      for (i = 0; i < s.geometries.length; i++)
                        if (!1 === t(s.geometries[i], r, n)) return !1;
                      break;
                    default:
                      throw new Error("Unknown Geometry Type");
                  }
                }
              }
            }
        })(t, function (t) {
          !(function (t, e, r) {
            t.length > r && t.splice(r, t.length);
            for (var n = 0; n < t.length; n++) t[n] = Math.round(t[n] * e) / e;
          })(t, o, n);
        }),
        t
      );
    };
    function ue(t) {
      if (!t) throw new Error("coord is required");
      if (
        "Feature" === t.type &&
        null !== t.geometry &&
        "Point" === t.geometry.type
      )
        return t.geometry.coordinates;
      if ("Point" === t.type) return t.coordinates;
      if (
        Array.isArray(t) &&
        2 <= t.length &&
        void 0 === t[0].length &&
        void 0 === t[1].length
      )
        return t;
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }
    function ce(t) {
      if (!t) throw new Error("coords is required");
      if ("Feature" === t.type && null !== t.geometry)
        return t.geometry.coordinates;
      if (t.coordinates) return t.coordinates;
      if (Array.isArray(t)) return t;
      throw new Error(
        "coords must be GeoJSON Feature, Geometry Object or an Array"
      );
    }
    function fe(t, e) {
      if (!t) throw new Error((e || "geojson") + " is required");
      if (t.geometry && t.geometry.type) return t.geometry.type;
      if (t.type) return t.type;
      throw new Error((e || "geojson") + " is invalid");
    }
    var pe = function (t) {
      if (!t) throw new Error("geojson is required");
      var e = [];
      return (
        te(t, function (t) {
          !(function (t, e) {
            var r = [],
              n = t.geometry;
            switch (n.type) {
              case "Polygon":
                r = ce(n);
                break;
              case "LineString":
                r = [ce(n)];
            }
            r.forEach(function (r) {
              (function (t, e) {
                var r = [];
                return (
                  t.reduce(function (t, n) {
                    var i = Jt([t, n], e);
                    return (
                      (i.bbox = (function (t, e) {
                        var r = t[0],
                          n = t[1],
                          i = e[0],
                          o = e[1];
                        return [
                          r < i ? r : i,
                          n < o ? n : o,
                          i < r ? r : i,
                          o < n ? n : o,
                        ];
                      })(t, n)),
                      r.push(i),
                      n
                    );
                  }),
                  r
                );
              })(r, t.properties).forEach(function (t) {
                (t.id = e.length), e.push(t);
              });
            });
          })(t, e);
        }),
        Vt(e)
      );
    };
    function de(t, e) {
      var r = ce(t),
        n = ce(e);
      if (2 !== r.length)
        throw new Error("<intersects> line1 must only contain 2 coordinates");
      if (2 !== n.length)
        throw new Error("<intersects> line2 must only contain 2 coordinates");
      var i = r[0][0],
        o = r[0][1],
        a = r[1][0],
        s = r[1][1],
        l = n[0][0],
        h = n[0][1],
        u = n[1][0],
        c = n[1][1],
        f = (c - h) * (a - i) - (u - l) * (s - o);
      if (0 == f) return null;
      var p = ((u - l) * (o - h) - (c - h) * (i - l)) / f,
        d = ((a - i) * (o - h) - (s - o) * (i - l)) / f;
      return 0 <= p && p <= 1 && 0 <= d && d <= 1
        ? (function (t, e, r) {
            if (!t) throw new Error("coordinates is required");
            if (!Array.isArray(t))
              throw new Error("coordinates must be an Array");
            if (t.length < 2)
              throw new Error("coordinates must be at least 2 numbers long");
            if (!Ht(t[0]) || !Ht(t[1]))
              throw new Error("coordinates must contain numbers");
            return Ut({ type: "Point", coordinates: t }, e, r);
          })([i + p * (a - i), o + p * (s - o)])
        : null;
    }
    function ge(t) {
      if (null == t) throw new Error("degrees is required");
      return ((t % 360) * Math.PI) / 180;
    }
    function me(t) {
      if (!t) throw new Error("coord is required");
      if (
        "Feature" === t.type &&
        null !== t.geometry &&
        "Point" === t.geometry.type
      )
        return t.geometry.coordinates;
      if ("Point" === t.type) return t.coordinates;
      if (
        Array.isArray(t) &&
        2 <= t.length &&
        void 0 === t[0].length &&
        void 0 === t[1].length
      )
        return t;
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }
    var ye = function t(e, r, n) {
        if (
          !(function (t) {
            return !!t && t.constructor === Object;
          })((n = n || {}))
        )
          throw new Error("options is invalid");
        if (!0 === n.final)
          return (function (e, r) {
            var n = t(r, e);
            return (n + 180) % 360;
          })(e, r);
        var i = me(e),
          o = me(r),
          a = ge(i[0]),
          s = ge(o[0]),
          l = ge(i[1]),
          h = ge(o[1]),
          u = Math.sin(s - a) * Math.cos(h),
          c =
            Math.cos(l) * Math.sin(h) -
            Math.sin(l) * Math.cos(h) * Math.cos(s - a);
        return (function (t) {
          if (null == t) throw new Error("radians is required");
          return ((t % (2 * Math.PI)) * 180) / Math.PI;
        })(Math.atan2(u, c));
      },
      _e = 6371008.8,
      ve = {
        meters: _e,
        metres: _e,
        millimeters: 1e3 * _e,
        millimetres: 1e3 * _e,
        centimeters: 100 * _e,
        centimetres: 100 * _e,
        kilometers: _e / 1e3,
        kilometres: _e / 1e3,
        miles: _e / 1609.344,
        nauticalmiles: _e / 1852,
        inches: 39.37 * _e,
        yards: _e / 1.0936,
        feet: 3.28084 * _e,
        radians: 1,
        degrees: _e / 111325,
      };
    function be(t, e, r) {
      if (!we((r = r || {}))) throw new Error("options is invalid");
      var n = r.bbox,
        i = r.id;
      if (void 0 === t) throw new Error("geometry is required");
      if (e && e.constructor !== Object)
        throw new Error("properties must be an Object");
      n &&
        (function (t) {
          if (!t) throw new Error("bbox is required");
          if (!Array.isArray(t)) throw new Error("bbox must be an Array");
          if (4 !== t.length && 6 !== t.length)
            throw new Error("bbox must be an Array of 4 or 6 numbers");
          t.forEach(function (t) {
            if (!Me(t)) throw new Error("bbox must only contain numbers");
          });
        })(n),
        i &&
          (function (t) {
            if (!t) throw new Error("id is required");
            if (-1 === ["string", "number"].indexOf(typeof t))
              throw new Error("id must be a number or a string");
          })(i);
      var o = { type: "Feature" };
      return (
        i && (o.id = i),
        n && (o.bbox = n),
        (o.properties = e || {}),
        (o.geometry = t),
        o
      );
    }
    function Le(t) {
      if (null == t) throw new Error("radians is required");
      return ((t % (2 * Math.PI)) * 180) / Math.PI;
    }
    function ke(t) {
      if (null == t) throw new Error("degrees is required");
      return ((t % 360) * Math.PI) / 180;
    }
    function Me(t) {
      return !isNaN(t) && null !== t && !Array.isArray(t);
    }
    function we(t) {
      return !!t && t.constructor === Object;
    }
    var xe = function (t, e, r, n) {
      if (!we((n = n || {}))) throw new Error("options is invalid");
      var i = n.units,
        o = n.properties,
        a = (function (t) {
          if (!t) throw new Error("coord is required");
          if (
            "Feature" === t.type &&
            null !== t.geometry &&
            "Point" === t.geometry.type
          )
            return t.geometry.coordinates;
          if ("Point" === t.type) return t.coordinates;
          if (
            Array.isArray(t) &&
            2 <= t.length &&
            void 0 === t[0].length &&
            void 0 === t[1].length
          )
            return t;
          throw new Error("coord must be GeoJSON Point or an Array of numbers");
        })(t),
        s = ke(a[0]),
        l = ke(a[1]),
        h = ke(r),
        u = (function (t, e) {
          if (null == t) throw new Error("distance is required");
          if (e && "string" != typeof e)
            throw new Error("units must be a string");
          var r = ve[e || "kilometers"];
          if (!r) throw new Error(e + " units is invalid");
          return t / r;
        })(e, i),
        c = Math.asin(
          Math.sin(l) * Math.cos(u) + Math.cos(l) * Math.sin(u) * Math.cos(h)
        );
      return (function (t, e, r) {
        if (!t) throw new Error("coordinates is required");
        if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
        if (t.length < 2)
          throw new Error("coordinates must be at least 2 numbers long");
        if (!Me(t[0]) || !Me(t[1]))
          throw new Error("coordinates must contain numbers");
        return be({ type: "Point", coordinates: t }, e, r);
      })(
        [
          Le(
            s +
              Math.atan2(
                Math.sin(h) * Math.sin(u) * Math.cos(l),
                Math.cos(u) - Math.sin(l) * Math.sin(c)
              )
          ),
          Le(c),
        ],
        o
      );
    };
    function Se(t, e, r) {
      var n = t[e];
      (t[e] = t[r]), (t[r] = n);
    }
    function Ee(t, e) {
      return t < e ? -1 : e < t ? 1 : 0;
    }
    var Ce = function (t, e, r, n, i) {
      !(function t(e, r, n, i, o) {
        for (; n < i; ) {
          if (600 < i - n) {
            var a = i - n + 1,
              s = r - n + 1,
              l = Math.log(a),
              h = 0.5 * Math.exp((2 * l) / 3),
              u =
                0.5 *
                Math.sqrt((l * h * (a - h)) / a) *
                (s - a / 2 < 0 ? -1 : 1);
            t(
              e,
              r,
              Math.max(n, Math.floor(r - (s * h) / a + u)),
              Math.min(i, Math.floor(r + ((a - s) * h) / a + u)),
              o
            );
          }
          var c = e[r],
            f = n,
            p = i;
          for (Se(e, n, r), 0 < o(e[i], c) && Se(e, n, i); f < p; ) {
            for (Se(e, f, p), f++, p--; o(e[f], c) < 0; ) f++;
            for (; 0 < o(e[p], c); ) p--;
          }
          0 === o(e[n], c) ? Se(e, n, p) : Se(e, ++p, i),
            p <= r && (n = p + 1),
            r <= p && (i = p - 1);
        }
      })(t, e, r || 0, n || t.length - 1, i || Ee);
    };
    function Pe(t, e) {
      if (!(this instanceof Pe)) return new Pe(t, e);
      (this._maxEntries = Math.max(4, t || 9)),
        (this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries))),
        e && this._initFormat(e),
        this.clear();
    }
    function Oe(t, e, r) {
      if (!r) return e.indexOf(t);
      for (var n = 0; n < e.length; n++) if (r(t, e[n])) return n;
      return -1;
    }
    function Be(t, e) {
      Te(t, 0, t.children.length, e, t);
    }
    function Te(t, e, r, n, i) {
      ((i = i || Fe(null)).minX = 1 / 0),
        (i.minY = 1 / 0),
        (i.maxX = -1 / 0),
        (i.maxY = -1 / 0);
      for (var o, a = e; a < r; a++)
        (o = t.children[a]), De(i, t.leaf ? n(o) : o);
      return i;
    }
    function De(t, e) {
      return (
        (t.minX = Math.min(t.minX, e.minX)),
        (t.minY = Math.min(t.minY, e.minY)),
        (t.maxX = Math.max(t.maxX, e.maxX)),
        (t.maxY = Math.max(t.maxY, e.maxY)),
        t
      );
    }
    function Ie(t, e) {
      return t.minX - e.minX;
    }
    function je(t, e) {
      return t.minY - e.minY;
    }
    function Ae(t) {
      return (t.maxX - t.minX) * (t.maxY - t.minY);
    }
    function Re(t) {
      return t.maxX - t.minX + (t.maxY - t.minY);
    }
    function Ge(t, e) {
      return (
        t.minX <= e.minX &&
        t.minY <= e.minY &&
        e.maxX <= t.maxX &&
        e.maxY <= t.maxY
      );
    }
    function Ne(t, e) {
      return (
        e.minX <= t.maxX &&
        e.minY <= t.maxY &&
        e.maxX >= t.minX &&
        e.maxY >= t.minY
      );
    }
    function Fe(t) {
      return {
        children: t,
        height: 1,
        leaf: !0,
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0,
      };
    }
    function ze(t, e, r, n, i) {
      for (var o, a = [e, r]; a.length; )
        (r = a.pop()) - (e = a.pop()) <= n ||
          ((o = e + Math.ceil((r - e) / n / 2) * n),
          Ce(t, o, e, r, i),
          a.push(e, o, o, r));
    }
    Pe.prototype = {
      all: function () {
        return this._all(this.data, []);
      },
      search: function (t) {
        var e = this.data,
          r = [],
          n = this.toBBox;
        if (!Ne(t, e)) return r;
        for (var i, o, a, s, l = []; e; ) {
          for (i = 0, o = e.children.length; i < o; i++)
            (a = e.children[i]),
              Ne(t, (s = e.leaf ? n(a) : a)) &&
                (e.leaf ? r.push(a) : Ge(t, s) ? this._all(a, r) : l.push(a));
          e = l.pop();
        }
        return r;
      },
      collides: function (t) {
        var e = this.data,
          r = this.toBBox;
        if (!Ne(t, e)) return !1;
        for (var n, i, o, a, s = []; e; ) {
          for (n = 0, i = e.children.length; n < i; n++)
            if (((o = e.children[n]), Ne(t, (a = e.leaf ? r(o) : o)))) {
              if (e.leaf || Ge(t, a)) return !0;
              s.push(o);
            }
          e = s.pop();
        }
        return !1;
      },
      load: function (t) {
        if (!t || !t.length) return this;
        if (t.length < this._minEntries) {
          for (var e = 0, r = t.length; e < r; e++) this.insert(t[e]);
          return this;
        }
        var n = this._build(t.slice(), 0, t.length - 1, 0);
        if (this.data.children.length)
          if (this.data.height === n.height) this._splitRoot(this.data, n);
          else {
            if (this.data.height < n.height) {
              var i = this.data;
              (this.data = n), (n = i);
            }
            this._insert(n, this.data.height - n.height - 1, !0);
          }
        else this.data = n;
        return this;
      },
      insert: function (t) {
        return t && this._insert(t, this.data.height - 1), this;
      },
      clear: function () {
        return (this.data = Fe([])), this;
      },
      remove: function (t, e) {
        if (!t) return this;
        for (
          var r, n, i, o, a = this.data, s = this.toBBox(t), l = [], h = [];
          a || l.length;

        ) {
          if (
            (a ||
              ((a = l.pop()), (n = l[l.length - 1]), (r = h.pop()), (o = !0)),
            a.leaf && -1 !== (i = Oe(t, a.children, e)))
          )
            return a.children.splice(i, 1), l.push(a), this._condense(l), this;
          o || a.leaf || !Ge(a, s)
            ? n
              ? (r++, (a = n.children[r]), (o = !1))
              : (a = null)
            : (l.push(a), h.push(r), (r = 0), (a = (n = a).children[0]));
        }
        return this;
      },
      toBBox: function (t) {
        return t;
      },
      compareMinX: Ie,
      compareMinY: je,
      toJSON: function () {
        return this.data;
      },
      fromJSON: function (t) {
        return (this.data = t), this;
      },
      _all: function (t, e) {
        for (var r = []; t; )
          t.leaf ? e.push.apply(e, t.children) : r.push.apply(r, t.children),
            (t = r.pop());
        return e;
      },
      _build: function (t, e, r, n) {
        var i,
          o = r - e + 1,
          a = this._maxEntries;
        if (o <= a) return Be((i = Fe(t.slice(e, r + 1))), this.toBBox), i;
        n ||
          ((n = Math.ceil(Math.log(o) / Math.log(a))),
          (a = Math.ceil(o / Math.pow(a, n - 1)))),
          ((i = Fe([])).leaf = !1),
          (i.height = n);
        var s,
          l,
          h,
          u,
          c = Math.ceil(o / a),
          f = c * Math.ceil(Math.sqrt(a));
        for (ze(t, e, r, f, this.compareMinX), s = e; s <= r; s += f)
          for (
            ze(t, s, (h = Math.min(s + f - 1, r)), c, this.compareMinY), l = s;
            l <= h;
            l += c
          )
            (u = Math.min(l + c - 1, h)),
              i.children.push(this._build(t, l, u, n - 1));
        return Be(i, this.toBBox), i;
      },
      _chooseSubtree: function (t, e, r, n) {
        for (
          var i, o, a, s, l, h, u, c, f, p;
          n.push(e), !e.leaf && n.length - 1 !== r;

        ) {
          for (u = c = 1 / 0, i = 0, o = e.children.length; i < o; i++)
            (l = Ae((a = e.children[i]))),
              (f = t),
              (p = a),
              (h =
                (Math.max(p.maxX, f.maxX) - Math.min(p.minX, f.minX)) *
                  (Math.max(p.maxY, f.maxY) - Math.min(p.minY, f.minY)) -
                l) < c
                ? ((c = h), (u = l < u ? l : u), (s = a))
                : h === c && l < u && ((u = l), (s = a));
          e = s || e.children[0];
        }
        return e;
      },
      _insert: function (t, e, r) {
        var n = this.toBBox,
          i = r ? t : n(t),
          o = [],
          a = this._chooseSubtree(i, this.data, e, o);
        for (
          a.children.push(t), De(a, i);
          0 <= e && o[e].children.length > this._maxEntries;

        )
          this._split(o, e), e--;
        this._adjustParentBBoxes(i, o, e);
      },
      _split: function (t, e) {
        var r = t[e],
          n = r.children.length,
          i = this._minEntries;
        this._chooseSplitAxis(r, i, n);
        var o = this._chooseSplitIndex(r, i, n),
          a = Fe(r.children.splice(o, r.children.length - o));
        (a.height = r.height),
          (a.leaf = r.leaf),
          Be(r, this.toBBox),
          Be(a, this.toBBox),
          e ? t[e - 1].children.push(a) : this._splitRoot(r, a);
      },
      _splitRoot: function (t, e) {
        (this.data = Fe([t, e])),
          (this.data.height = t.height + 1),
          (this.data.leaf = !1),
          Be(this.data, this.toBBox);
      },
      _chooseSplitIndex: function (t, e, r) {
        var n, i, o, a, s, l, h, u, c, f, p, d, g, m;
        for (l = h = 1 / 0, n = e; n <= r - e; n++)
          (c = i = Te(t, 0, n, this.toBBox)),
            (f = o = Te(t, n, r, this.toBBox)),
            (p = Math.max(c.minX, f.minX)),
            (d = Math.max(c.minY, f.minY)),
            (g = Math.min(c.maxX, f.maxX)),
            (m = Math.min(c.maxY, f.maxY)),
            (a = Math.max(0, g - p) * Math.max(0, m - d)),
            (s = Ae(i) + Ae(o)),
            a < l
              ? ((l = a), (u = n), (h = s < h ? s : h))
              : a === l && s < h && ((h = s), (u = n));
        return u;
      },
      _chooseSplitAxis: function (t, e, r) {
        var n = t.leaf ? this.compareMinX : Ie,
          i = t.leaf ? this.compareMinY : je;
        this._allDistMargin(t, e, r, n) < this._allDistMargin(t, e, r, i) &&
          t.children.sort(n);
      },
      _allDistMargin: function (t, e, r, n) {
        t.children.sort(n);
        var i,
          o,
          a = this.toBBox,
          s = Te(t, 0, e, a),
          l = Te(t, r - e, r, a),
          h = Re(s) + Re(l);
        for (i = e; i < r - e; i++)
          (o = t.children[i]), De(s, t.leaf ? a(o) : o), (h += Re(s));
        for (i = r - e - 1; e <= i; i--)
          (o = t.children[i]), De(l, t.leaf ? a(o) : o), (h += Re(l));
        return h;
      },
      _adjustParentBBoxes: function (t, e, r) {
        for (var n = r; 0 <= n; n--) De(e[n], t);
      },
      _condense: function (t) {
        for (var e, r = t.length - 1; 0 <= r; r--)
          0 === t[r].children.length
            ? 0 < r
              ? (e = t[r - 1].children).splice(e.indexOf(t[r]), 1)
              : this.clear()
            : Be(t[r], this.toBBox);
      },
      _initFormat: function (t) {
        var e = ["return a", " - b", ";"];
        (this.compareMinX = new Function("a", "b", e.join(t[0]))),
          (this.compareMinY = new Function("a", "b", e.join(t[1]))),
          (this.toBBox = new Function(
            "a",
            "return {minX: a" +
              t[0] +
              ", minY: a" +
              t[1] +
              ", maxX: a" +
              t[2] +
              ", maxY: a" +
              t[3] +
              "};"
          ));
      },
    };
    var qe = Pe;
    function Ye(t, e, r) {
      if (!He((r = r || {}))) throw new Error("options is invalid");
      var n = r.bbox,
        i = r.id;
      if (void 0 === t) throw new Error("geometry is required");
      if (e && e.constructor !== Object)
        throw new Error("properties must be an Object");
      n && Ke(n), i && $e(i);
      var o = { type: "Feature" };
      return (
        i && (o.id = i),
        n && (o.bbox = n),
        (o.properties = e || {}),
        (o.geometry = t),
        o
      );
    }
    function Xe(t, e, r) {
      if (!t) throw new Error("coordinates is required");
      if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
      if (t.length < 2)
        throw new Error("coordinates must be at least 2 numbers long");
      if (!Ve(t[0]) || !Ve(t[1]))
        throw new Error("coordinates must contain numbers");
      return Ye({ type: "Point", coordinates: t }, e, r);
    }
    function Ue(t, e, r) {
      if (!t) throw new Error("coordinates is required");
      if (t.length < 2)
        throw new Error(
          "coordinates must be an array of two or more positions"
        );
      if (!Ve(t[0][1]) || !Ve(t[0][1]))
        throw new Error("coordinates must contain numbers");
      return Ye({ type: "LineString", coordinates: t }, e, r);
    }
    function Je(t, e) {
      if (!He((e = e || {}))) throw new Error("options is invalid");
      var r = e.bbox,
        n = e.id;
      if (!t) throw new Error("No features passed");
      if (!Array.isArray(t)) throw new Error("features must be an Array");
      r && Ke(r), n && $e(n);
      var i = { type: "FeatureCollection" };
      return n && (i.id = n), r && (i.bbox = r), (i.features = t), i;
    }
    function Ve(t) {
      return !isNaN(t) && null !== t && !Array.isArray(t);
    }
    function He(t) {
      return !!t && t.constructor === Object;
    }
    function Ke(t) {
      if (!t) throw new Error("bbox is required");
      if (!Array.isArray(t)) throw new Error("bbox must be an Array");
      if (4 !== t.length && 6 !== t.length)
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      t.forEach(function (t) {
        if (!Ve(t)) throw new Error("bbox must only contain numbers");
      });
    }
    function $e(t) {
      if (!t) throw new Error("id is required");
      if (-1 === ["string", "number"].indexOf(typeof t))
        throw new Error("id must be a number or a string");
    }
    function Ze(t, e) {
      if ("Feature" === t.type) e(t, 0);
      else if ("FeatureCollection" === t.type)
        for (
          var r = 0;
          r < t.features.length && !1 !== e(t.features[r], r);
          r++
        );
    }
    function We(t, e) {
      !(function (t, e) {
        var r,
          n,
          i,
          o,
          a,
          s,
          l,
          h,
          u,
          c,
          f = 0,
          p = "FeatureCollection" === t.type,
          d = "Feature" === t.type,
          g = p ? t.features.length : 1;
        for (r = 0; r < g; r++) {
          for (
            s = p ? t.features[r].geometry : d ? t.geometry : t,
              h = p ? t.features[r].properties : d ? t.properties : {},
              u = p ? t.features[r].bbox : d ? t.bbox : void 0,
              c = p ? t.features[r].id : d ? t.id : void 0,
              a = (l = !!s && "GeometryCollection" === s.type)
                ? s.geometries.length
                : 1,
              i = 0;
            i < a;
            i++
          )
            if (null !== (o = l ? s.geometries[i] : s))
              switch (o.type) {
                case "Point":
                case "LineString":
                case "MultiPoint":
                case "Polygon":
                case "MultiLineString":
                case "MultiPolygon":
                  if (!1 === e(o, f, h, u, c)) return !1;
                  break;
                case "GeometryCollection":
                  for (n = 0; n < o.geometries.length; n++)
                    if (!1 === e(o.geometries[n], f, h, u, c)) return !1;
                  break;
                default:
                  throw new Error("Unknown Geometry Type");
              }
            else if (!1 === e(null, f, h, u, c)) return !1;
          f++;
        }
      })(t, function (t, r, n, i, o) {
        var a,
          s = null === t ? null : t.type;
        switch (s) {
          case null:
          case "Point":
          case "LineString":
          case "Polygon":
            return !1 !== e(Ye(t, n, { bbox: i, id: o }), r, 0) && void 0;
        }
        switch (s) {
          case "MultiPoint":
            a = "Point";
            break;
          case "MultiLineString":
            a = "LineString";
            break;
          case "MultiPolygon":
            a = "Polygon";
        }
        for (var l = 0; l < t.coordinates.length; l++) {
          var h = t.coordinates[l];
          if (!1 === e(Ye({ type: a, coordinates: h }, n), r, l)) return !1;
        }
      });
    }
    function Qe(t) {
      var e = [t[0], t[1]],
        r = [t[0], t[3]],
        n = [t[2], t[3]];
      return {
        type: "Feature",
        bbox: t,
        properties: {},
        geometry: {
          type: "Polygon",
          coordinates: [[e, [t[2], t[1]], n, r, e]],
        },
      };
    }
    function tr(t) {
      var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      return (
        (function t(e, r, n) {
          if (null !== e)
            for (
              var i,
                o,
                a,
                s,
                l,
                h,
                u,
                c,
                f = 0,
                p = 0,
                d = e.type,
                g = "FeatureCollection" === d,
                m = "Feature" === d,
                y = g ? e.features.length : 1,
                _ = 0;
              _ < y;
              _++
            ) {
              l = (c =
                !!(u = g ? e.features[_].geometry : m ? e.geometry : e) &&
                "GeometryCollection" === u.type)
                ? u.geometries.length
                : 1;
              for (var v = 0; v < l; v++) {
                var b = 0,
                  L = 0;
                if (null !== (s = c ? u.geometries[v] : u)) {
                  h = s.coordinates;
                  var k = s.type;
                  switch (
                    ((f =
                      !n || ("Polygon" !== k && "MultiPolygon" !== k) ? 0 : 1),
                    k)
                  ) {
                    case null:
                      break;
                    case "Point":
                      if (!1 === r(h, p, _, b, L)) return !1;
                      p++, b++;
                      break;
                    case "LineString":
                    case "MultiPoint":
                      for (i = 0; i < h.length; i++) {
                        if (!1 === r(h[i], p, _, b, L)) return !1;
                        p++, "MultiPoint" === k && b++;
                      }
                      "LineString" === k && b++;
                      break;
                    case "Polygon":
                    case "MultiLineString":
                      for (i = 0; i < h.length; i++) {
                        for (o = 0; o < h[i].length - f; o++) {
                          if (!1 === r(h[i][o], p, _, b, L)) return !1;
                          p++;
                        }
                        "MultiLineString" === k && b++, "Polygon" === k && L++;
                      }
                      "Polygon" === k && b++;
                      break;
                    case "MultiPolygon":
                      for (i = 0; i < h.length; i++) {
                        for (
                          "MultiPolygon" === k && (L = 0), o = 0;
                          o < h[i].length;
                          o++
                        ) {
                          for (a = 0; a < h[i][o].length - f; a++) {
                            if (!1 === r(h[i][o][a], p, _, b, L)) return !1;
                            p++;
                          }
                          L++;
                        }
                        b++;
                      }
                      break;
                    case "GeometryCollection":
                      for (i = 0; i < s.geometries.length; i++)
                        if (!1 === t(s.geometries[i], r, n)) return !1;
                      break;
                    default:
                      throw new Error("Unknown Geometry Type");
                  }
                }
              }
            }
        })(t, function (t) {
          e[0] > t[0] && (e[0] = t[0]),
            e[1] > t[1] && (e[1] = t[1]),
            e[2] < t[0] && (e[2] = t[0]),
            e[3] < t[1] && (e[3] = t[1]);
        }),
        e
      );
    }
    function er(t) {
      if (!t) throw new Error("coords is required");
      if ("Feature" === t.type && null !== t.geometry)
        return t.geometry.coordinates;
      if (t.coordinates) return t.coordinates;
      if (Array.isArray(t)) return t;
      throw new Error(
        "coords must be GeoJSON Feature, Geometry Object or an Array"
      );
    }
    var rr = function (t) {
      if (!t) throw new Error("geojson is required");
      var e = [];
      return (
        We(t, function (t) {
          !(function (t, e) {
            var r = [],
              n = t.geometry;
            switch (n.type) {
              case "Polygon":
                r = er(n);
                break;
              case "LineString":
                r = [er(n)];
            }
            r.forEach(function (r) {
              (function (t, e) {
                var r = [];
                return (
                  t.reduce(function (t, n) {
                    var i = Ue([t, n], e);
                    return (
                      (i.bbox = (function (t, e) {
                        var r = t[0],
                          n = t[1],
                          i = e[0],
                          o = e[1];
                        return [
                          r < i ? r : i,
                          n < o ? n : o,
                          i < r ? r : i,
                          o < n ? n : o,
                        ];
                      })(t, n)),
                      r.push(i),
                      n
                    );
                  }),
                  r
                );
              })(r, t.properties).forEach(function (t) {
                (t.id = e.length), e.push(t);
              });
            });
          })(t, e);
        }),
        Je(e)
      );
    };
    function nr(t, e) {
      var r = er(t),
        n = er(e);
      if (2 !== r.length)
        throw new Error("<intersects> line1 must only contain 2 coordinates");
      if (2 !== n.length)
        throw new Error("<intersects> line2 must only contain 2 coordinates");
      var i = r[0][0],
        o = r[0][1],
        a = r[1][0],
        s = r[1][1],
        l = n[0][0],
        h = n[0][1],
        u = n[1][0],
        c = n[1][1],
        f = (c - h) * (a - i) - (u - l) * (s - o);
      if (0 == f) return null;
      var p = ((u - l) * (o - h) - (c - h) * (i - l)) / f,
        d = ((a - i) * (o - h) - (s - o) * (i - l)) / f;
      return 0 <= p && p <= 1 && 0 <= d && d <= 1
        ? Xe([i + p * (a - i), o + p * (s - o)])
        : null;
    }
    var ir = function (t, e) {
      var r = {},
        n = [];
      if (
        ("LineString" === t.type && (t = Ye(t)),
        "LineString" === e.type && (e = Ye(e)),
        "Feature" === t.type &&
          "Feature" === e.type &&
          "LineString" === t.geometry.type &&
          "LineString" === e.geometry.type &&
          2 === t.geometry.coordinates.length &&
          2 === e.geometry.coordinates.length)
      ) {
        var i = nr(t, e);
        return i && n.push(i), Je(n);
      }
      var o = (function (t) {
        var e = qe(t);
        return (
          (e.insert = function (t) {
            if (Array.isArray(t)) {
              var e = t;
              (t = Qe(e)).bbox = e;
            } else t.bbox = t.bbox ? t.bbox : tr(t);
            return qe.prototype.insert.call(this, t);
          }),
          (e.load = function (t) {
            var e = [];
            return (
              Array.isArray(t)
                ? t.forEach(function (t) {
                    var r = Qe(t);
                    (r.bbox = t), e.push(r);
                  })
                : Ze(t, function (t) {
                    (t.bbox = t.bbox ? t.bbox : tr(t)), e.push(t);
                  }),
              qe.prototype.load.call(this, e)
            );
          }),
          (e.remove = function (t) {
            if (Array.isArray(t)) {
              var e = t;
              (t = Qe(e)).bbox = e;
            }
            return qe.prototype.remove.call(this, t);
          }),
          (e.clear = function () {
            return qe.prototype.clear.call(this);
          }),
          (e.search = function (t) {
            return {
              type: "FeatureCollection",
              features: qe.prototype.search.call(this, this.toBBox(t)),
            };
          }),
          (e.collides = function (t) {
            return qe.prototype.collides.call(this, this.toBBox(t));
          }),
          (e.all = function () {
            return {
              type: "FeatureCollection",
              features: qe.prototype.all.call(this),
            };
          }),
          (e.toJSON = function () {
            return qe.prototype.toJSON.call(this);
          }),
          (e.fromJSON = function (t) {
            return qe.prototype.fromJSON.call(this, t);
          }),
          (e.toBBox = function (t) {
            var e;
            return {
              minX: (e = t.bbox
                ? t.bbox
                : Array.isArray(t) && 4 === t.length
                ? t
                : tr(t))[0],
              minY: e[1],
              maxX: e[2],
              maxY: e[3],
            };
          }),
          e
        );
      })();
      return (
        o.load(rr(e)),
        Ze(rr(t), function (t) {
          Ze(o.search(t), function (e) {
            var i = nr(t, e);
            if (i) {
              var o = er(i).join(",");
              r[o] || ((r[o] = !0), n.push(i));
            }
          });
        }),
        Je(n)
      );
    };
    function or(t, e) {
      var r = [],
        n = ne();
      return (
        te(e, function (e) {
          if (
            (r.forEach(function (t, e) {
              t.id = e;
            }),
            r.length)
          ) {
            var i = n.search(e);
            if (i.features.length) {
              var o = sr(e, i);
              (r = r.filter(function (t) {
                return t.id !== o.id;
              })),
                n.remove(o),
                Qt(ar(o, e), function (t) {
                  r.push(t), n.insert(t);
                });
            }
          } else
            (r = ar(t, e).features).forEach(function (t) {
              t.bbox ||
                (t.bbox = (function (t) {
                  var e = t[0],
                    r = t[1],
                    n = t[2],
                    i = t[3],
                    o = le(t.slice(0, 2), [n, r]);
                  if (le(t.slice(0, 2), [e, i]) <= o) {
                    var a = (r + i) / 2;
                    return [e, a - (n - e) / 2, n, a + (n - e) / 2];
                  }
                  var s = (e + n) / 2;
                  return [s - (i - r) / 2, r, s + (i - r) / 2, i];
                })(
                  (function (t) {
                    var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    return (
                      Wt(t, function (t) {
                        e[0] > t[0] && (e[0] = t[0]),
                          e[1] > t[1] && (e[1] = t[1]),
                          e[2] < t[0] && (e[2] = t[0]),
                          e[3] < t[1] && (e[3] = t[1]);
                      }),
                      e
                    );
                  })(t)
                ));
            }),
              n.load(Vt(r));
        }),
        Vt(r)
      );
    }
    function ar(t, e) {
      var r = [],
        n = ce(t)[0],
        i = ce(t)[t.geometry.coordinates.length - 1];
      if (lr(n, ue(e)) || lr(i, ue(e))) return Vt([t]);
      var o = ne(),
        a = pe(t);
      o.load(a);
      var s = o.search(e);
      if (!s.features.length) return Vt([t]);
      var l = sr(e, s),
        h = (function (t, e, r) {
          var n = r;
          return (
            Qt(t, function (t, i) {
              n = 0 === i && void 0 === r ? t : e(n, t, i);
            }),
            n
          );
        })(
          a,
          function (t, n, i) {
            var o = ce(n)[1],
              a = ue(e);
            return i === l.id
              ? (t.push(a), r.push(Jt(t)), lr(a, o) ? [a] : [a, o])
              : (t.push(o), t);
          },
          [n]
        );
      return 1 < h.length && r.push(Jt(h)), Vt(r);
    }
    function sr(t, e) {
      if (!e.features.length) throw new Error("lines must contain features");
      if (1 === e.features.length) return e.features[0];
      var r,
        n = 1 / 0;
      return (
        Qt(e, function (e) {
          var i = (function (t, e, r) {
            if (!He((r = r || {}))) throw new Error("options is invalid");
            var n = t.geometry ? t.geometry.type : t.type;
            if ("LineString" !== n && "MultiLineString" !== n)
              throw new Error("lines must be LineString or MultiLineString");
            var i = Xe([1 / 0, 1 / 0], { dist: 1 / 0 }),
              o = 0;
            return (
              We(t, function (t) {
                for (var n = er(t), a = 0; a < n.length - 1; a++) {
                  var s = Xe(n[a]);
                  s.properties.dist = le(e, s, r);
                  var l = Xe(n[a + 1]);
                  l.properties.dist = le(e, l, r);
                  var h = le(s, l, r),
                    u = Math.max(s.properties.dist, l.properties.dist),
                    c = ye(s, l),
                    f = xe(e, u, c + 90, r),
                    p = xe(e, u, c - 90, r),
                    d = ir(
                      Ue([f.geometry.coordinates, p.geometry.coordinates]),
                      Ue([s.geometry.coordinates, l.geometry.coordinates])
                    ),
                    g = null;
                  0 < d.features.length &&
                    (((g = d.features[0]).properties.dist = le(e, g, r)),
                    (g.properties.location = o + le(s, g, r))),
                    s.properties.dist < i.properties.dist &&
                      (((i = s).properties.index = a),
                      (i.properties.location = o)),
                    l.properties.dist < i.properties.dist &&
                      (((i = l).properties.index = a + 1),
                      (i.properties.location = o + h)),
                    g &&
                      g.properties.dist < i.properties.dist &&
                      ((i = g).properties.index = a),
                    (o += h);
                }
              }),
              i
            );
          })(e, t).properties.dist;
          i < n && ((r = e), (n = i));
        }),
        r
      );
    }
    function lr(t, e) {
      return t[0] === e[0] && t[1] === e[1];
    }
    var hr = function (t, e) {
      if (!t) throw new Error("line is required");
      if (!e) throw new Error("splitter is required");
      var r = fe(t),
        n = fe(e);
      if ("LineString" !== r) throw new Error("line must be LineString");
      if ("FeatureCollection" === n)
        throw new Error("splitter cannot be a FeatureCollection");
      if ("GeometryCollection" === n)
        throw new Error("splitter cannot be a GeometryCollection");
      var i = he(e, { precision: 7 });
      switch (n) {
        case "Point":
          return ar(t, i);
        case "MultiPoint":
          return or(t, i);
        case "LineString":
        case "MultiLineString":
        case "Polygon":
        case "MultiPolygon":
          return or(
            t,
            (function (t, e) {
              var r = {},
                n = [];
              if (
                ("LineString" === t.type && (t = Ut(t)),
                "LineString" === e.type && (e = Ut(e)),
                "Feature" === t.type &&
                  "Feature" === e.type &&
                  "LineString" === t.geometry.type &&
                  "LineString" === e.geometry.type &&
                  2 === t.geometry.coordinates.length &&
                  2 === e.geometry.coordinates.length)
              ) {
                var i = de(t, e);
                return i && n.push(i), Vt(n);
              }
              var o = ne();
              return (
                o.load(pe(e)),
                Qt(pe(t), function (t) {
                  Qt(o.search(t), function (e) {
                    var i = de(t, e);
                    if (i) {
                      var o = ce(i).join(",");
                      r[o] || ((r[o] = !0), n.push(i));
                    }
                  });
                }),
                Vt(n)
              );
            })(t, i)
          );
      }
    };
    function ur(t, e) {
      (null == e || e > t.length) && (e = t.length);
      for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
      return n;
    }
    function cr(t, e, r) {
      if (!fr((r = r || {}))) throw new Error("options is invalid");
      var n = r.bbox,
        i = r.id;
      if (void 0 === t) throw new Error("geometry is required");
      if (e && e.constructor !== Object)
        throw new Error("properties must be an Object");
      n && pr(n), i && dr(i);
      var o = { type: "Feature" };
      return (
        i && (o.id = i),
        n && (o.bbox = n),
        (o.properties = e || {}),
        (o.geometry = t),
        o
      );
    }
    function fr(t) {
      return !!t && t.constructor === Object;
    }
    function pr(t) {
      if (!t) throw new Error("bbox is required");
      if (!Array.isArray(t)) throw new Error("bbox must be an Array");
      if (4 !== t.length && 6 !== t.length)
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      t.forEach(function (t) {
        if (
          !(function (t) {
            return !isNaN(t) && null !== t && !Array.isArray(t);
          })(t)
        )
          throw new Error("bbox must only contain numbers");
      });
    }
    function dr(t) {
      if (!t) throw new Error("id is required");
      if (-1 === ["string", "number"].indexOf(typeof t))
        throw new Error("id must be a number or a string");
    }
    function gr(t, e) {
      !(function (t, e) {
        var r,
          n,
          i,
          o,
          a,
          s,
          l,
          h,
          u,
          c,
          f = 0,
          p = "FeatureCollection" === t.type,
          d = "Feature" === t.type,
          g = p ? t.features.length : 1;
        for (r = 0; r < g; r++) {
          for (
            s = p ? t.features[r].geometry : d ? t.geometry : t,
              h = p ? t.features[r].properties : d ? t.properties : {},
              u = p ? t.features[r].bbox : d ? t.bbox : void 0,
              c = p ? t.features[r].id : d ? t.id : void 0,
              a = (l = !!s && "GeometryCollection" === s.type)
                ? s.geometries.length
                : 1,
              i = 0;
            i < a;
            i++
          )
            if (null !== (o = l ? s.geometries[i] : s))
              switch (o.type) {
                case "Point":
                case "LineString":
                case "MultiPoint":
                case "Polygon":
                case "MultiLineString":
                case "MultiPolygon":
                  if (!1 === e(o, f, h, u, c)) return !1;
                  break;
                case "GeometryCollection":
                  for (n = 0; n < o.geometries.length; n++)
                    if (!1 === e(o.geometries[n], f, h, u, c)) return !1;
                  break;
                default:
                  throw new Error("Unknown Geometry Type");
              }
            else if (!1 === e(null, f, h, u, c)) return !1;
          f++;
        }
      })(t, function (t, r, n, i, o) {
        var a,
          s = null === t ? null : t.type;
        switch (s) {
          case null:
          case "Point":
          case "LineString":
          case "Polygon":
            return !1 !== e(cr(t, n, { bbox: i, id: o }), r, 0) && void 0;
        }
        switch (s) {
          case "MultiPoint":
            a = "Point";
            break;
          case "MultiLineString":
            a = "LineString";
            break;
          case "MultiPolygon":
            a = "Polygon";
        }
        for (var l = 0; l < t.coordinates.length; l++) {
          var h = t.coordinates[l];
          if (!1 === e(cr({ type: a, coordinates: h }, n), r, l)) return !1;
        }
      });
    }
    xt.Cut = xt.Polygon.extend({
      initialize: function (t) {
        (this._map = t),
          (this._shape = "Cut"),
          (this.toolbarButtonName = "cutPolygon");
      },
      _cut: function (t) {
        var e = this,
          r = this._map._layers,
          n = t._latlngInfos || [];
        Object.keys(r)
          .map(function (t) {
            return r[t];
          })
          .filter(function (t) {
            return t.pm;
          })
          .filter(function (t) {
            return t instanceof L.Polyline;
          })
          .filter(function (e) {
            return e !== t;
          })
          .filter(function (t) {
            return !e._layerGroup.hasLayer(t);
          })
          .filter(function (e) {
            try {
              return (
                0 < !!T()(t.toGeoJSON(15), e.toGeoJSON(15)).features.length ||
                !!(function (t, e) {
                  var r = E(t),
                    n = E(e),
                    i = x.a.intersection(r.coordinates, n.coordinates);
                  return 0 === i.length
                    ? null
                    : 1 === i.length
                    ? P(i[0])
                    : O(i);
                })(t.toGeoJSON(15), e.toGeoJSON(15))
              );
            } catch (t) {
              return (
                console.error("You cant cut polygons with self-intersections"),
                !1
              );
            }
          })
          .forEach(function (r) {
            var i;
            if (r instanceof L.Polygon) {
              var o = (i = L.polygon(r.getLatLngs())).getLatLngs();
              n.forEach(function (t) {
                if (t && t.snapInfo) {
                  var r = t.latlng,
                    n = e._calcClosestLayer(r, [i]);
                  if (n && n.segment && n.distance < e.options.snapDistance) {
                    var a = n.segment;
                    if (a && 2 === a.length) {
                      var s = at._getIndexFromSegment(o, a),
                        l = s.indexPath,
                        h = s.parentPath,
                        u = s.newIndex;
                      (1 < l.length ? b()(o, h) : o).splice(u, 0, r);
                    }
                  }
                }
              });
            } else i = r;
            var a = e._cutLayer(t, i),
              s = L.geoJSON(a, r.options);
            1 === s.getLayers().length &&
              (s = (function (t, e) {
                return (
                  (function (t) {
                    if (Array.isArray(t)) return t;
                  })(t) ||
                  (function (t, e) {
                    if (
                      "undefined" != typeof Symbol &&
                      Symbol.iterator in Object(t)
                    ) {
                      var r = [],
                        n = !0,
                        i = !1,
                        o = void 0;
                      try {
                        for (
                          var a, s = t[Symbol.iterator]();
                          !(n = (a = s.next()).done) &&
                          (r.push(a.value), !e || r.length !== e);
                          n = !0
                        );
                      } catch (t) {
                        (i = !0), (o = t);
                      } finally {
                        try {
                          n || null == s.return || s.return();
                        } finally {
                          if (i) throw o;
                        }
                      }
                      return r;
                    }
                  })(t, e) ||
                  (function (t, e) {
                    if (t) {
                      if ("string" == typeof t) return ur(t, e);
                      var r = Object.prototype.toString.call(t).slice(8, -1);
                      return (
                        "Object" === r &&
                          t.constructor &&
                          (r = t.constructor.name),
                        "Map" === r || "Set" === r
                          ? Array.from(t)
                          : "Arguments" === r ||
                            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
                          ? ur(t, e)
                          : void 0
                      );
                    }
                  })(t, e) ||
                  (function () {
                    throw new TypeError(
                      "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                  })()
                );
              })(s.getLayers(), 1)[0]);
            var l = s.addTo(e._map);
            l.pm.enable(e.options),
              l.pm.disable(),
              (r._pmTempLayer = !0),
              (t._pmTempLayer = !0),
              r.remove(),
              t.remove(),
              l.getLayers &&
                0 === l.getLayers().length &&
                e._map.pm.removeLayer({ target: l }),
              e._addDrawnLayerProp(l),
              l instanceof L.LayerGroup || l.pm.addMeasurementTooltipToLayer(l),
              e._editedLayers.push({ layer: l, originalLayer: r });
          });
      },
      _finishShape: function () {
        var t = this;
        if (
          ((this._editedLayers = []),
          this.options.allowSelfIntersection ||
            (this._handleSelfIntersection(!1), !this._doesSelfIntersect))
        ) {
          var e = this._layer.getLatLngs(),
            r = L.polygon(e, this.options.pathOptions);
          (r._latlngInfos = this._layer._latlngInfo),
            this._cut(r),
            this.disable(),
            this._cleanupSnapping(),
            this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1),
            delete this._tempSnapLayerIndex,
            this._editedLayers.forEach(function (e) {
              var r = e.layer,
                n = e.originalLayer;
              n.fire("pm:cut", { shape: t._shape, layer: r, originalLayer: n }),
                t._map.fire("pm:cut", {
                  shape: t._shape,
                  layer: r,
                  originalLayer: n,
                }),
                n.fire("pm:edit", { layer: n, shape: n.pm.getShape() });
            }),
            (this._editedLayers = []);
        }
      },
      _cutLayer: function (t, e) {
        var r,
          n = L.geoJSON();
        if (e instanceof L.Polygon)
          r = (function (t, e) {
            var r = E(t),
              n = E(e),
              i = x.a.difference(r.coordinates, n.coordinates);
            return 0 === i.length ? null : 1 === i.length ? P(i[0]) : O(i);
          })(e.toGeoJSON(15), t.toGeoJSON(15));
        else {
          var i = hr(e.toGeoJSON(15), t.toGeoJSON(15));
          if (!i) return null;
          L.geoJSON(i)
            .getLayers()
            .forEach(function (e) {
              M()(t.toGeoJSON(15), e.toGeoJSON(15)) || e.addTo(n);
            }),
            (r = n.toGeoJSON(15));
        }
        return r;
      },
    });
    var mr = function (t) {
      if (!t) throw new Error("geojson is required");
      var e = [];
      return (
        gr(t, function (t) {
          e.push(t);
        }),
        (function (t, e) {
          if (!fr((e = e || {}))) throw new Error("options is invalid");
          var r = e.bbox,
            n = e.id;
          if (!t) throw new Error("No features passed");
          if (!Array.isArray(t)) throw new Error("features must be an Array");
          r && pr(r), n && dr(n);
          var i = { type: "FeatureCollection" };
          return n && (i.id = n), r && (i.bbox = r), (i.features = t), i;
        })(e)
      );
    };
    function yr(t, e) {
      (null == e || e > t.length) && (e = t.length);
      for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
      return n;
    }
    xt.Split = xt.Line.extend({
      initialize: function (t) {
        (this._map = t),
          (this._shape = "Split"),
          (this.toolbarButtonName = "splitMode");
      },
      _split: function (t) {
        var e = this,
          r = this._map._layers;
        (this.options.splitOnlyMarkedLayers =
          this.options.splitOnlyMarkedLayers || !1),
          Object.keys(r)
            .map(function (t) {
              return r[t];
            })
            .filter(function (t) {
              return t.pm;
            })
            .filter(function (t) {
              return t instanceof L.Polyline;
            })
            .filter(function (e) {
              return e !== t;
            })
            .filter(function (t) {
              return !e._layerGroup.hasLayer(t);
            })
            .filter(function (t) {
              return (
                (!e.options.splitOnlyMarkedLayers &&
                  !1 !== t.options.splitMark) ||
                (e.options.splitOnlyMarkedLayers && !0 === t.options.splitMark)
              );
            })
            .filter(function (e) {
              try {
                return (
                  0 < !!T()(t.toGeoJSON(15), e.toGeoJSON(15)).features.length
                );
              } catch (t) {
                return (
                  console.error(
                    "You cant split polygons with self-intersections"
                  ),
                  !1
                );
              }
            })
            .forEach(function (r) {
              var n = e._splitLayer(t, r);
              if (n) {
                var i = L.geoJSON(n, r.options);
                1 === i.getLayers().length &&
                  (i = (function (t, e) {
                    return (
                      (function (t) {
                        if (Array.isArray(t)) return t;
                      })(t) ||
                      (function (t, e) {
                        if (
                          "undefined" != typeof Symbol &&
                          Symbol.iterator in Object(t)
                        ) {
                          var r = [],
                            n = !0,
                            i = !1,
                            o = void 0;
                          try {
                            for (
                              var a, s = t[Symbol.iterator]();
                              !(n = (a = s.next()).done) &&
                              (r.push(a.value), !e || r.length !== e);
                              n = !0
                            );
                          } catch (t) {
                            (i = !0), (o = t);
                          } finally {
                            try {
                              n || null == s.return || s.return();
                            } finally {
                              if (i) throw o;
                            }
                          }
                          return r;
                        }
                      })(t, e) ||
                      (function (t, e) {
                        if (t) {
                          if ("string" == typeof t) return yr(t, e);
                          var r = Object.prototype.toString
                            .call(t)
                            .slice(8, -1);
                          return (
                            "Object" === r &&
                              t.constructor &&
                              (r = t.constructor.name),
                            "Map" === r || "Set" === r
                              ? Array.from(t)
                              : "Arguments" === r ||
                                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                                  r
                                )
                              ? yr(t, e)
                              : void 0
                          );
                        }
                      })(t, e) ||
                      (function () {
                        throw new TypeError(
                          "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                        );
                      })()
                    );
                  })(i.getLayers(), 1)[0]);
                var o = i.addTo(e._map);
                o.pm.enable(e.options),
                  o.pm.disable(),
                  (r._pmTempLayer = !0),
                  (t._pmTempLayer = !0),
                  r.remove(),
                  t.remove(),
                  o.getLayers &&
                    0 === o.getLayers().length &&
                    e._map.pm.removeLayer({ target: o }),
                  r.fire("pm:split", {
                    shape: e._shape,
                    splitLayer: t,
                    layers: o,
                    originalLayer: r,
                  }),
                  e._map.fire("pm:split", {
                    shape: e._shape,
                    splitLayer: t,
                    layers: o,
                    originalLayer: r,
                  });
              }
            });
      },
      _splitLayer: function (t, e) {
        var r,
          n = this;
        try {
          var i = L.geoJSON();
          r =
            e instanceof L.Polygon
              ? (L.geoJSON(mr(e.toGeoJSON(15)))
                  .getLayers()
                  .forEach(function (e) {
                    var r = ot(t, e, n._map).toGeoJSON(15);
                    r ? i.addData(r) : i.addData(e.toGeoJSON(15));
                  }),
                i.toGeoJSON(15))
              : hr(e.toGeoJSON(15), t.toGeoJSON(15));
        } catch (t) {
          console.error(t), (r = null);
        }
        return r;
      },
      _finishShape: function () {
        if (
          this.options.allowSelfIntersection ||
          (this._handleSelfIntersection(!1), !this._doesSelfIntersect)
        ) {
          var t = this._layer.getLatLngs(),
            e = L.polyline(t, this.options.pathOptions);
          this._split(e),
            this.disable(),
            this._cleanupSnapping(),
            this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1),
            delete this._tempSnapLayerIndex;
        }
      },
    });
    var _r = {
        _initPinning: function () {
          this._assignPinEvents(this._markers);
        },
        _disablePinning: function () {
          var t = this;
          (0 < arguments.length && void 0 !== arguments[0]
            ? arguments[0]
            : this._markers
          ).forEach(function (e) {
            Array.isArray(e)
              ? t._disablePinning(e)
              : e.off("dragstart", t._onPinnedMarkerDragStart, t);
          });
        },
        _assignPinEvents: function (t) {
          var e = this;
          t.forEach(function (t) {
            Array.isArray(t)
              ? e._assignPinEvents(t)
              : (t.off("dragstart", e._onPinnedMarkerDragStart, e),
                t.on("dragstart", e._onPinnedMarkerDragStart, e));
          });
        },
        _onPinnedMarkerDragStart: function (t) {
          var e = this;
          (this.pinnedVertices = []), (this._enabledLayers = []);
          var r = this._map,
            n = t.target,
            i = n.getLatLng();
          (this.relevantLayers = this._getRelevantLayers(r)),
            this.relevantLayers.forEach(function (t) {
              var r =
                  t instanceof L.Marker || t instanceof L.CircleMarker
                    ? [t.getLatLng()]
                    : t.getLatLngs(),
                n = { indexPaths: at.findDeepCoordIndex(r, i), layer: t };
              0 < Object.keys(n.indexPaths).length &&
                (e.pinnedVertices.push(n),
                t.pm.enabled() && (e._enabledLayers.push(t), t.pm.disable()));
            });
          var o = t.type.includes("pm:") ? "pm:" : "";
          0 < this.pinnedVertices.length &&
            (n.on("".concat(o, "drag"), this._applyAnchorLatLng, this),
            n.off("".concat(o, "dragend"), this._onPinnedMarkerDragEnd, this),
            n.on("".concat(o, "dragend"), this._onPinnedMarkerDragEnd, this));
        },
        _onPinnedMarkerDragEnd: function (t) {
          var e = t.target;
          if (0 < this.pinnedVertices.length) {
            this._applyAnchorLatLng({ target: e, latlng: e.getLatLng() });
            var r = t.type.includes("pm:") ? "pm:" : "";
            e.off("".concat(r, "drag"), this._applyAnchorLatLng, this),
              this.pinnedVertices.forEach(function (t) {
                t.layer.fire("pm:edit");
              });
          }
          this._enabledLayers.forEach(function (t) {
            t.pm.enable();
          }),
            (this.pinnedVertices = []),
            (this._enabledLayers = []);
        },
        _applyAnchorLatLng: function (t) {
          var e = t.latlng;
          this.pinnedVertices.forEach(function (t) {
            var r =
                t.layer instanceof L.Marker ||
                t.layer instanceof L.CircleMarker,
              n = t.layer instanceof L.Rectangle,
              i = r ? [t.layer.getLatLng()] : t.layer.getLatLngs(),
              o = t.indexPaths,
              a = o.indexPath,
              s = o.index,
              l = o.parentPath;
            if (((1 < a.length ? b()(i, l) : i).splice(s, 1, e), r))
              t.layer.setLatLng(i[0]);
            else if (n) {
              var h = s + 2,
                u = h <= i[0].length - 1 ? h : s - 2,
                c = i[0][u],
                f = L.latLngBounds(e, c);
              t.layer.setBounds(f);
            } else t.layer.setLatLngs(i);
          });
        },
        _getRelevantLayers: function (t) {
          var e = this,
            r = [];
          return (
            t.eachLayer(function (t) {
              r.push(t);
            }),
            (r = (r = (r = r.filter(function (t) {
              return e._layer !== t;
            })).filter(function (t) {
              return t._latlng || (t._latlngs && 0 < t._latlngs.length);
            })).filter(function (t) {
              return !t._pmTempLayer;
            }))
          );
        },
      },
      vr = {
        enableLayerDrag: function () {
          if (
            (this.disable(),
            this._map || (this._map = this._layer._map),
            this._layer instanceof L.Marker)
          )
            return (
              this._layer.on("dragstart", this._fireDragStart, this),
              this._layer.on("drag", this._fireDrag, this),
              this._layer.on("dragend", this._fireDragEnd, this),
              this.options.snappable
                ? this._initSnappableMarkers()
                : this._disableSnapping(),
              this._layer.dragging && this._layer.dragging.enable(),
              void (
                this.options.measurement &&
                this._layer.on("drag", this._measurementDrag, this)
              )
            );
          (this._tempDragCoord = null),
            this._layer._map.options.preferCanvas
              ? (this._layer.on("mouseout", this.removeDraggingClass, this),
                this._layer.on("mouseover", this.addDraggingClass, this))
              : this.addDraggingClass(),
            (this._originalMapDragState = this._layer._map.dragging._enabled),
            (this._safeToCacheDragState = !0),
            this._layer.on("mousedown", this._dragMixinOnMouseDown, this),
            this._layer instanceof L.CircleMarker &&
              this.options.measurement &&
              this._layer.on("drag", this._measurementDrag, this);
        },
        disableLayerDrag: function () {
          if (this._layer instanceof L.Marker)
            return (
              this._layer.off("dragstart", this._fireDragStart, this),
              this._layer.off("drag", this._fireDrag, this),
              this._layer.off("dragend", this._fireDragEnd, this),
              this._layer.dragging && this._layer.dragging.disable(),
              void this._layer.off("drag", this._measurementDrag, this)
            );
          this._layer._map.options.preferCanvas
            ? (this._layer.off("mouseout", this.removeDraggingClass, this),
              this._layer.off("mouseover", this.addDraggingClass, this))
            : this.removeDraggingClass(),
            (this._safeToCacheDragState = !1),
            this._layer.off("mousedown", this._dragMixinOnMouseDown, this);
        },
        _dragMixinOnMouseUp: function () {
          var t = this,
            e = this._layer._path
              ? this._layer._path
              : this._layer._renderer._container;
          return (
            this._originalMapDragState && this._layer._map.dragging.enable(),
            (this._safeToCacheDragState = !0),
            this._layer._map.off("mousemove", this._dragMixinOnMouseMove, this),
            this._layer._map.off("mouseup", this._dragMixinOnMouseUp, this),
            !!this._dragging &&
              (this._layer instanceof L.CircleMarker &&
                this._layer.pm._updateHiddenPolyCircle(),
              window.setTimeout(function () {
                (t._dragging = !1),
                  L.DomUtil.removeClass(e, "leaflet-pm-dragging"),
                  t._fireDragEnd(),
                  t._fireEdit();
              }, 10),
              !0)
          );
        },
        _dragMixinOnMouseMove: function (t) {
          var e = this._layer._path
            ? this._layer._path
            : this._layer._renderer._container;
          this._dragging ||
            ((this._dragging = !0),
            L.DomUtil.addClass(e, "leaflet-pm-dragging"),
            this._layer.bringToFront(),
            this._originalMapDragState && this._layer._map.dragging.disable(),
            this._fireDragStart()),
            this._onLayerDrag(t);
        },
        _dragMixinOnMouseDown: function (t) {
          0 < t.originalEvent.button ||
            (this._safeToCacheDragState &&
              ((this._originalMapDragState = this._layer._map.dragging._enabled),
              (this._safeToCacheDragState = !1)),
            (this._tempDragCoord = t.latlng),
            this._layer._map.on("mouseup", this._dragMixinOnMouseUp, this),
            this._layer._map.on("mousemove", this._dragMixinOnMouseMove, this));
        },
        dragging: function () {
          return this._dragging;
        },
        _onLayerDrag: function (t) {
          var e = t.latlng,
            r = e.lat - this._tempDragCoord.lat,
            n = e.lng - this._tempDragCoord.lng,
            i = function t(e) {
              return e.map(function (e) {
                return Array.isArray(e)
                  ? t(e)
                  : { lat: e.lat + r, lng: e.lng + n };
              });
            };
          if (this._layer instanceof L.CircleMarker) {
            var o = i([this._layer.getLatLng()]);
            this._layer.setLatLng(o[0]);
          } else {
            var a = i(this._layer.getLatLngs());
            this._layer.setLatLngs(a);
          }
          (this._tempDragCoord = e), (t.layer = this._layer), this._fireDrag(t);
        },
        _fireDragStart: function () {
          this._layer.fire("pm:dragstart", {
            layer: this._layer,
            shape: this.getShape(),
          });
        },
        _fireDrag: function (t) {
          this._layer.fire(
            "pm:drag",
            Object.assign({}, t, { shape: this.getShape() })
          ),
            this._hideMesurementTooltip();
        },
        _hideMesurementTooltip: function () {
          this._layer.closeTooltip();
        },
        _measurementDrag: function () {
          this.calcMeasurement(this._layer),
            this.showMeasurementTooltip(this._layer, this._layer);
        },
        _fireDragEnd: function () {
          this._layer.fire("pm:dragend", {
            layer: this._layer,
            shape: this.getShape(),
          });
        },
        addDraggingClass: function () {
          var t = this._layer._path
            ? this._layer._path
            : this._layer._renderer._container;
          L.DomUtil.addClass(t, "leaflet-pm-draggable");
        },
        removeDraggingClass: function () {
          var t = this._layer._path
            ? this._layer._path
            : this._layer._renderer._container;
          L.DomUtil.removeClass(t, "leaflet-pm-draggable");
        },
      },
      br = L.Class.extend({
        includes: [vr, Lt, _r, wt],
        options: {
          snappable: !0,
          snapDistance: 20,
          pinning: !1,
          allowSelfIntersection: !0,
          allowSelfIntersectionEdit: !1,
          draggable: !0,
          limitMarkersToCount: -1,
          preventMarkerRemoval: !1,
          hideMiddleMarkers: !1,
          limitMarkersCountGlobally: !1,
          limitMarkersToViewport: !1,
          limitMarkersToZoom: -1,
          limitMarkersToClick: !1,
        },
        setOptions: function (t) {
          L.Util.setOptions(this, t);
        },
        applyOptions: function () {},
        isPolygon: function () {
          return this._layer instanceof L.Polygon;
        },
        getShape: function () {
          return this._shape;
        },
      });
    function Lr(t) {
      return (
        (function (t) {
          if (Array.isArray(t)) return kr(t);
        })(t) ||
        (function (t) {
          if ("undefined" != typeof Symbol && Symbol.iterator in Object(t))
            return Array.from(t);
        })(t) ||
        (function (t, e) {
          if (t) {
            if ("string" == typeof t) return kr(t, e);
            var r = Object.prototype.toString.call(t).slice(8, -1);
            return (
              "Object" === r && t.constructor && (r = t.constructor.name),
              "Map" === r || "Set" === r
                ? Array.from(t)
                : "Arguments" === r ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
                ? kr(t, e)
                : void 0
            );
          }
        })(t) ||
        (function () {
          throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        })()
      );
    }
    function kr(t, e) {
      (null == e || e > t.length) && (e = t.length);
      for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
      return n;
    }
    (br.LayerGroup = L.Class.extend({
      initialize: function (t) {
        var e = this;
        (this._layerGroup = t),
          (this._layers = this.findLayers()),
          this._layers.forEach(function (t) {
            return e._initLayer(t);
          }),
          this._layerGroup.on("layeradd", function (t) {
            t.target._pmTempLayer ||
              ((e._layers = e.findLayers()),
              t.layer.pm && e._initLayer(t.layer),
              t.target.pm.enabled() && e.enable(e.getOptions()));
          }),
          this._layerGroup.on("layerremove", function (t) {
            t.target._pmTempLayer || (e._layers = e.findLayers());
          });
      },
      findLayers: function () {
        var t = this._layerGroup.getLayers();
        return (t = (t = t.filter(function (t) {
          return !(t instanceof L.LayerGroup);
        })).filter(function (t) {
          return !!t.pm;
        })).filter(function (t) {
          return !t._pmTempLayer;
        });
      },
      _initLayer: function (t) {
        var e = this;
        [
          "pm:edit",
          "pm:update",
          "pm:enable",
          "pm:disable",
          "pm:remove",
          "pm:dragstart",
          "pm:drag",
          "pm:dragend",
          "pm:snap",
          "pm:unsnap",
          "pm:cut",
          "pm:intersect",
          "pm:markerdragend",
          "pm:markerdragstart",
          "pm:vertexadded",
          "pm:vertexremoved",
          "pm:centerplaced",
        ].forEach(function (r) {
          t.on(r, e._fireEvent, e);
        }),
          (t.pm._layerGroup = this._layerGroup);
      },
      _fireEvent: function (t) {
        this._layerGroup.fireEvent(t.type, t);
      },
      toggleEdit: function (t) {
        (this._options = t),
          this._layers.forEach(function (e) {
            e.pm.toggleEdit(t);
          });
      },
      enable: function (t) {
        (this._options = t),
          this._layers.forEach(function (e) {
            e.pm.enable(t);
          });
      },
      disable: function () {
        this._layers.forEach(function (t) {
          t.pm.disable();
        });
      },
      enabled: function () {
        var t = this._layers.find(function (t) {
          return t.pm.enabled();
        });
        return !!t;
      },
      dragging: function () {
        var t = this._layers.find(function (t) {
          return t.pm.dragging();
        });
        return !!t;
      },
      getOptions: function () {
        return this._options;
      },
    })),
      (br.Marker = br.extend({
        _shape: "Marker",
        initialize: function (t) {
          (this._layer = t),
            (this._enabled = !1),
            this._layer.on("dragend", this._onDragEnd, this),
            this.initMeasurement();
        },
        applyOptions: function () {
          this.initMeasurement(),
            this.options.pinning ? this._initPinning() : this._disablePinning(),
            this.options.snappable
              ? this._initSnappableMarkers()
              : this._disableSnapping(),
            this.options.draggable
              ? this.enableLayerDrag()
              : this.disableLayerDrag(),
            this._layer.on("drag", this._onDrag, this),
            this.options.preventMarkerRemoval ||
              this._layer.on("contextmenu", this._removeMarker, this);
        },
        toggleEdit: function (t) {
          this.enabled() ? this.disable() : this.enable(t);
        },
        enable: function () {
          var t =
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : { draggable: !0 };
          L.Util.setOptions(this, t),
            (this._map = this._layer._map),
            this.enabled() ||
              ((this._enabled = !0),
              this._layer.fire("pm:enable", {
                layer: this._layer,
                shape: this.getShape(),
              }),
              this.applyOptions());
        },
        enabled: function () {
          return this._enabled;
        },
        disable: function () {
          (this._enabled = !1),
            this.disableLayerDrag(),
            this._layer.off("contextmenu", this._removeMarker, this),
            this._layer.off("dragstart", this._onPinnedMarkerDragStart, this),
            this._layer.off("drag", this._onDrag, this),
            this._layer.fire("pm:disable", {
              layer: this._layer,
              shape: this.getShape(),
            }),
            this._layerEdited &&
              this._layer.fire("pm:update", {
                layer: this._layer,
                shape: this.getShape(),
              }),
            (this._layerEdited = !1);
        },
        _removeMarker: function (t) {
          var e = t.target;
          e.remove(),
            e.fire("pm:remove", { layer: e, shape: this.getShape() }),
            this._map.fire("pm:remove", { layer: e, shape: this.getShape() });
        },
        _onDragEnd: function (t) {
          t.target.fire("pm:edit", {
            layer: this._layer,
            shape: this.getShape(),
          }),
            (this._layerEdited = !0),
            this.addMeasurementTooltipToLayer(this._layer);
        },
        _onDrag: function () {
          this.calcMeasurement(this._layer),
            this.showMeasurementTooltip(this._layer, this._layer);
        },
        _initPinning: function () {
          var t = this._layer;
          t.off("dragstart", this._onPinnedMarkerDragStart, this),
            t.on("dragstart", this._onPinnedMarkerDragStart, this);
        },
        _disablePinning: function () {
          this._layer.off("dragstart", this._onPinnedMarkerDragStart, this);
        },
        _initSnappableMarkers: function () {
          var t = this._layer;
          (this.options.snapDistance = this.options.snapDistance || 30),
            t.off("drag", this._handleSnapping, this),
            t.on("drag", this._handleSnapping, this),
            t.off("dragend", this._cleanupSnapping, this),
            t.on("dragend", this._cleanupSnapping, this),
            t.off("pm:dragstart", this._unsnap, this),
            t.on("pm:dragstart", this._unsnap, this);
        },
        _disableSnapping: function () {
          var t = this._layer;
          t.off("drag", this._handleSnapping, this),
            t.off("dragend", this._cleanupSnapping, this),
            t.off("pm:dragstart", this._unsnap, this);
        },
      }));
    var Mr = {
      filterMarkerGroup: function () {
        (this.markerCache = []),
          this.createCache(),
          this._layer.on("pm:edit", this.createCache, this),
          this.applyLimitFilters({}),
          this.throttledApplyLimitFilters ||
            (this.throttledApplyLimitFilters = L.Util.throttle(
              this.applyLimitFilters,
              100,
              this
            )),
          this._layer.on("pm:disable", this._removeMarkerLimitEvents, this),
          -1 < this.options.limitMarkersToCount &&
            (this._layer.on("pm:vertexremoved", this._initMarkers, this),
            this._map.on("mousemove", this.throttledApplyLimitFilters, this)),
          this.options.limitMarkersToClick &&
            ((this.isClicked = !1),
            this._layer.on("click", this.handleClickFlag, this)),
          (this.options.limitMarkersToViewport ||
            this.options.limitMarkersToZoom) &&
            this._map.on("moveend", this.applyLimitFilters, this);
      },
      _removeMarkerLimitEvents: function () {
        this._map.off("moveend", this.applyLimitFilters, this),
          this._map.off("mousemove", this.throttledApplyLimitFilters, this),
          this._layer.off("pm:edit", this.createCache, this),
          this._layer.off("pm:disable", this._removeMarkerLimitEvents, this),
          this._layer.off("pm:vertexremoved", this._initMarkers, this),
          this._layer.off("click", this.handleClickFlag, this);
      },
      createCache: function () {
        var t = [].concat(
          Lr(this._markerGroup.getLayers()),
          Lr(this.markerCache)
        );
        this.markerCache = t.filter(function (t, e, r) {
          return r.indexOf(t) === e;
        });
      },
      renderLimits: function (t) {
        var e = this;
        this.markerCache.forEach(function (r) {
          t.includes(r)
            ? e._markerGroup.addLayer(r)
            : e._markerGroup.removeLayer(r);
        });
      },
      applyLimitFilters: function (t) {
        var e = t.latlng,
          r = void 0 === e ? { lat: 0, lng: 0 } : e,
          n = this._filterClosestMarkers(r),
          i = [
            n,
            this._filterClosestGlobally(n, r),
            this._filterViewportMarkers(),
            this._filterMarkersInZoom(),
            this._filterMarkersOnClick(),
          ].reduce(function (t, e) {
            return t.filter(function (t) {
              return e.includes(t);
            });
          });
        this.renderLimits(i);
      },
      _filterMarkersOnClick: function () {
        var t = Lr(this.markerCache);
        return this.options.limitMarkersToClick ? (this.isClicked ? t : []) : t;
      },
      _filterMarkersInZoom: function () {
        var t = Lr(this.markerCache),
          e = this._map.getZoom();
        return this.options.limitMarkersToZoom <= e ? t : [];
      },
      _filterViewportMarkers: function () {
        var t = Lr(this.markerCache),
          e = this._map.getBounds(),
          r = this.options.limitMarkersToViewport;
        return t.filter(function (t) {
          return !r || e.contains(t.getLatLng());
        });
      },
      _filterClosestMarkers: function (t) {
        var e = Lr(this.markerCache),
          r = this.options.limitMarkersToCount;
        return -1 === r
          ? e
          : (e.sort(function (e, r) {
              return e._latlng.distanceTo(t) - r._latlng.distanceTo(t);
            }),
            e.filter(function (t, e) {
              return e < r;
            }));
      },
      _filterClosestGlobally: function (t, e) {
        return this._map.pm.globalOptions.limitMarkersCountGlobally
          ? this._map.pm._areMarkersClosestGlobally(t, e)
          : t;
      },
      handleClickFlag: function (t) {
        (this.isClicked = !this.isClicked), this.applyLimitFilters(t);
      },
    };
    function wr(t, e) {
      (null == e || e > t.length) && (e = t.length);
      for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
      return n;
    }
    (br.Line = br.extend({
      includes: [Mr],
      _shape: "Line",
      initialize: function (t) {
        (this._layer = t), (this._enabled = !1), this.initMeasurement();
      },
      applyOptions: function () {
        this.initMeasurement(),
          this.options.pinning ? this._initPinning() : this._disablePinning(),
          this.options.snappable
            ? this._initSnappableMarkers()
            : this._disableSnapping();
      },
      toggleEdit: function (t) {
        return this.enabled() ? this.disable() : this.enable(t), this.enabled();
      },
      enable: function (t) {
        L.Util.setOptions(this, t),
          (this._map = this._layer._map),
          this._map &&
            (this.enabled() || this.disable(),
            (this._enabled = !0),
            this._initMarkers(),
            this.applyOptions(),
            this._layer.fire("pm:enable", {
              layer: this._layer,
              shape: this.getShape(),
            }),
            this._layer.on("remove", this._onLayerRemove, this),
            this.options.allowSelfIntersection ||
              this._layer.on(
                "pm:vertexremoved",
                this._handleSelfIntersectionOnVertexRemoval,
                this
              ),
            (this.cachedColor = void 0),
            this.options.allowSelfIntersection ||
              ((this.cachedColor = this._layer.options.color),
              (this.isRed = !1),
              this._handleLayerStyle()));
      },
      _onLayerRemove: function (t) {
        this.disable(t.target);
      },
      enabled: function () {
        return this._enabled;
      },
      disable: function () {
        var t =
          0 < arguments.length && void 0 !== arguments[0]
            ? arguments[0]
            : this._layer;
        if (!this.enabled()) return !1;
        if ((this._disablePinning(), t.pm._dragging)) return !1;
        (t.pm._enabled = !1),
          t.pm._markerGroup.clearLayers(),
          t.pm._markerGroup.removeFrom(this._map),
          t.off("mousedown"),
          t.off("mouseup"),
          this._layer.off("remove", this._onLayerRemove, this),
          this.options.allowSelfIntersection ||
            this._layer.off(
              "pm:vertexremoved",
              this._handleSelfIntersectionOnVertexRemoval,
              this
            );
        var e = t._path ? t._path : this._layer._renderer._container;
        return (
          L.DomUtil.removeClass(e, "leaflet-pm-draggable"),
          this.hasSelfIntersection() &&
            L.DomUtil.removeClass(e, "leaflet-pm-invalid"),
          this._layer.fire("pm:disable", {
            layer: this._layer,
            shape: this.getShape(),
          }),
          this._layerEdited &&
            this._layer.fire("pm:update", {
              layer: this._layer,
              shape: this.getShape(),
            }),
          !(this._layerEdited = !1)
        );
      },
      hasSelfIntersection: function () {
        return 0 < Et()(this._layer.toGeoJSON(15)).features.length;
      },
      _handleSelfIntersectionOnVertexRemoval: function () {
        this._handleLayerStyle(!0),
          this.hasSelfIntersection() &&
            (this._layer.setLatLngs(this._coordsBeforeEdit),
            (this._coordsBeforeEdit = null),
            this._initMarkers());
      },
      _handleLayerStyle: function (t) {
        var e = this,
          r = this._layer;
        if (this.hasSelfIntersection()) {
          if (
            (!this.options.allowSelfIntersection &&
              this.options.allowSelfIntersectionEdit &&
              this._updateDisabledMarkerStyle(this._markers, !0),
            this.isRed)
          )
            return;
          t
            ? (r.setStyle({ color: "red" }),
              (this.isRed = !0),
              window.setTimeout(function () {
                r.setStyle({ color: e.cachedColor }), (e.isRed = !1);
              }, 200))
            : (r.setStyle({ color: "red" }), (this.isRed = !0)),
            this._layer.fire("pm:intersect", {
              layer: this._layer,
              intersection: Et()(this._layer.toGeoJSON(15)),
              shape: this.getShape(),
            });
        } else
          r.setStyle({ color: this.cachedColor }),
            (this.isRed = !1),
            !this.options.allowSelfIntersection &&
              this.options.allowSelfIntersectionEdit &&
              this._updateDisabledMarkerStyle(this._markers, !1);
      },
      _updateDisabledMarkerStyle: function (t, e) {
        var r = this;
        t.forEach(function (t) {
          return Array.isArray(t)
            ? r._updateDisabledMarkerStyle(t, e)
            : (t._icon &&
                (e && !r._checkMarkerAllowedToDrag(t)
                  ? L.DomUtil.addClass(t._icon, "vertexmarker-disabled")
                  : L.DomUtil.removeClass(t._icon, "vertexmarker-disabled")),
              !0);
        });
      },
      _initMarkers: function () {
        var t = this,
          e = this._map,
          r = this._layer.getLatLngs();
        this._markerGroup && this._markerGroup.clearLayers(),
          (this._markerGroup = new L.LayerGroup()),
          (this._markerGroup._pmTempLayer = !0);
        (this._markers = (function e(r) {
          if (Array.isArray(r[0])) return r.map(e, t);
          var n = r.map(t._createMarker, t);
          return (
            !0 !== t.options.hideMiddleMarkers &&
              r.map(function (e, i) {
                var o = t.isPolygon() ? (i + 1) % r.length : i + 1;
                return t._createMiddleMarker(n[i], n[o]);
              }),
            n
          );
        })(r)),
          this.filterMarkerGroup(),
          e.addLayer(this._markerGroup);
      },
      _createMarker: function (t) {
        var e = new L.Marker(t, {
          draggable: !0,
          icon: L.divIcon({ className: "marker-icon" }),
        });
        return (
          (e._pmTempLayer = !0),
          e.on("dragstart", this._onMarkerDragStart, this),
          e.on("move", this._onMarkerDrag, this),
          e.on("dragend", this._onMarkerDragEnd, this),
          this.options.preventMarkerRemoval ||
            e.on("contextmenu", this._removeMarker, this),
          this._markerGroup.addLayer(e),
          e
        );
      },
      _createMiddleMarker: function (t, e) {
        var r = this;
        if (!t || !e) return !1;
        var n = at.calcMiddleLatLng(this._map, t.getLatLng(), e.getLatLng()),
          i = this._createMarker(n),
          o = L.divIcon({ className: "marker-icon marker-icon-middle" });
        return (
          i.setIcon(o),
          (t._middleMarkerNext = i),
          (e._middleMarkerPrev = i).on("click", function () {
            var n = L.divIcon({ className: "marker-icon" });
            i.setIcon(n), r._addMarker(i, t, e);
          }),
          i.on("movestart", function () {
            i.on("moveend", function () {
              var t = L.divIcon({ className: "marker-icon" });
              i.setIcon(t), i.off("moveend");
            }),
              r._addMarker(i, t, e);
          }),
          i
        );
      },
      _addMarker: function (t, e, r) {
        t.off("movestart"), t.off("click");
        var n = t.getLatLng(),
          i = this._layer._latlngs,
          o = this.findDeepMarkerIndex(this._markers, e),
          a = o.indexPath,
          s = o.index,
          l = o.parentPath,
          h = 1 < a.length ? b()(i, l) : i,
          u = 1 < a.length ? b()(this._markers, l) : this._markers;
        h.splice(s + 1, 0, n),
          u.splice(s + 1, 0, t),
          this._layer.setLatLngs(i),
          !0 !== this.options.hideMiddleMarkers &&
            (this._createMiddleMarker(e, t), this._createMiddleMarker(t, r)),
          this._fireEdit(),
          this._layer.fire("pm:vertexadded", {
            layer: this._layer,
            marker: t,
            indexPath: this.findDeepMarkerIndex(this._markers, t).indexPath,
            latlng: n,
            shape: this.getShape(),
          }),
          this.options.snappable && this._initSnappableMarkers(),
          this.options.pinning && this._initPinning();
      },
      _removeMarker: function (t) {
        if (!this.options.allowSelfIntersection) {
          var e = this._layer.getLatLngs();
          this._coordsBeforeEdit = JSON.parse(JSON.stringify(e));
        }
        var r = t.target,
          n = this._layer.getLatLngs(),
          i = this.findDeepMarkerIndex(this._markers, r),
          o = i.indexPath,
          a = i.index,
          s = i.parentPath;
        if (o) {
          var l,
            h,
            u = 1 < o.length ? b()(n, s) : n,
            c = 1 < o.length ? b()(this._markers, s) : this._markers;
          if (
            (u.splice(a, 1),
            this._layer.setLatLngs(n),
            this.isPolygon() && u.length <= 2 && u.splice(0, u.length),
            u.length <= 1 &&
              (u.splice(0, u.length),
              this._layer.setLatLngs(n),
              this.disable(),
              this.enable(this.options)),
            (function (t) {
              return !(function t(e) {
                return e
                  .filter(function (t) {
                    return ![null, "", void 0].includes(t);
                  })
                  .reduce(function (e, r) {
                    return e.concat(Array.isArray(r) ? t(r) : r);
                  }, []);
              })(t).length;
            })(n) && this._layer.remove(),
            r._middleMarkerPrev &&
              this._markerGroup.removeLayer(r._middleMarkerPrev),
            r._middleMarkerNext &&
              this._markerGroup.removeLayer(r._middleMarkerNext),
            this._markerGroup.removeLayer(r),
            this.isPolygon()
              ? ((l = (a + 1) % c.length),
                (h = (a + (c.length - 1)) % c.length))
              : ((h = a - 1 < 0 ? void 0 : a - 1),
                (l = a + 1 >= c.length ? void 0 : a + 1)),
            l !== h)
          ) {
            var f = c[h],
              p = c[l];
            !0 !== this.options.hideMiddleMarkers &&
              this._createMiddleMarker(f, p);
          }
          c.splice(a, 1),
            this._fireEdit(),
            this._layer.fire("pm:vertexremoved", {
              layer: this._layer,
              marker: r,
              indexPath: o,
              shape: this.getShape(),
            });
        }
      },
      findDeepMarkerIndex: function (t, e) {
        var r;
        t.some(
          (function t(n) {
            return function (i, o) {
              var a = n.concat(o);
              return i._leaflet_id === e._leaflet_id
                ? ((r = a), !0)
                : Array.isArray(i) && i.some(t(a));
            };
          })([])
        );
        var n = {};
        return (
          r &&
            (n = {
              indexPath: r,
              index: r[r.length - 1],
              parentPath: r.slice(0, r.length - 1),
            }),
          n
        );
      },
      updatePolygonCoordsFromMarkerDrag: function (t) {
        var e = this._layer.getLatLngs(),
          r = t.getLatLng(),
          n = this.findDeepMarkerIndex(this._markers, t),
          i = n.indexPath,
          o = n.index,
          a = n.parentPath;
        (1 < i.length ? b()(e, a) : e).splice(o, 1, r),
          this._layer.setLatLngs(e);
      },
      _getNeighborMarkers: function (t) {
        var e = this.findDeepMarkerIndex(this._markers, t),
          r = e.indexPath,
          n = e.index,
          i = e.parentPath,
          o = 1 < r.length ? b()(this._markers, i) : this._markers,
          a = (n + 1) % o.length;
        return {
          prevMarker: o[(n + (o.length - 1)) % o.length],
          nextMarker: o[a],
        };
      },
      _onMarkerDrag: function (t) {
        var e = t.target,
          r = this.findDeepMarkerIndex(this._markers, e),
          n = r.indexPath,
          i = r.index,
          o = r.parentPath;
        if (n) {
          if (
            !this.options.allowSelfIntersection &&
            this.options.allowSelfIntersectionEdit &&
            this.hasSelfIntersection() &&
            !1 === this._markerAllowedToDrag
          )
            return (
              this._layer.setLatLngs(this._coordsBeforeEdit),
              this._initMarkers(),
              void this._handleLayerStyle()
            );
          this.updatePolygonCoordsFromMarkerDrag(e);
          var a = 1 < n.length ? b()(this._markers, o) : this._markers,
            s = (i + 1) % a.length,
            l = (i + (a.length - 1)) % a.length,
            h = e.getLatLng(),
            u = a[l].getLatLng(),
            c = a[s].getLatLng();
          if (e._middleMarkerNext) {
            var f = at.calcMiddleLatLng(this._map, h, c);
            e._middleMarkerNext.setLatLng(f);
          }
          if (e._middleMarkerPrev) {
            var p = at.calcMiddleLatLng(this._map, h, u);
            e._middleMarkerPrev.setLatLng(p);
          }
          this.options.allowSelfIntersection || this._handleLayerStyle(),
            this.calcMeasurement(this._layer),
            this.showMeasurementTooltip(this._layer, e);
        }
      },
      _onMarkerDragEnd: function (t) {
        var e = t.target,
          r = this.findDeepMarkerIndex(this._markers, e).indexPath;
        this._layer.fire("pm:markerdragend", {
          layer: this._layer,
          markerEvent: t,
          indexPath: r,
          shape: this.getShape(),
        });
        var n = this.hasSelfIntersection();
        if (
          (n &&
            this.options.allowSelfIntersectionEdit &&
            this._markerAllowedToDrag &&
            (n = !1),
          !this.options.allowSelfIntersection && n)
        )
          return (
            this._layer.setLatLngs(this._coordsBeforeEdit),
            (this._coordsBeforeEdit = null),
            this._initMarkers(),
            void this._handleLayerStyle()
          );
        !this.options.allowSelfIntersection &&
          this.options.allowSelfIntersectionEdit &&
          this._handleLayerStyle(),
          this._fireEdit(),
          this.addMeasurementTooltipToLayer(this._layer);
      },
      _onMarkerDragStart: function (t) {
        var e = t.target,
          r = this.findDeepMarkerIndex(this._markers, e).indexPath;
        this._layer.fire("pm:markerdragstart", {
          layer: this._layer,
          markerEvent: t,
          indexPath: r,
          shape: this.getShape(),
        }),
          this.options.allowSelfIntersection ||
            (this._coordsBeforeEdit = this._layer.getLatLngs()),
          this.cachedColor || (this.cachedColor = this._layer.options.color),
          !this.options.allowSelfIntersection &&
          this.options.allowSelfIntersectionEdit &&
          this.hasSelfIntersection()
            ? (this._markerAllowedToDrag = this._checkMarkerAllowedToDrag(e))
            : (this._markerAllowedToDrag = null);
      },
      _checkMarkerAllowedToDrag: function (t) {
        var e = this._getNeighborMarkers(t),
          r = e.prevMarker,
          n = e.nextMarker,
          i = L.polyline([r.getLatLng(), t.getLatLng()]),
          o = L.polyline([t.getLatLng(), n.getLatLng()]),
          a = T()(this._layer.toGeoJSON(15), i.toGeoJSON(15)).features.length,
          s = T()(this._layer.toGeoJSON(15), o.toGeoJSON(15)).features.length;
        return (
          t.getLatLng() === this._markers[0][0].getLatLng()
            ? (s += 1)
            : t.getLatLng() ===
                this._markers[0][this._markers[0].length - 1].getLatLng() &&
              (a += 1),
          !(a <= 2 && s <= 2)
        );
      },
      _fireEdit: function () {
        (this._layerEdited = !0),
          this._layer.fire("pm:edit", {
            layer: this._layer,
            shape: this.getShape(),
          });
      },
    })),
      (br.Polygon = br.Line.extend({
        _shape: "Polygon",
        _checkMarkerAllowedToDrag: function (t) {
          var e = this._getNeighborMarkers(t),
            r = e.prevMarker,
            n = e.nextMarker,
            i = L.polyline([r.getLatLng(), t.getLatLng()]),
            o = L.polyline([t.getLatLng(), n.getLatLng()]),
            a = T()(this._layer.toGeoJSON(15), i.toGeoJSON(15)).features.length,
            s = T()(this._layer.toGeoJSON(15), o.toGeoJSON(15)).features.length;
          return !(a <= 2 && s <= 2);
        },
      })),
      (br.Rectangle = br.Polygon.extend({
        _shape: "Rectangle",
        _initMarkers: function () {
          var t = this._map,
            e = this._findCorners();
          this._markerGroup && this._markerGroup.clearLayers(),
            (this._markerGroup = new L.LayerGroup()),
            (this._markerGroup._pmTempLayer = !0),
            t.addLayer(this._markerGroup),
            (this._markers = []),
            (this._markers[0] = e.map(this._createMarker, this));
          var r = (function (t, e) {
            return (
              (function (t) {
                if (Array.isArray(t)) return t;
              })(t) ||
              (function (t, e) {
                if (
                  "undefined" != typeof Symbol &&
                  Symbol.iterator in Object(t)
                ) {
                  var r = [],
                    n = !0,
                    i = !1,
                    o = void 0;
                  try {
                    for (
                      var a, s = t[Symbol.iterator]();
                      !(n = (a = s.next()).done) &&
                      (r.push(a.value), !e || r.length !== e);
                      n = !0
                    );
                  } catch (t) {
                    (i = !0), (o = t);
                  } finally {
                    try {
                      n || null == s.return || s.return();
                    } finally {
                      if (i) throw o;
                    }
                  }
                  return r;
                }
              })(t, e) ||
              (function (t, e) {
                if (t) {
                  if ("string" == typeof t) return wr(t, e);
                  var r = Object.prototype.toString.call(t).slice(8, -1);
                  return (
                    "Object" === r && t.constructor && (r = t.constructor.name),
                    "Map" === r || "Set" === r
                      ? Array.from(t)
                      : "Arguments" === r ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
                      ? wr(t, e)
                      : void 0
                  );
                }
              })(t, e) ||
              (function () {
                throw new TypeError(
                  "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                );
              })()
            );
          })(this._markers, 1);
          (this._cornerMarkers = r[0]),
            this.options.snappable && this._initSnappableMarkers();
        },
        _createMarker: function (t, e) {
          var r = new L.Marker(t, {
            draggable: !0,
            icon: L.divIcon({ className: "marker-icon" }),
          });
          return (
            (r._origLatLng = t),
            (r._index = e),
            (r._pmTempLayer = !0),
            r.on("dragstart", this._onMarkerDragStart, this),
            r.on("drag", this._onMarkerDrag, this),
            r.on("dragend", this._onMarkerDragEnd, this),
            r.on("pm:snap", this._adjustRectangleForMarkerSnap, this),
            this.options.preventMarkerRemoval ||
              r.on("contextmenu", this._removeMarker, this),
            this._markerGroup.addLayer(r),
            r
          );
        },
        _removeMarker: function () {
          return null;
        },
        _onMarkerDragStart: function (t) {
          var e = t.target,
            r = this._findCorners();
          (e._oppositeCornerLatLng = r[(e._index + 2) % 4]),
            (e._snapped = !1),
            this._layer.fire("pm:markerdragstart", {
              layer: this._layer,
              markerEvent: t,
              shape: this.getShape(),
              indexPath: void 0,
            });
        },
        _onMarkerDrag: function (t) {
          var e = t.target;
          void 0 !== e._index &&
            (e._snapped || this._adjustRectangleForMarkerMove(e),
            this.calcMeasurement(this._layer),
            this.showMeasurementTooltip(this._layer, e));
        },
        _onMarkerDragEnd: function (t) {
          var e = this._findCorners();
          this._adjustAllMarkers(e),
            this._cornerMarkers.forEach(function (t) {
              delete t._oppositeCornerLatLng;
            }),
            this._layer.setLatLngs(e),
            this._layer.fire("pm:markerdragend", {
              layer: this._layer,
              markerEvent: t,
              shape: this.getShape(),
              indexPath: void 0,
            }),
            this._fireEdit(),
            this.addMeasurementTooltipToLayer(this._layer);
        },
        _adjustRectangleForMarkerMove: function (t) {
          L.extend(t._origLatLng, t._latlng);
          var e = t.getLatLng();
          this._layer.setBounds(L.latLngBounds(e, t._oppositeCornerLatLng)),
            this._adjustAdjacentMarkers(t),
            this._layer.redraw();
        },
        _adjustRectangleForMarkerSnap: function (t) {
          if (this.options.snappable) {
            var e = t.target;
            this._adjustRectangleForMarkerMove(e);
          }
        },
        _adjustAllMarkers: function (t) {
          t.length && 4 === t.length
            ? this._cornerMarkers.forEach(function (e, r) {
                e.setLatLng(t[r]);
              })
            : console.error(
                "_adjustAllMarkers() requires an array of EXACTLY 4 LatLng coordinates"
              );
        },
        _adjustAdjacentMarkers: function (t) {
          if (t && t.getLatLng && t._oppositeCornerLatLng) {
            var e = t.getLatLng(),
              r = t._oppositeCornerLatLng,
              n = [];
            this._findCorners().forEach(function (t) {
              t.equals(e) || t.equals(r) || n.push(t);
            });
            var i = 0;
            2 === n.length &&
              this._cornerMarkers.forEach(function (t) {
                var o = t.getLatLng();
                o.equals(e) || o.equals(r) || (t.setLatLng(n[i]), (i += 1));
              });
          } else
            console.error(
              "_adjustAdjacentMarkers() requires a valid Marker object"
            );
        },
        _findCorners: function () {
          var t = this._layer.getBounds();
          return [
            t.getNorthWest(),
            t.getNorthEast(),
            t.getSouthEast(),
            t.getSouthWest(),
          ];
        },
      })),
      (br.Circle = br.extend({
        _shape: "Circle",
        initialize: function (t) {
          (this._layer = t),
            (this._enabled = !1),
            this._updateHiddenPolyCircle(),
            this.initMeasurement();
        },
        applyOptions: function () {
          this.initMeasurement(),
            this.options.pinning ? this._initPinning() : this._disablePinning(),
            this.options.snappable
              ? (this._initSnappableMarkers(),
                this._outerMarker.on("move", this._syncHintLine, this),
                this._outerMarker.on("move", this._syncCircleRadius, this),
                this._centerMarker.on("move", this._moveCircle, this))
              : this._disableSnapping();
        },
        _disableSnapping: function () {
          var t = this;
          this._markers.forEach(function (e) {
            e.off("move", t._syncHintLine, t),
              e.off("move", t._syncCircleRadius, t),
              e.off("drag", t._handleSnapping, t),
              e.off("dragend", t._cleanupSnapping, t);
          }),
            this._layer.off("pm:dragstart", this._unsnap, this);
        },
        toggleEdit: function (t) {
          this.enabled() ? this.disable() : this.enable(t);
        },
        enabled: function () {
          return this._enabled;
        },
        enable: function (t) {
          var e = this;
          L.Util.setOptions(this, t),
            (this._map = this._layer._map),
            this.enabled() || this.disable(),
            (this._enabled = !0),
            this._initMarkers(),
            this.applyOptions(),
            this._layer.fire("pm:enable", {
              layer: this._layer,
              shape: this.getShape(),
            }),
            this._layer.on("remove", function (t) {
              e.disable(t.target);
            }),
            this._updateHiddenPolyCircle();
        },
        disable: function () {
          var t =
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : this._layer;
          if (!this.enabled()) return !1;
          if (t.pm._dragging) return !1;
          this._centerMarker.off("dragstart", this._fireDragStart, this),
            this._centerMarker.off("drag", this._fireDrag, this),
            this._centerMarker.off("dragend", this._fireDragEnd, this),
            (t.pm._enabled = !1),
            t.pm._helperLayers.clearLayers(),
            t.off("mousedown"),
            t.off("mouseup");
          var e = t._path ? t._path : this._layer._renderer._container;
          return (
            L.DomUtil.removeClass(e, "leaflet-pm-draggable"),
            this._layer.fire("pm:disable", {
              layer: this._layer,
              shape: this.getShape(),
            }),
            this._layerEdited &&
              this._layer.fire("pm:update", {
                layer: this._layer,
                shape: this.getShape(),
              }),
            !(this._layerEdited = !1)
          );
        },
        _initMarkers: function () {
          var t = this._map;
          this._helperLayers && this._helperLayers.clearLayers(),
            (this._helperLayers = new L.LayerGroup()),
            (this._helperLayers._pmTempLayer = !0),
            this._helperLayers.addTo(t);
          var e = this._layer.getLatLng(),
            r = this._layer._radius,
            n = this._getLatLngOnCircle(e, r);
          (this._centerMarker = this._createCenterMarker(e)),
            (this._outerMarker = this._createOuterMarker(n)),
            (this._markers = [this._centerMarker, this._outerMarker]),
            this._createHintLine(this._centerMarker, this._outerMarker);
        },
        _getLatLngOnCircle: function (t, e) {
          var r = this._map.project(t),
            n = L.point(r.x + e, r.y);
          return this._map.unproject(n);
        },
        _resizeCircle: function () {
          this._syncHintLine(),
            this._syncCircleRadius(),
            this.calcMeasurement(this._layer),
            this.showMeasurementTooltip(this._layer, this._outerMarker);
        },
        _moveCircle: function (t) {
          var e = t.latlng;
          this._layer.setLatLng(e);
          var r = this._layer._radius,
            n = this._getLatLngOnCircle(e, r);
          this._outerMarker.setLatLng(n),
            this._syncHintLine(),
            this._updateHiddenPolyCircle(),
            this._layer.fire("pm:centerplaced", {
              layer: this._layer,
              latlng: e,
              shape: this.getShape(),
            });
        },
        _onMarkerDragStart: function (t) {
          this._layer.fire("pm:markerdragstart", {
            layer: this._layer,
            markerEvent: t,
            shape: this.getShape(),
            indexPath: void 0,
          });
        },
        _onMarkerDragEnd: function (t) {
          this._fireEdit(),
            this.addMeasurementTooltipToLayer(this._layer),
            this._layer.fire("pm:markerdragend", {
              layer: this._layer,
              markerEvent: t,
              shape: this.getShape(),
              indexPath: void 0,
            });
        },
        _syncCircleRadius: function () {
          var t = this._centerMarker.getLatLng(),
            e = this._outerMarker.getLatLng(),
            r = t.distanceTo(e);
          this._layer.setRadius(r),
            this._updateHiddenPolyCircle(),
            this._outerMarker._snapped && this.calcMeasurement(this._layer);
        },
        _syncHintLine: function () {
          var t = this._centerMarker.getLatLng(),
            e = this._outerMarker.getLatLng();
          this._hintline.setLatLngs([t, e]);
        },
        _createHintLine: function (t, e) {
          var r = t.getLatLng(),
            n = e.getLatLng();
          (this._hintline = L.polyline([r, n], this.options.hintlineStyle)),
            (this._hintline._pmTempLayer = !0),
            this._helperLayers.addLayer(this._hintline);
        },
        _createCenterMarker: function (t) {
          var e = this._createMarker(t);
          return (
            L.DomUtil.addClass(e._icon, "leaflet-pm-draggable"),
            e.on("drag", this._moveCircle, this),
            e.on("dragstart", this._fireDragStart, this),
            e.on("drag", this._fireDrag, this),
            e.on("dragend", this._fireDragEnd, this),
            e
          );
        },
        _createOuterMarker: function (t) {
          var e = this._createMarker(t);
          return e.on("drag", this._resizeCircle, this), e;
        },
        _createMarker: function (t) {
          var e = new L.Marker(t, {
            draggable: !0,
            icon: L.divIcon({ className: "marker-icon" }),
          });
          return (
            (e._origLatLng = t),
            (e._pmTempLayer = !0),
            e.on("dragstart", this._onMarkerDragStart, this),
            e.on("dragend", this._onMarkerDragEnd, this),
            this._helperLayers.addLayer(e),
            e
          );
        },
        _fireEdit: function () {
          this._layer.fire("pm:edit", {
            layer: this._layer,
            shape: this.getShape(),
          }),
            (this._layerEdited = !0);
        },
        _fireDragStart: function () {
          this._layer.fire("pm:dragstart", {
            layer: this._layer,
            shape: this.getShape(),
          });
        },
        _fireDrag: function (t) {
          this._layer.fire(
            "pm:drag",
            Object.assign({}, t, { shape: this.getShape() })
          );
        },
        _fireDragEnd: function () {
          this._layer.fire("pm:dragend", {
            layer: this._layer,
            shape: this.getShape(),
          });
        },
        _updateHiddenPolyCircle: function () {
          this._hiddenPolyCircle
            ? this._hiddenPolyCircle.setLatLngs(
                at.circleToPolygon(this._layer, 200).getLatLngs()
              )
            : (this._hiddenPolyCircle = at.circleToPolygon(this._layer, 200)),
            this._hiddenPolyCircle._parentCopy ||
              (this._hiddenPolyCircle._parentCopy = this._layer);
        },
      })),
      (br.CircleMarker = br.extend({
        _shape: "CircleMarker",
        initialize: function (t) {
          (this._layer = t),
            (this._enabled = !1),
            this._updateHiddenPolyCircle(),
            this.initMeasurement();
        },
        applyOptions: function () {
          this.initMeasurement(),
            !this.options.editable && this.options.draggable
              ? this.enableLayerDrag()
              : this.disableLayerDrag(),
            this.options.pinning ? this._initPinning() : this._disablePinning(),
            this.options.editable
              ? (this._initMarkers(),
                this._map.on("move", this._syncMarkers, this))
              : this._map.on("move", this._updateHiddenPolyCircle, this),
            this.options.snappable
              ? this.options.editable
                ? (this._initSnappableMarkers(),
                  this._outerMarker.on("move", this._syncHintLine, this),
                  this._outerMarker.on("move", this._syncCircleRadius, this))
                : this._initSnappableMarkersDrag()
              : this.options.editable
              ? this._disableSnapping()
              : this._disableSnappingDrag(),
            this._layer.on("pm:drag", this._onDrag, this),
            this.options.preventMarkerRemoval ||
              this._layer.on("contextmenu", this._removeMarker, this);
        },
        toggleEdit: function (t) {
          this.enabled() ? this.disable() : this.enable(t);
        },
        enabled: function () {
          return this._enabled;
        },
        enable: function () {
          var t =
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : { draggable: !0, snappable: !0 };
          L.Util.setOptions(this, t),
            (this._map = this._layer._map),
            this._map &&
              (this.enabled() || this.disable(),
              this.applyOptions(),
              this._layer.fire("pm:enable", {
                layer: this._layer,
                shape: this.getShape(),
              }),
              (this._enabled = !0),
              this._layer.on("pm:dragend", this._onMarkerDragEnd, this),
              this._updateHiddenPolyCircle());
        },
        disable: function () {
          var t =
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : this._layer;
          return !(
            t.pm._dragging ||
            (t.pm._helperLayers && t.pm._helperLayers.clearLayers(),
            this._map || (this._map = this._layer._map),
            this.options.editable
              ? this._map.off("move", this._syncMarkers, this)
              : this._map.off("move", this._updateHiddenPolyCircle, this),
            this.disableLayerDrag(),
            this._layer.off("drag", this._onDrag, this),
            this.enabled() ||
              (this._layer.fire("pm:disable", {
                layer: this._layer,
                shape: this.getShape(),
              }),
              this._layerEdited &&
                this._layer.fire("pm:update", {
                  layer: this._layer,
                  shape: this.getShape(),
                }),
              (this._layerEdited = !1)),
            this._layer.off("contextmenu", this._removeMarker, this),
            (t.pm._enabled = !1))
          );
        },
        _initMarkers: function () {
          var t = this._map;
          this._helperLayers && this._helperLayers.clearLayers(),
            (this._helperLayers = new L.LayerGroup()),
            (this._helperLayers._pmTempLayer = !0),
            this._helperLayers.addTo(t);
          var e = this._layer.getLatLng(),
            r = this._layer._radius,
            n = this._getLatLngOnCircle(e, r);
          (this._centerMarker = this._createCenterMarker(e)),
            (this._outerMarker = this._createOuterMarker(n)),
            (this._markers = [this._centerMarker, this._outerMarker]),
            this._createHintLine(this._centerMarker, this._outerMarker);
        },
        _getLatLngOnCircle: function (t, e) {
          var r = this._map.project(t),
            n = L.point(r.x + e, r.y);
          return this._map.unproject(n);
        },
        _createHintLine: function (t, e) {
          var r = t.getLatLng(),
            n = e.getLatLng();
          (this._hintline = L.polyline([r, n], this.options.hintlineStyle)),
            (this._hintline._pmTempLayer = !0),
            this._helperLayers.addLayer(this._hintline);
        },
        _createCenterMarker: function (t) {
          var e = this._createMarker(t);
          return (
            this.options.draggable
              ? (L.DomUtil.addClass(e._icon, "leaflet-pm-draggable"),
                e.on("drag", this._moveCircle, this))
              : e.dragging.disable(),
            e
          );
        },
        _moveCircle: function (t) {
          var e = t.latlng;
          this._layer.setLatLng(e);
          var r = this._layer._radius,
            n = this._getLatLngOnCircle(e, r);
          this._outerMarker.setLatLng(n),
            this._syncHintLine(),
            this._layer.fire("pm:centerplaced", {
              layer: this._layer,
              latlng: e,
              shape: this.getShape(),
            });
        },
        _createOuterMarker: function (t) {
          var e = this._createMarker(t);
          return e.on("drag", this._resizeCircle, this), e;
        },
        _createMarker: function (t) {
          var e = new L.Marker(t, {
            draggable: !0,
            icon: L.divIcon({ className: "marker-icon" }),
          });
          return (
            (e._origLatLng = t),
            (e._pmTempLayer = !0),
            e.on("dragstart", this._onMarkerDragStart, this),
            e.on("dragend", this._onMarkerDragEnd, this),
            this._helperLayers.addLayer(e),
            e
          );
        },
        _syncMarkers: function () {
          var t = this._layer.getLatLng(),
            e = this._layer._radius,
            r = this._getLatLngOnCircle(t, e);
          this._outerMarker.setLatLng(r),
            this._centerMarker.setLatLng(t),
            this._syncHintLine(),
            this._updateHiddenPolyCircle();
        },
        _resizeCircle: function () {
          this._syncHintLine(),
            this._syncCircleRadius(),
            this.calcMeasurement(this._layer),
            this.showMeasurementTooltip(this._layer, this._outerMarker);
        },
        _syncCircleRadius: function () {
          var t = this._centerMarker.getLatLng(),
            e = this._outerMarker.getLatLng(),
            r = this._map.project(t).distanceTo(this._map.project(e));
          this._layer.setRadius(r), this._updateHiddenPolyCircle();
        },
        _syncHintLine: function () {
          var t = this._centerMarker.getLatLng(),
            e = this._outerMarker.getLatLng();
          this._hintline.setLatLngs([t, e]);
        },
        _moveMarker: function (t) {
          var e = t.latlng;
          this._layer.setLatLng(e).redraw();
        },
        _removeMarker: function () {
          this.options.editable && this.disable(),
            this._layer.remove(),
            this._layer.fire("pm:remove", {
              layer: this._layer,
              shape: this.getShape(),
            }),
            this._map.fire("pm:remove", {
              layer: this._layer,
              shape: this.getShape(),
            });
        },
        _onMarkerDragStart: function (t) {
          this._layer.fire("pm:markerdragstart", {
            markerEvent: t,
            layer: this._layer,
            shape: this.getShape(),
            indexPath: void 0,
          });
        },
        _fireEdit: function () {
          this._layer.fire("pm:edit", {
            layer: this._layer,
            shape: this.getShape(),
          }),
            (this._layerEdited = !0);
        },
        _onDrag: function () {
          this.calcMeasurement(this._layer),
            this.options.editable
              ? this.showMeasurementTooltip(this._layer, this._outerMarker)
              : this.showMeasurementTooltip(this._layer, this._layer);
        },
        _onMarkerDragEnd: function (t) {
          this._layer.fire("pm:markerdragend", {
            layer: this._layer,
            markerEvent: t,
            shape: this.getShape(),
            indexPath: void 0,
          }),
            this._fireEdit(),
            this.addMeasurementTooltipToLayer(this._layer);
        },
        _initPinning: function () {
          var t = this._layer;
          t.off("pm:dragstart", this._onPinnedMarkerDragStart, this),
            t.on("pm:dragstart", this._onPinnedMarkerDragStart, this);
        },
        _disablePinning: function () {
          this._layer.off("pm:dragstart", this._onPinnedMarkerDragStart, this);
        },
        _initSnappableMarkersDrag: function () {
          var t = this._layer;
          (this.options.snapDistance = this.options.snapDistance || 30),
            t.off("pm:drag", this._handleSnapping, this),
            t.on("pm:drag", this._handleSnapping, this),
            t.off("pm:dragend", this._cleanupSnapping, this),
            t.on("pm:dragend", this._cleanupSnapping, this),
            t.off("pm:dragstart", this._unsnap, this),
            t.on("pm:dragstart", this._unsnap, this);
        },
        _disableSnappingDrag: function () {
          var t = this._layer;
          t.off("pm:drag", this._handleSnapping, this),
            t.off("pm:dragend", this._cleanupSnapping, this),
            t.off("pm:dragstart", this._unsnap, this);
        },
        _updateHiddenPolyCircle: function () {
          var t = this._layer._map || this._map;
          if (t) {
            var e = t.project(this._layer.getLatLng()),
              r = L.point(e.x + this._layer.getRadius(), e.y),
              n = this._layer.getLatLng().distanceTo(t.unproject(r)),
              i = L.circle(this._layer.getLatLng(), this._layer.options);
            i.setRadius(n),
              this._hiddenPolyCircle
                ? this._hiddenPolyCircle.setLatLngs(
                    at.circleToPolygon(i, 200).getLatLngs()
                  )
                : (this._hiddenPolyCircle = at.circleToPolygon(i, 200)),
              this._hiddenPolyCircle._parentCopy ||
                (this._hiddenPolyCircle._parentCopy = this._layer);
          }
        },
      })),
      r(163),
      r(164),
      (L.PM = L.PM || {
        version: n.a,
        Map: yt,
        Toolbar: bt,
        Draw: xt,
        Edit: br,
        Utils: at,
        activeLang: "en",
        initialize: function (t) {
          this.addInitHooks(t);
        },
        addInitHooks: function () {
          var t =
            0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
          L.Map.addInitHook(function () {
            (this.pm = void 0),
              t.optIn
                ? !1 === this.options.pmIgnore && (this.pm = new L.PM.Map(this))
                : this.options.pmIgnore || (this.pm = new L.PM.Map(this)),
              this.pm && this.pm.setGlobalOptions({});
          }),
            L.LayerGroup.addInitHook(function () {
              this.pm = new L.PM.Edit.LayerGroup(this);
            }),
            L.Marker.addInitHook(function () {
              (this.pm = void 0),
                t.optIn
                  ? !1 === this.options.pmIgnore &&
                    (this.pm = new L.PM.Edit.Marker(this))
                  : this.options.pmIgnore ||
                    (this.pm = new L.PM.Edit.Marker(this));
            }),
            L.CircleMarker.addInitHook(function () {
              (this.pm = void 0),
                t.optIn
                  ? !1 === this.options.pmIgnore &&
                    (this.pm = new L.PM.Edit.CircleMarker(this))
                  : this.options.pmIgnore ||
                    (this.pm = new L.PM.Edit.CircleMarker(this));
            }),
            L.Polyline.addInitHook(function () {
              (this.pm = void 0),
                t.optIn
                  ? !1 === this.options.pmIgnore &&
                    (this.pm = new L.PM.Edit.Line(this))
                  : this.options.pmIgnore ||
                    (this.pm = new L.PM.Edit.Line(this));
            }),
            L.Polygon.addInitHook(function () {
              (this.pm = void 0),
                t.optIn
                  ? !1 === this.options.pmIgnore &&
                    (this.pm = new L.PM.Edit.Polygon(this))
                  : this.options.pmIgnore ||
                    (this.pm = new L.PM.Edit.Polygon(this));
            }),
            L.Rectangle.addInitHook(function () {
              (this.pm = void 0),
                t.optIn
                  ? !1 === this.options.pmIgnore &&
                    (this.pm = new L.PM.Edit.Rectangle(this))
                  : this.options.pmIgnore ||
                    (this.pm = new L.PM.Edit.Rectangle(this));
            }),
            L.Circle.addInitHook(function () {
              (this.pm = void 0),
                t.optIn
                  ? !1 === this.options.pmIgnore &&
                    (this.pm = new L.PM.Edit.Circle(this))
                  : this.options.pmIgnore ||
                    (this.pm = new L.PM.Edit.Circle(this));
            });
        },
      }),
      L.PM.initialize();
  },
]);
